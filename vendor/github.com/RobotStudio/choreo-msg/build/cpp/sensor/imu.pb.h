// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor/imu.proto

#ifndef PROTOBUF_sensor_2fimu_2eproto__INCLUDED
#define PROTOBUF_sensor_2fimu_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "primitive/float.pb.h"
#include "primitive/header.pb.h"
#include "geometric/quaternion.pb.h"
#include "geometric/vector.pb.h"
// @@protoc_insertion_point(includes)
namespace choreo {
class Float;
class FloatDefaultTypeInternal;
extern FloatDefaultTypeInternal _Float_default_instance_;
class Float32;
class Float32DefaultTypeInternal;
extern Float32DefaultTypeInternal _Float32_default_instance_;
class Float32Array;
class Float32ArrayDefaultTypeInternal;
extern Float32ArrayDefaultTypeInternal _Float32Array_default_instance_;
class Float64;
class Float64DefaultTypeInternal;
extern Float64DefaultTypeInternal _Float64_default_instance_;
class Float64Array;
class Float64ArrayDefaultTypeInternal;
extern Float64ArrayDefaultTypeInternal _Float64Array_default_instance_;
class FloatArray;
class FloatArrayDefaultTypeInternal;
extern FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class IMU;
class IMUDefaultTypeInternal;
extern IMUDefaultTypeInternal _IMU_default_instance_;
class MagneticField;
class MagneticFieldDefaultTypeInternal;
extern MagneticFieldDefaultTypeInternal _MagneticField_default_instance_;
class NavSatFix;
class NavSatFixDefaultTypeInternal;
extern NavSatFixDefaultTypeInternal _NavSatFix_default_instance_;
class NavSatStatus;
class NavSatStatusDefaultTypeInternal;
extern NavSatStatusDefaultTypeInternal _NavSatStatus_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class QuaternionStamped;
class QuaternionStampedDefaultTypeInternal;
extern QuaternionStampedDefaultTypeInternal _QuaternionStamped_default_instance_;
class Vector3;
class Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class Vector3Stamped;
class Vector3StampedDefaultTypeInternal;
extern Vector3StampedDefaultTypeInternal _Vector3Stamped_default_instance_;
}  // namespace choreo

namespace choreo {

namespace protobuf_sensor_2fimu_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_sensor_2fimu_2eproto

enum NavSatStatus_Status {
  NavSatStatus_Status_NO_FIX = 0,
  NavSatStatus_Status_FIX = 1,
  NavSatStatus_Status_SBAS_FIX = 2,
  NavSatStatus_Status_GBAS_FIX = 3,
  NavSatStatus_Status_NavSatStatus_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NavSatStatus_Status_NavSatStatus_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NavSatStatus_Status_IsValid(int value);
const NavSatStatus_Status NavSatStatus_Status_Status_MIN = NavSatStatus_Status_NO_FIX;
const NavSatStatus_Status NavSatStatus_Status_Status_MAX = NavSatStatus_Status_GBAS_FIX;
const int NavSatStatus_Status_Status_ARRAYSIZE = NavSatStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* NavSatStatus_Status_descriptor();
inline const ::std::string& NavSatStatus_Status_Name(NavSatStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    NavSatStatus_Status_descriptor(), value);
}
inline bool NavSatStatus_Status_Parse(
    const ::std::string& name, NavSatStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NavSatStatus_Status>(
    NavSatStatus_Status_descriptor(), name, value);
}
enum NavSatStatus_Service {
  NavSatStatus_Service_GPS = 0,
  NavSatStatus_Service_GLONASS = 1,
  NavSatStatus_Service_COMPASS = 2,
  NavSatStatus_Service_GALILEO = 3,
  NavSatStatus_Service_NavSatStatus_Service_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NavSatStatus_Service_NavSatStatus_Service_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NavSatStatus_Service_IsValid(int value);
const NavSatStatus_Service NavSatStatus_Service_Service_MIN = NavSatStatus_Service_GPS;
const NavSatStatus_Service NavSatStatus_Service_Service_MAX = NavSatStatus_Service_GALILEO;
const int NavSatStatus_Service_Service_ARRAYSIZE = NavSatStatus_Service_Service_MAX + 1;

const ::google::protobuf::EnumDescriptor* NavSatStatus_Service_descriptor();
inline const ::std::string& NavSatStatus_Service_Name(NavSatStatus_Service value) {
  return ::google::protobuf::internal::NameOfEnum(
    NavSatStatus_Service_descriptor(), value);
}
inline bool NavSatStatus_Service_Parse(
    const ::std::string& name, NavSatStatus_Service* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NavSatStatus_Service>(
    NavSatStatus_Service_descriptor(), name, value);
}
enum NavSatFix_PositionCovarianceType {
  NavSatFix_PositionCovarianceType_UNKNOWN = 0,
  NavSatFix_PositionCovarianceType_APPROXIMATED = 1,
  NavSatFix_PositionCovarianceType_DIAGONAL_UNKNOWN = 2,
  NavSatFix_PositionCovarianceType_KNOWN = 3,
  NavSatFix_PositionCovarianceType_NavSatFix_PositionCovarianceType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NavSatFix_PositionCovarianceType_NavSatFix_PositionCovarianceType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NavSatFix_PositionCovarianceType_IsValid(int value);
const NavSatFix_PositionCovarianceType NavSatFix_PositionCovarianceType_PositionCovarianceType_MIN = NavSatFix_PositionCovarianceType_UNKNOWN;
const NavSatFix_PositionCovarianceType NavSatFix_PositionCovarianceType_PositionCovarianceType_MAX = NavSatFix_PositionCovarianceType_KNOWN;
const int NavSatFix_PositionCovarianceType_PositionCovarianceType_ARRAYSIZE = NavSatFix_PositionCovarianceType_PositionCovarianceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NavSatFix_PositionCovarianceType_descriptor();
inline const ::std::string& NavSatFix_PositionCovarianceType_Name(NavSatFix_PositionCovarianceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NavSatFix_PositionCovarianceType_descriptor(), value);
}
inline bool NavSatFix_PositionCovarianceType_Parse(
    const ::std::string& name, NavSatFix_PositionCovarianceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NavSatFix_PositionCovarianceType>(
    NavSatFix_PositionCovarianceType_descriptor(), name, value);
}
// ===================================================================

class IMU : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.IMU) */ {
 public:
  IMU();
  virtual ~IMU();

  IMU(const IMU& from);

  inline IMU& operator=(const IMU& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IMU& default_instance();

  static inline const IMU* internal_default_instance() {
    return reinterpret_cast<const IMU*>(
               &_IMU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(IMU* other);

  // implements Message ----------------------------------------------

  inline IMU* New() const PROTOBUF_FINAL { return New(NULL); }

  IMU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IMU& from);
  void MergeFrom(const IMU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IMU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.Float64 orientation_covariance = 3;
  int orientation_covariance_size() const;
  void clear_orientation_covariance();
  static const int kOrientationCovarianceFieldNumber = 3;
  const ::choreo::Float64& orientation_covariance(int index) const;
  ::choreo::Float64* mutable_orientation_covariance(int index);
  ::choreo::Float64* add_orientation_covariance();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
      mutable_orientation_covariance();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
      orientation_covariance() const;

  // repeated .choreo.Float64 angular_velocity_covariance = 5;
  int angular_velocity_covariance_size() const;
  void clear_angular_velocity_covariance();
  static const int kAngularVelocityCovarianceFieldNumber = 5;
  const ::choreo::Float64& angular_velocity_covariance(int index) const;
  ::choreo::Float64* mutable_angular_velocity_covariance(int index);
  ::choreo::Float64* add_angular_velocity_covariance();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
      mutable_angular_velocity_covariance();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
      angular_velocity_covariance() const;

  // repeated .choreo.Float64 linear_acceleration_covariance = 7;
  int linear_acceleration_covariance_size() const;
  void clear_linear_acceleration_covariance();
  static const int kLinearAccelerationCovarianceFieldNumber = 7;
  const ::choreo::Float64& linear_acceleration_covariance(int index) const;
  ::choreo::Float64* mutable_linear_acceleration_covariance(int index);
  ::choreo::Float64* add_linear_acceleration_covariance();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
      mutable_linear_acceleration_covariance();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
      linear_acceleration_covariance() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.Quaternion orientation = 2;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  const ::choreo::Quaternion& orientation() const;
  ::choreo::Quaternion* mutable_orientation();
  ::choreo::Quaternion* release_orientation();
  void set_allocated_orientation(::choreo::Quaternion* orientation);

  // .choreo.Vector3 angular_velocity = 4;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 4;
  const ::choreo::Vector3& angular_velocity() const;
  ::choreo::Vector3* mutable_angular_velocity();
  ::choreo::Vector3* release_angular_velocity();
  void set_allocated_angular_velocity(::choreo::Vector3* angular_velocity);

  // .choreo.Vector3 linear_acceleration = 6;
  bool has_linear_acceleration() const;
  void clear_linear_acceleration();
  static const int kLinearAccelerationFieldNumber = 6;
  const ::choreo::Vector3& linear_acceleration() const;
  ::choreo::Vector3* mutable_linear_acceleration();
  ::choreo::Vector3* release_linear_acceleration();
  void set_allocated_linear_acceleration(::choreo::Vector3* linear_acceleration);

  // @@protoc_insertion_point(class_scope:choreo.IMU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 > orientation_covariance_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 > angular_velocity_covariance_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 > linear_acceleration_covariance_;
  ::choreo::Header* header_;
  ::choreo::Quaternion* orientation_;
  ::choreo::Vector3* angular_velocity_;
  ::choreo::Vector3* linear_acceleration_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fimu_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MagneticField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.MagneticField) */ {
 public:
  MagneticField();
  virtual ~MagneticField();

  MagneticField(const MagneticField& from);

  inline MagneticField& operator=(const MagneticField& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MagneticField& default_instance();

  static inline const MagneticField* internal_default_instance() {
    return reinterpret_cast<const MagneticField*>(
               &_MagneticField_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MagneticField* other);

  // implements Message ----------------------------------------------

  inline MagneticField* New() const PROTOBUF_FINAL { return New(NULL); }

  MagneticField* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MagneticField& from);
  void MergeFrom(const MagneticField& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MagneticField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.Float64 magnetic_field_covariance = 3;
  int magnetic_field_covariance_size() const;
  void clear_magnetic_field_covariance();
  static const int kMagneticFieldCovarianceFieldNumber = 3;
  const ::choreo::Float64& magnetic_field_covariance(int index) const;
  ::choreo::Float64* mutable_magnetic_field_covariance(int index);
  ::choreo::Float64* add_magnetic_field_covariance();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
      mutable_magnetic_field_covariance();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
      magnetic_field_covariance() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.Vector3 magnetic_field = 2;
  bool has_magnetic_field() const;
  void clear_magnetic_field();
  static const int kMagneticFieldFieldNumber = 2;
  const ::choreo::Vector3& magnetic_field() const;
  ::choreo::Vector3* mutable_magnetic_field();
  ::choreo::Vector3* release_magnetic_field();
  void set_allocated_magnetic_field(::choreo::Vector3* magnetic_field);

  // @@protoc_insertion_point(class_scope:choreo.MagneticField)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 > magnetic_field_covariance_;
  ::choreo::Header* header_;
  ::choreo::Vector3* magnetic_field_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fimu_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NavSatStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.NavSatStatus) */ {
 public:
  NavSatStatus();
  virtual ~NavSatStatus();

  NavSatStatus(const NavSatStatus& from);

  inline NavSatStatus& operator=(const NavSatStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavSatStatus& default_instance();

  static inline const NavSatStatus* internal_default_instance() {
    return reinterpret_cast<const NavSatStatus*>(
               &_NavSatStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(NavSatStatus* other);

  // implements Message ----------------------------------------------

  inline NavSatStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  NavSatStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NavSatStatus& from);
  void MergeFrom(const NavSatStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NavSatStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NavSatStatus_Status Status;
  static const Status NO_FIX =
    NavSatStatus_Status_NO_FIX;
  static const Status FIX =
    NavSatStatus_Status_FIX;
  static const Status SBAS_FIX =
    NavSatStatus_Status_SBAS_FIX;
  static const Status GBAS_FIX =
    NavSatStatus_Status_GBAS_FIX;
  static inline bool Status_IsValid(int value) {
    return NavSatStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    NavSatStatus_Status_Status_MIN;
  static const Status Status_MAX =
    NavSatStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    NavSatStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return NavSatStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return NavSatStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return NavSatStatus_Status_Parse(name, value);
  }

  typedef NavSatStatus_Service Service;
  static const Service GPS =
    NavSatStatus_Service_GPS;
  static const Service GLONASS =
    NavSatStatus_Service_GLONASS;
  static const Service COMPASS =
    NavSatStatus_Service_COMPASS;
  static const Service GALILEO =
    NavSatStatus_Service_GALILEO;
  static inline bool Service_IsValid(int value) {
    return NavSatStatus_Service_IsValid(value);
  }
  static const Service Service_MIN =
    NavSatStatus_Service_Service_MIN;
  static const Service Service_MAX =
    NavSatStatus_Service_Service_MAX;
  static const int Service_ARRAYSIZE =
    NavSatStatus_Service_Service_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Service_descriptor() {
    return NavSatStatus_Service_descriptor();
  }
  static inline const ::std::string& Service_Name(Service value) {
    return NavSatStatus_Service_Name(value);
  }
  static inline bool Service_Parse(const ::std::string& name,
      Service* value) {
    return NavSatStatus_Service_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .choreo.NavSatStatus.Status nav_sat_status = 1;
  void clear_nav_sat_status();
  static const int kNavSatStatusFieldNumber = 1;
  ::choreo::NavSatStatus_Status nav_sat_status() const;
  void set_nav_sat_status(::choreo::NavSatStatus_Status value);

  // .choreo.NavSatStatus.Service nav_sat_service = 2;
  void clear_nav_sat_service();
  static const int kNavSatServiceFieldNumber = 2;
  ::choreo::NavSatStatus_Service nav_sat_service() const;
  void set_nav_sat_service(::choreo::NavSatStatus_Service value);

  // @@protoc_insertion_point(class_scope:choreo.NavSatStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int nav_sat_status_;
  int nav_sat_service_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fimu_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NavSatFix : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.NavSatFix) */ {
 public:
  NavSatFix();
  virtual ~NavSatFix();

  NavSatFix(const NavSatFix& from);

  inline NavSatFix& operator=(const NavSatFix& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavSatFix& default_instance();

  static inline const NavSatFix* internal_default_instance() {
    return reinterpret_cast<const NavSatFix*>(
               &_NavSatFix_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(NavSatFix* other);

  // implements Message ----------------------------------------------

  inline NavSatFix* New() const PROTOBUF_FINAL { return New(NULL); }

  NavSatFix* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NavSatFix& from);
  void MergeFrom(const NavSatFix& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NavSatFix* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NavSatFix_PositionCovarianceType PositionCovarianceType;
  static const PositionCovarianceType UNKNOWN =
    NavSatFix_PositionCovarianceType_UNKNOWN;
  static const PositionCovarianceType APPROXIMATED =
    NavSatFix_PositionCovarianceType_APPROXIMATED;
  static const PositionCovarianceType DIAGONAL_UNKNOWN =
    NavSatFix_PositionCovarianceType_DIAGONAL_UNKNOWN;
  static const PositionCovarianceType KNOWN =
    NavSatFix_PositionCovarianceType_KNOWN;
  static inline bool PositionCovarianceType_IsValid(int value) {
    return NavSatFix_PositionCovarianceType_IsValid(value);
  }
  static const PositionCovarianceType PositionCovarianceType_MIN =
    NavSatFix_PositionCovarianceType_PositionCovarianceType_MIN;
  static const PositionCovarianceType PositionCovarianceType_MAX =
    NavSatFix_PositionCovarianceType_PositionCovarianceType_MAX;
  static const int PositionCovarianceType_ARRAYSIZE =
    NavSatFix_PositionCovarianceType_PositionCovarianceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PositionCovarianceType_descriptor() {
    return NavSatFix_PositionCovarianceType_descriptor();
  }
  static inline const ::std::string& PositionCovarianceType_Name(PositionCovarianceType value) {
    return NavSatFix_PositionCovarianceType_Name(value);
  }
  static inline bool PositionCovarianceType_Parse(const ::std::string& name,
      PositionCovarianceType* value) {
    return NavSatFix_PositionCovarianceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .choreo.Float64 position_covariance = 6;
  int position_covariance_size() const;
  void clear_position_covariance();
  static const int kPositionCovarianceFieldNumber = 6;
  const ::choreo::Float64& position_covariance(int index) const;
  ::choreo::Float64* mutable_position_covariance(int index);
  ::choreo::Float64* add_position_covariance();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
      mutable_position_covariance();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
      position_covariance() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.NavSatStatus nav_sat_status = 2;
  bool has_nav_sat_status() const;
  void clear_nav_sat_status();
  static const int kNavSatStatusFieldNumber = 2;
  const ::choreo::NavSatStatus& nav_sat_status() const;
  ::choreo::NavSatStatus* mutable_nav_sat_status();
  ::choreo::NavSatStatus* release_nav_sat_status();
  void set_allocated_nav_sat_status(::choreo::NavSatStatus* nav_sat_status);

  // .choreo.Float64 latitude = 3;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 3;
  const ::choreo::Float64& latitude() const;
  ::choreo::Float64* mutable_latitude();
  ::choreo::Float64* release_latitude();
  void set_allocated_latitude(::choreo::Float64* latitude);

  // .choreo.Float64 longitude = 4;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 4;
  const ::choreo::Float64& longitude() const;
  ::choreo::Float64* mutable_longitude();
  ::choreo::Float64* release_longitude();
  void set_allocated_longitude(::choreo::Float64* longitude);

  // .choreo.Float64 altitude = 5;
  bool has_altitude() const;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 5;
  const ::choreo::Float64& altitude() const;
  ::choreo::Float64* mutable_altitude();
  ::choreo::Float64* release_altitude();
  void set_allocated_altitude(::choreo::Float64* altitude);

  // .choreo.NavSatFix.PositionCovarianceType position_covariance_type = 7;
  void clear_position_covariance_type();
  static const int kPositionCovarianceTypeFieldNumber = 7;
  ::choreo::NavSatFix_PositionCovarianceType position_covariance_type() const;
  void set_position_covariance_type(::choreo::NavSatFix_PositionCovarianceType value);

  // @@protoc_insertion_point(class_scope:choreo.NavSatFix)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 > position_covariance_;
  ::choreo::Header* header_;
  ::choreo::NavSatStatus* nav_sat_status_;
  ::choreo::Float64* latitude_;
  ::choreo::Float64* longitude_;
  ::choreo::Float64* altitude_;
  int position_covariance_type_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fimu_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// IMU

// .choreo.Header header = 1;
inline bool IMU::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void IMU::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& IMU::header() const {
  // @@protoc_insertion_point(field_get:choreo.IMU.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* IMU::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.IMU.header)
  return header_;
}
inline ::choreo::Header* IMU::release_header() {
  // @@protoc_insertion_point(field_release:choreo.IMU.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void IMU::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.IMU.header)
}

// .choreo.Quaternion orientation = 2;
inline bool IMU::has_orientation() const {
  return this != internal_default_instance() && orientation_ != NULL;
}
inline void IMU::clear_orientation() {
  if (GetArenaNoVirtual() == NULL && orientation_ != NULL) delete orientation_;
  orientation_ = NULL;
}
inline const ::choreo::Quaternion& IMU::orientation() const {
  // @@protoc_insertion_point(field_get:choreo.IMU.orientation)
  return orientation_ != NULL ? *orientation_
                         : *::choreo::Quaternion::internal_default_instance();
}
inline ::choreo::Quaternion* IMU::mutable_orientation() {
  
  if (orientation_ == NULL) {
    orientation_ = new ::choreo::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:choreo.IMU.orientation)
  return orientation_;
}
inline ::choreo::Quaternion* IMU::release_orientation() {
  // @@protoc_insertion_point(field_release:choreo.IMU.orientation)
  
  ::choreo::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void IMU::set_allocated_orientation(::choreo::Quaternion* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.IMU.orientation)
}

// repeated .choreo.Float64 orientation_covariance = 3;
inline int IMU::orientation_covariance_size() const {
  return orientation_covariance_.size();
}
inline void IMU::clear_orientation_covariance() {
  orientation_covariance_.Clear();
}
inline const ::choreo::Float64& IMU::orientation_covariance(int index) const {
  // @@protoc_insertion_point(field_get:choreo.IMU.orientation_covariance)
  return orientation_covariance_.Get(index);
}
inline ::choreo::Float64* IMU::mutable_orientation_covariance(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.IMU.orientation_covariance)
  return orientation_covariance_.Mutable(index);
}
inline ::choreo::Float64* IMU::add_orientation_covariance() {
  // @@protoc_insertion_point(field_add:choreo.IMU.orientation_covariance)
  return orientation_covariance_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
IMU::mutable_orientation_covariance() {
  // @@protoc_insertion_point(field_mutable_list:choreo.IMU.orientation_covariance)
  return &orientation_covariance_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
IMU::orientation_covariance() const {
  // @@protoc_insertion_point(field_list:choreo.IMU.orientation_covariance)
  return orientation_covariance_;
}

// .choreo.Vector3 angular_velocity = 4;
inline bool IMU::has_angular_velocity() const {
  return this != internal_default_instance() && angular_velocity_ != NULL;
}
inline void IMU::clear_angular_velocity() {
  if (GetArenaNoVirtual() == NULL && angular_velocity_ != NULL) delete angular_velocity_;
  angular_velocity_ = NULL;
}
inline const ::choreo::Vector3& IMU::angular_velocity() const {
  // @@protoc_insertion_point(field_get:choreo.IMU.angular_velocity)
  return angular_velocity_ != NULL ? *angular_velocity_
                         : *::choreo::Vector3::internal_default_instance();
}
inline ::choreo::Vector3* IMU::mutable_angular_velocity() {
  
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::choreo::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:choreo.IMU.angular_velocity)
  return angular_velocity_;
}
inline ::choreo::Vector3* IMU::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:choreo.IMU.angular_velocity)
  
  ::choreo::Vector3* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline void IMU::set_allocated_angular_velocity(::choreo::Vector3* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.IMU.angular_velocity)
}

// repeated .choreo.Float64 angular_velocity_covariance = 5;
inline int IMU::angular_velocity_covariance_size() const {
  return angular_velocity_covariance_.size();
}
inline void IMU::clear_angular_velocity_covariance() {
  angular_velocity_covariance_.Clear();
}
inline const ::choreo::Float64& IMU::angular_velocity_covariance(int index) const {
  // @@protoc_insertion_point(field_get:choreo.IMU.angular_velocity_covariance)
  return angular_velocity_covariance_.Get(index);
}
inline ::choreo::Float64* IMU::mutable_angular_velocity_covariance(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.IMU.angular_velocity_covariance)
  return angular_velocity_covariance_.Mutable(index);
}
inline ::choreo::Float64* IMU::add_angular_velocity_covariance() {
  // @@protoc_insertion_point(field_add:choreo.IMU.angular_velocity_covariance)
  return angular_velocity_covariance_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
IMU::mutable_angular_velocity_covariance() {
  // @@protoc_insertion_point(field_mutable_list:choreo.IMU.angular_velocity_covariance)
  return &angular_velocity_covariance_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
IMU::angular_velocity_covariance() const {
  // @@protoc_insertion_point(field_list:choreo.IMU.angular_velocity_covariance)
  return angular_velocity_covariance_;
}

// .choreo.Vector3 linear_acceleration = 6;
inline bool IMU::has_linear_acceleration() const {
  return this != internal_default_instance() && linear_acceleration_ != NULL;
}
inline void IMU::clear_linear_acceleration() {
  if (GetArenaNoVirtual() == NULL && linear_acceleration_ != NULL) delete linear_acceleration_;
  linear_acceleration_ = NULL;
}
inline const ::choreo::Vector3& IMU::linear_acceleration() const {
  // @@protoc_insertion_point(field_get:choreo.IMU.linear_acceleration)
  return linear_acceleration_ != NULL ? *linear_acceleration_
                         : *::choreo::Vector3::internal_default_instance();
}
inline ::choreo::Vector3* IMU::mutable_linear_acceleration() {
  
  if (linear_acceleration_ == NULL) {
    linear_acceleration_ = new ::choreo::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:choreo.IMU.linear_acceleration)
  return linear_acceleration_;
}
inline ::choreo::Vector3* IMU::release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:choreo.IMU.linear_acceleration)
  
  ::choreo::Vector3* temp = linear_acceleration_;
  linear_acceleration_ = NULL;
  return temp;
}
inline void IMU::set_allocated_linear_acceleration(::choreo::Vector3* linear_acceleration) {
  delete linear_acceleration_;
  linear_acceleration_ = linear_acceleration;
  if (linear_acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.IMU.linear_acceleration)
}

// repeated .choreo.Float64 linear_acceleration_covariance = 7;
inline int IMU::linear_acceleration_covariance_size() const {
  return linear_acceleration_covariance_.size();
}
inline void IMU::clear_linear_acceleration_covariance() {
  linear_acceleration_covariance_.Clear();
}
inline const ::choreo::Float64& IMU::linear_acceleration_covariance(int index) const {
  // @@protoc_insertion_point(field_get:choreo.IMU.linear_acceleration_covariance)
  return linear_acceleration_covariance_.Get(index);
}
inline ::choreo::Float64* IMU::mutable_linear_acceleration_covariance(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.IMU.linear_acceleration_covariance)
  return linear_acceleration_covariance_.Mutable(index);
}
inline ::choreo::Float64* IMU::add_linear_acceleration_covariance() {
  // @@protoc_insertion_point(field_add:choreo.IMU.linear_acceleration_covariance)
  return linear_acceleration_covariance_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
IMU::mutable_linear_acceleration_covariance() {
  // @@protoc_insertion_point(field_mutable_list:choreo.IMU.linear_acceleration_covariance)
  return &linear_acceleration_covariance_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
IMU::linear_acceleration_covariance() const {
  // @@protoc_insertion_point(field_list:choreo.IMU.linear_acceleration_covariance)
  return linear_acceleration_covariance_;
}

// -------------------------------------------------------------------

// MagneticField

// .choreo.Header header = 1;
inline bool MagneticField::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void MagneticField::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& MagneticField::header() const {
  // @@protoc_insertion_point(field_get:choreo.MagneticField.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* MagneticField::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MagneticField.header)
  return header_;
}
inline ::choreo::Header* MagneticField::release_header() {
  // @@protoc_insertion_point(field_release:choreo.MagneticField.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void MagneticField::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MagneticField.header)
}

// .choreo.Vector3 magnetic_field = 2;
inline bool MagneticField::has_magnetic_field() const {
  return this != internal_default_instance() && magnetic_field_ != NULL;
}
inline void MagneticField::clear_magnetic_field() {
  if (GetArenaNoVirtual() == NULL && magnetic_field_ != NULL) delete magnetic_field_;
  magnetic_field_ = NULL;
}
inline const ::choreo::Vector3& MagneticField::magnetic_field() const {
  // @@protoc_insertion_point(field_get:choreo.MagneticField.magnetic_field)
  return magnetic_field_ != NULL ? *magnetic_field_
                         : *::choreo::Vector3::internal_default_instance();
}
inline ::choreo::Vector3* MagneticField::mutable_magnetic_field() {
  
  if (magnetic_field_ == NULL) {
    magnetic_field_ = new ::choreo::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MagneticField.magnetic_field)
  return magnetic_field_;
}
inline ::choreo::Vector3* MagneticField::release_magnetic_field() {
  // @@protoc_insertion_point(field_release:choreo.MagneticField.magnetic_field)
  
  ::choreo::Vector3* temp = magnetic_field_;
  magnetic_field_ = NULL;
  return temp;
}
inline void MagneticField::set_allocated_magnetic_field(::choreo::Vector3* magnetic_field) {
  delete magnetic_field_;
  magnetic_field_ = magnetic_field;
  if (magnetic_field) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MagneticField.magnetic_field)
}

// repeated .choreo.Float64 magnetic_field_covariance = 3;
inline int MagneticField::magnetic_field_covariance_size() const {
  return magnetic_field_covariance_.size();
}
inline void MagneticField::clear_magnetic_field_covariance() {
  magnetic_field_covariance_.Clear();
}
inline const ::choreo::Float64& MagneticField::magnetic_field_covariance(int index) const {
  // @@protoc_insertion_point(field_get:choreo.MagneticField.magnetic_field_covariance)
  return magnetic_field_covariance_.Get(index);
}
inline ::choreo::Float64* MagneticField::mutable_magnetic_field_covariance(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.MagneticField.magnetic_field_covariance)
  return magnetic_field_covariance_.Mutable(index);
}
inline ::choreo::Float64* MagneticField::add_magnetic_field_covariance() {
  // @@protoc_insertion_point(field_add:choreo.MagneticField.magnetic_field_covariance)
  return magnetic_field_covariance_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
MagneticField::mutable_magnetic_field_covariance() {
  // @@protoc_insertion_point(field_mutable_list:choreo.MagneticField.magnetic_field_covariance)
  return &magnetic_field_covariance_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
MagneticField::magnetic_field_covariance() const {
  // @@protoc_insertion_point(field_list:choreo.MagneticField.magnetic_field_covariance)
  return magnetic_field_covariance_;
}

// -------------------------------------------------------------------

// NavSatStatus

// .choreo.NavSatStatus.Status nav_sat_status = 1;
inline void NavSatStatus::clear_nav_sat_status() {
  nav_sat_status_ = 0;
}
inline ::choreo::NavSatStatus_Status NavSatStatus::nav_sat_status() const {
  // @@protoc_insertion_point(field_get:choreo.NavSatStatus.nav_sat_status)
  return static_cast< ::choreo::NavSatStatus_Status >(nav_sat_status_);
}
inline void NavSatStatus::set_nav_sat_status(::choreo::NavSatStatus_Status value) {
  
  nav_sat_status_ = value;
  // @@protoc_insertion_point(field_set:choreo.NavSatStatus.nav_sat_status)
}

// .choreo.NavSatStatus.Service nav_sat_service = 2;
inline void NavSatStatus::clear_nav_sat_service() {
  nav_sat_service_ = 0;
}
inline ::choreo::NavSatStatus_Service NavSatStatus::nav_sat_service() const {
  // @@protoc_insertion_point(field_get:choreo.NavSatStatus.nav_sat_service)
  return static_cast< ::choreo::NavSatStatus_Service >(nav_sat_service_);
}
inline void NavSatStatus::set_nav_sat_service(::choreo::NavSatStatus_Service value) {
  
  nav_sat_service_ = value;
  // @@protoc_insertion_point(field_set:choreo.NavSatStatus.nav_sat_service)
}

// -------------------------------------------------------------------

// NavSatFix

// .choreo.Header header = 1;
inline bool NavSatFix::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void NavSatFix::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& NavSatFix::header() const {
  // @@protoc_insertion_point(field_get:choreo.NavSatFix.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* NavSatFix::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.NavSatFix.header)
  return header_;
}
inline ::choreo::Header* NavSatFix::release_header() {
  // @@protoc_insertion_point(field_release:choreo.NavSatFix.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void NavSatFix::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.NavSatFix.header)
}

// .choreo.NavSatStatus nav_sat_status = 2;
inline bool NavSatFix::has_nav_sat_status() const {
  return this != internal_default_instance() && nav_sat_status_ != NULL;
}
inline void NavSatFix::clear_nav_sat_status() {
  if (GetArenaNoVirtual() == NULL && nav_sat_status_ != NULL) delete nav_sat_status_;
  nav_sat_status_ = NULL;
}
inline const ::choreo::NavSatStatus& NavSatFix::nav_sat_status() const {
  // @@protoc_insertion_point(field_get:choreo.NavSatFix.nav_sat_status)
  return nav_sat_status_ != NULL ? *nav_sat_status_
                         : *::choreo::NavSatStatus::internal_default_instance();
}
inline ::choreo::NavSatStatus* NavSatFix::mutable_nav_sat_status() {
  
  if (nav_sat_status_ == NULL) {
    nav_sat_status_ = new ::choreo::NavSatStatus;
  }
  // @@protoc_insertion_point(field_mutable:choreo.NavSatFix.nav_sat_status)
  return nav_sat_status_;
}
inline ::choreo::NavSatStatus* NavSatFix::release_nav_sat_status() {
  // @@protoc_insertion_point(field_release:choreo.NavSatFix.nav_sat_status)
  
  ::choreo::NavSatStatus* temp = nav_sat_status_;
  nav_sat_status_ = NULL;
  return temp;
}
inline void NavSatFix::set_allocated_nav_sat_status(::choreo::NavSatStatus* nav_sat_status) {
  delete nav_sat_status_;
  nav_sat_status_ = nav_sat_status;
  if (nav_sat_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.NavSatFix.nav_sat_status)
}

// .choreo.Float64 latitude = 3;
inline bool NavSatFix::has_latitude() const {
  return this != internal_default_instance() && latitude_ != NULL;
}
inline void NavSatFix::clear_latitude() {
  if (GetArenaNoVirtual() == NULL && latitude_ != NULL) delete latitude_;
  latitude_ = NULL;
}
inline const ::choreo::Float64& NavSatFix::latitude() const {
  // @@protoc_insertion_point(field_get:choreo.NavSatFix.latitude)
  return latitude_ != NULL ? *latitude_
                         : *::choreo::Float64::internal_default_instance();
}
inline ::choreo::Float64* NavSatFix::mutable_latitude() {
  
  if (latitude_ == NULL) {
    latitude_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.NavSatFix.latitude)
  return latitude_;
}
inline ::choreo::Float64* NavSatFix::release_latitude() {
  // @@protoc_insertion_point(field_release:choreo.NavSatFix.latitude)
  
  ::choreo::Float64* temp = latitude_;
  latitude_ = NULL;
  return temp;
}
inline void NavSatFix::set_allocated_latitude(::choreo::Float64* latitude) {
  delete latitude_;
  latitude_ = latitude;
  if (latitude) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.NavSatFix.latitude)
}

// .choreo.Float64 longitude = 4;
inline bool NavSatFix::has_longitude() const {
  return this != internal_default_instance() && longitude_ != NULL;
}
inline void NavSatFix::clear_longitude() {
  if (GetArenaNoVirtual() == NULL && longitude_ != NULL) delete longitude_;
  longitude_ = NULL;
}
inline const ::choreo::Float64& NavSatFix::longitude() const {
  // @@protoc_insertion_point(field_get:choreo.NavSatFix.longitude)
  return longitude_ != NULL ? *longitude_
                         : *::choreo::Float64::internal_default_instance();
}
inline ::choreo::Float64* NavSatFix::mutable_longitude() {
  
  if (longitude_ == NULL) {
    longitude_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.NavSatFix.longitude)
  return longitude_;
}
inline ::choreo::Float64* NavSatFix::release_longitude() {
  // @@protoc_insertion_point(field_release:choreo.NavSatFix.longitude)
  
  ::choreo::Float64* temp = longitude_;
  longitude_ = NULL;
  return temp;
}
inline void NavSatFix::set_allocated_longitude(::choreo::Float64* longitude) {
  delete longitude_;
  longitude_ = longitude;
  if (longitude) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.NavSatFix.longitude)
}

// .choreo.Float64 altitude = 5;
inline bool NavSatFix::has_altitude() const {
  return this != internal_default_instance() && altitude_ != NULL;
}
inline void NavSatFix::clear_altitude() {
  if (GetArenaNoVirtual() == NULL && altitude_ != NULL) delete altitude_;
  altitude_ = NULL;
}
inline const ::choreo::Float64& NavSatFix::altitude() const {
  // @@protoc_insertion_point(field_get:choreo.NavSatFix.altitude)
  return altitude_ != NULL ? *altitude_
                         : *::choreo::Float64::internal_default_instance();
}
inline ::choreo::Float64* NavSatFix::mutable_altitude() {
  
  if (altitude_ == NULL) {
    altitude_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.NavSatFix.altitude)
  return altitude_;
}
inline ::choreo::Float64* NavSatFix::release_altitude() {
  // @@protoc_insertion_point(field_release:choreo.NavSatFix.altitude)
  
  ::choreo::Float64* temp = altitude_;
  altitude_ = NULL;
  return temp;
}
inline void NavSatFix::set_allocated_altitude(::choreo::Float64* altitude) {
  delete altitude_;
  altitude_ = altitude;
  if (altitude) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.NavSatFix.altitude)
}

// repeated .choreo.Float64 position_covariance = 6;
inline int NavSatFix::position_covariance_size() const {
  return position_covariance_.size();
}
inline void NavSatFix::clear_position_covariance() {
  position_covariance_.Clear();
}
inline const ::choreo::Float64& NavSatFix::position_covariance(int index) const {
  // @@protoc_insertion_point(field_get:choreo.NavSatFix.position_covariance)
  return position_covariance_.Get(index);
}
inline ::choreo::Float64* NavSatFix::mutable_position_covariance(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.NavSatFix.position_covariance)
  return position_covariance_.Mutable(index);
}
inline ::choreo::Float64* NavSatFix::add_position_covariance() {
  // @@protoc_insertion_point(field_add:choreo.NavSatFix.position_covariance)
  return position_covariance_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
NavSatFix::mutable_position_covariance() {
  // @@protoc_insertion_point(field_mutable_list:choreo.NavSatFix.position_covariance)
  return &position_covariance_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
NavSatFix::position_covariance() const {
  // @@protoc_insertion_point(field_list:choreo.NavSatFix.position_covariance)
  return position_covariance_;
}

// .choreo.NavSatFix.PositionCovarianceType position_covariance_type = 7;
inline void NavSatFix::clear_position_covariance_type() {
  position_covariance_type_ = 0;
}
inline ::choreo::NavSatFix_PositionCovarianceType NavSatFix::position_covariance_type() const {
  // @@protoc_insertion_point(field_get:choreo.NavSatFix.position_covariance_type)
  return static_cast< ::choreo::NavSatFix_PositionCovarianceType >(position_covariance_type_);
}
inline void NavSatFix::set_position_covariance_type(::choreo::NavSatFix_PositionCovarianceType value) {
  
  position_covariance_type_ = value;
  // @@protoc_insertion_point(field_set:choreo.NavSatFix.position_covariance_type)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace choreo

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::choreo::NavSatStatus_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::choreo::NavSatStatus_Status>() {
  return ::choreo::NavSatStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::choreo::NavSatStatus_Service> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::choreo::NavSatStatus_Service>() {
  return ::choreo::NavSatStatus_Service_descriptor();
}
template <> struct is_proto_enum< ::choreo::NavSatFix_PositionCovarianceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::choreo::NavSatFix_PositionCovarianceType>() {
  return ::choreo::NavSatFix_PositionCovarianceType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sensor_2fimu_2eproto__INCLUDED
