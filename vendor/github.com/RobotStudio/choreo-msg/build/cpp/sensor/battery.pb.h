// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor/battery.proto

#ifndef PROTOBUF_sensor_2fbattery_2eproto__INCLUDED
#define PROTOBUF_sensor_2fbattery_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "primitive/bool.pb.h"
#include "primitive/float.pb.h"
#include "primitive/header.pb.h"
#include "primitive/int.pb.h"
#include "primitive/string.pb.h"
// @@protoc_insertion_point(includes)
namespace choreo {
class BatteryState;
class BatteryStateDefaultTypeInternal;
extern BatteryStateDefaultTypeInternal _BatteryState_default_instance_;
class Bool;
class BoolDefaultTypeInternal;
extern BoolDefaultTypeInternal _Bool_default_instance_;
class BoolArray;
class BoolArrayDefaultTypeInternal;
extern BoolArrayDefaultTypeInternal _BoolArray_default_instance_;
class Float;
class FloatDefaultTypeInternal;
extern FloatDefaultTypeInternal _Float_default_instance_;
class Float32;
class Float32DefaultTypeInternal;
extern Float32DefaultTypeInternal _Float32_default_instance_;
class Float32Array;
class Float32ArrayDefaultTypeInternal;
extern Float32ArrayDefaultTypeInternal _Float32Array_default_instance_;
class Float64;
class Float64DefaultTypeInternal;
extern Float64DefaultTypeInternal _Float64_default_instance_;
class Float64Array;
class Float64ArrayDefaultTypeInternal;
extern Float64ArrayDefaultTypeInternal _Float64Array_default_instance_;
class FloatArray;
class FloatArrayDefaultTypeInternal;
extern FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Int32;
class Int32DefaultTypeInternal;
extern Int32DefaultTypeInternal _Int32_default_instance_;
class Int32Array;
class Int32ArrayDefaultTypeInternal;
extern Int32ArrayDefaultTypeInternal _Int32Array_default_instance_;
class Int64;
class Int64DefaultTypeInternal;
extern Int64DefaultTypeInternal _Int64_default_instance_;
class Int64Array;
class Int64ArrayDefaultTypeInternal;
extern Int64ArrayDefaultTypeInternal _Int64Array_default_instance_;
class SInt32;
class SInt32DefaultTypeInternal;
extern SInt32DefaultTypeInternal _SInt32_default_instance_;
class SInt32Array;
class SInt32ArrayDefaultTypeInternal;
extern SInt32ArrayDefaultTypeInternal _SInt32Array_default_instance_;
class SInt64;
class SInt64DefaultTypeInternal;
extern SInt64DefaultTypeInternal _SInt64_default_instance_;
class SInt64Array;
class SInt64ArrayDefaultTypeInternal;
extern SInt64ArrayDefaultTypeInternal _SInt64Array_default_instance_;
class String;
class StringDefaultTypeInternal;
extern StringDefaultTypeInternal _String_default_instance_;
class UInt32;
class UInt32DefaultTypeInternal;
extern UInt32DefaultTypeInternal _UInt32_default_instance_;
class UInt32Array;
class UInt32ArrayDefaultTypeInternal;
extern UInt32ArrayDefaultTypeInternal _UInt32Array_default_instance_;
class UInt64;
class UInt64DefaultTypeInternal;
extern UInt64DefaultTypeInternal _UInt64_default_instance_;
class UInt64Array;
class UInt64ArrayDefaultTypeInternal;
extern UInt64ArrayDefaultTypeInternal _UInt64Array_default_instance_;
}  // namespace choreo

namespace choreo {

namespace protobuf_sensor_2fbattery_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_sensor_2fbattery_2eproto

enum BatteryState_Status {
  BatteryState_Status_STATUS_UNKNOWN = 0,
  BatteryState_Status_STATUS_CHARGING = 1,
  BatteryState_Status_STATUS_DISCHARGING = 2,
  BatteryState_Status_STATUS_NOT_CHARGING = 3,
  BatteryState_Status_STATUS_FULL = 4,
  BatteryState_Status_BatteryState_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BatteryState_Status_BatteryState_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BatteryState_Status_IsValid(int value);
const BatteryState_Status BatteryState_Status_Status_MIN = BatteryState_Status_STATUS_UNKNOWN;
const BatteryState_Status BatteryState_Status_Status_MAX = BatteryState_Status_STATUS_FULL;
const int BatteryState_Status_Status_ARRAYSIZE = BatteryState_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* BatteryState_Status_descriptor();
inline const ::std::string& BatteryState_Status_Name(BatteryState_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    BatteryState_Status_descriptor(), value);
}
inline bool BatteryState_Status_Parse(
    const ::std::string& name, BatteryState_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BatteryState_Status>(
    BatteryState_Status_descriptor(), name, value);
}
enum BatteryState_Health {
  BatteryState_Health_HEALTH_UNKNOWN = 0,
  BatteryState_Health_HEALTH_GOOD = 1,
  BatteryState_Health_HEALTH_OVERHEAT = 2,
  BatteryState_Health_HEALTH_DEAD = 3,
  BatteryState_Health_HEALTH_OVERVOLTAGE = 4,
  BatteryState_Health_HEALTH_UNSPEC_FAILURE = 5,
  BatteryState_Health_HEALTH_COLD = 6,
  BatteryState_Health_HEALTH_WATCHDOG_TIMER_EXPIRE = 7,
  BatteryState_Health_HEALTH_SAFETY_TIMER_EXPIRE = 8,
  BatteryState_Health_BatteryState_Health_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BatteryState_Health_BatteryState_Health_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BatteryState_Health_IsValid(int value);
const BatteryState_Health BatteryState_Health_Health_MIN = BatteryState_Health_HEALTH_UNKNOWN;
const BatteryState_Health BatteryState_Health_Health_MAX = BatteryState_Health_HEALTH_SAFETY_TIMER_EXPIRE;
const int BatteryState_Health_Health_ARRAYSIZE = BatteryState_Health_Health_MAX + 1;

const ::google::protobuf::EnumDescriptor* BatteryState_Health_descriptor();
inline const ::std::string& BatteryState_Health_Name(BatteryState_Health value) {
  return ::google::protobuf::internal::NameOfEnum(
    BatteryState_Health_descriptor(), value);
}
inline bool BatteryState_Health_Parse(
    const ::std::string& name, BatteryState_Health* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BatteryState_Health>(
    BatteryState_Health_descriptor(), name, value);
}
enum BatteryState_Technology {
  BatteryState_Technology_TECHNOLOGY_UNKNOWN = 0,
  BatteryState_Technology_TECHNOLOGY_NIMH = 1,
  BatteryState_Technology_TECHNOLOGY_LION = 2,
  BatteryState_Technology_TECHNOLOGY_LIPO = 3,
  BatteryState_Technology_TECHNOLOGY_LIFE = 4,
  BatteryState_Technology_TECHNOLOGY_NICD = 5,
  BatteryState_Technology_TECHNOLOGY_LIMN = 6,
  BatteryState_Technology_BatteryState_Technology_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BatteryState_Technology_BatteryState_Technology_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BatteryState_Technology_IsValid(int value);
const BatteryState_Technology BatteryState_Technology_Technology_MIN = BatteryState_Technology_TECHNOLOGY_UNKNOWN;
const BatteryState_Technology BatteryState_Technology_Technology_MAX = BatteryState_Technology_TECHNOLOGY_LIMN;
const int BatteryState_Technology_Technology_ARRAYSIZE = BatteryState_Technology_Technology_MAX + 1;

const ::google::protobuf::EnumDescriptor* BatteryState_Technology_descriptor();
inline const ::std::string& BatteryState_Technology_Name(BatteryState_Technology value) {
  return ::google::protobuf::internal::NameOfEnum(
    BatteryState_Technology_descriptor(), value);
}
inline bool BatteryState_Technology_Parse(
    const ::std::string& name, BatteryState_Technology* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BatteryState_Technology>(
    BatteryState_Technology_descriptor(), name, value);
}
// ===================================================================

class BatteryState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.BatteryState) */ {
 public:
  BatteryState();
  virtual ~BatteryState();

  BatteryState(const BatteryState& from);

  inline BatteryState& operator=(const BatteryState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatteryState& default_instance();

  static inline const BatteryState* internal_default_instance() {
    return reinterpret_cast<const BatteryState*>(
               &_BatteryState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(BatteryState* other);

  // implements Message ----------------------------------------------

  inline BatteryState* New() const PROTOBUF_FINAL { return New(NULL); }

  BatteryState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BatteryState& from);
  void MergeFrom(const BatteryState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BatteryState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef BatteryState_Status Status;
  static const Status STATUS_UNKNOWN =
    BatteryState_Status_STATUS_UNKNOWN;
  static const Status STATUS_CHARGING =
    BatteryState_Status_STATUS_CHARGING;
  static const Status STATUS_DISCHARGING =
    BatteryState_Status_STATUS_DISCHARGING;
  static const Status STATUS_NOT_CHARGING =
    BatteryState_Status_STATUS_NOT_CHARGING;
  static const Status STATUS_FULL =
    BatteryState_Status_STATUS_FULL;
  static inline bool Status_IsValid(int value) {
    return BatteryState_Status_IsValid(value);
  }
  static const Status Status_MIN =
    BatteryState_Status_Status_MIN;
  static const Status Status_MAX =
    BatteryState_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    BatteryState_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return BatteryState_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return BatteryState_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return BatteryState_Status_Parse(name, value);
  }

  typedef BatteryState_Health Health;
  static const Health HEALTH_UNKNOWN =
    BatteryState_Health_HEALTH_UNKNOWN;
  static const Health HEALTH_GOOD =
    BatteryState_Health_HEALTH_GOOD;
  static const Health HEALTH_OVERHEAT =
    BatteryState_Health_HEALTH_OVERHEAT;
  static const Health HEALTH_DEAD =
    BatteryState_Health_HEALTH_DEAD;
  static const Health HEALTH_OVERVOLTAGE =
    BatteryState_Health_HEALTH_OVERVOLTAGE;
  static const Health HEALTH_UNSPEC_FAILURE =
    BatteryState_Health_HEALTH_UNSPEC_FAILURE;
  static const Health HEALTH_COLD =
    BatteryState_Health_HEALTH_COLD;
  static const Health HEALTH_WATCHDOG_TIMER_EXPIRE =
    BatteryState_Health_HEALTH_WATCHDOG_TIMER_EXPIRE;
  static const Health HEALTH_SAFETY_TIMER_EXPIRE =
    BatteryState_Health_HEALTH_SAFETY_TIMER_EXPIRE;
  static inline bool Health_IsValid(int value) {
    return BatteryState_Health_IsValid(value);
  }
  static const Health Health_MIN =
    BatteryState_Health_Health_MIN;
  static const Health Health_MAX =
    BatteryState_Health_Health_MAX;
  static const int Health_ARRAYSIZE =
    BatteryState_Health_Health_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Health_descriptor() {
    return BatteryState_Health_descriptor();
  }
  static inline const ::std::string& Health_Name(Health value) {
    return BatteryState_Health_Name(value);
  }
  static inline bool Health_Parse(const ::std::string& name,
      Health* value) {
    return BatteryState_Health_Parse(name, value);
  }

  typedef BatteryState_Technology Technology;
  static const Technology TECHNOLOGY_UNKNOWN =
    BatteryState_Technology_TECHNOLOGY_UNKNOWN;
  static const Technology TECHNOLOGY_NIMH =
    BatteryState_Technology_TECHNOLOGY_NIMH;
  static const Technology TECHNOLOGY_LION =
    BatteryState_Technology_TECHNOLOGY_LION;
  static const Technology TECHNOLOGY_LIPO =
    BatteryState_Technology_TECHNOLOGY_LIPO;
  static const Technology TECHNOLOGY_LIFE =
    BatteryState_Technology_TECHNOLOGY_LIFE;
  static const Technology TECHNOLOGY_NICD =
    BatteryState_Technology_TECHNOLOGY_NICD;
  static const Technology TECHNOLOGY_LIMN =
    BatteryState_Technology_TECHNOLOGY_LIMN;
  static inline bool Technology_IsValid(int value) {
    return BatteryState_Technology_IsValid(value);
  }
  static const Technology Technology_MIN =
    BatteryState_Technology_Technology_MIN;
  static const Technology Technology_MAX =
    BatteryState_Technology_Technology_MAX;
  static const int Technology_ARRAYSIZE =
    BatteryState_Technology_Technology_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Technology_descriptor() {
    return BatteryState_Technology_descriptor();
  }
  static inline const ::std::string& Technology_Name(Technology value) {
    return BatteryState_Technology_Name(value);
  }
  static inline bool Technology_Parse(const ::std::string& name,
      Technology* value) {
    return BatteryState_Technology_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .choreo.Header header = 4;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 4;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.Float32 voltage = 5;
  bool has_voltage() const;
  void clear_voltage();
  static const int kVoltageFieldNumber = 5;
  const ::choreo::Float32& voltage() const;
  ::choreo::Float32* mutable_voltage();
  ::choreo::Float32* release_voltage();
  void set_allocated_voltage(::choreo::Float32* voltage);

  // .choreo.Float32 current = 6;
  bool has_current() const;
  void clear_current();
  static const int kCurrentFieldNumber = 6;
  const ::choreo::Float32& current() const;
  ::choreo::Float32* mutable_current();
  ::choreo::Float32* release_current();
  void set_allocated_current(::choreo::Float32* current);

  // .choreo.Float32 charge = 7;
  bool has_charge() const;
  void clear_charge();
  static const int kChargeFieldNumber = 7;
  const ::choreo::Float32& charge() const;
  ::choreo::Float32* mutable_charge();
  ::choreo::Float32* release_charge();
  void set_allocated_charge(::choreo::Float32* charge);

  // .choreo.Float32 capacity = 8;
  bool has_capacity() const;
  void clear_capacity();
  static const int kCapacityFieldNumber = 8;
  const ::choreo::Float32& capacity() const;
  ::choreo::Float32* mutable_capacity();
  ::choreo::Float32* release_capacity();
  void set_allocated_capacity(::choreo::Float32* capacity);

  // .choreo.Float32 design_capacity = 9;
  bool has_design_capacity() const;
  void clear_design_capacity();
  static const int kDesignCapacityFieldNumber = 9;
  const ::choreo::Float32& design_capacity() const;
  ::choreo::Float32* mutable_design_capacity();
  ::choreo::Float32* release_design_capacity();
  void set_allocated_design_capacity(::choreo::Float32* design_capacity);

  // .choreo.Float32 percentage = 10;
  bool has_percentage() const;
  void clear_percentage();
  static const int kPercentageFieldNumber = 10;
  const ::choreo::Float32& percentage() const;
  ::choreo::Float32* mutable_percentage();
  ::choreo::Float32* release_percentage();
  void set_allocated_percentage(::choreo::Float32* percentage);

  // .choreo.UInt32 power_supply_status = 12;
  bool has_power_supply_status() const;
  void clear_power_supply_status();
  static const int kPowerSupplyStatusFieldNumber = 12;
  const ::choreo::UInt32& power_supply_status() const;
  ::choreo::UInt32* mutable_power_supply_status();
  ::choreo::UInt32* release_power_supply_status();
  void set_allocated_power_supply_status(::choreo::UInt32* power_supply_status);

  // .choreo.UInt32 power_supply_health = 13;
  bool has_power_supply_health() const;
  void clear_power_supply_health();
  static const int kPowerSupplyHealthFieldNumber = 13;
  const ::choreo::UInt32& power_supply_health() const;
  ::choreo::UInt32* mutable_power_supply_health();
  ::choreo::UInt32* release_power_supply_health();
  void set_allocated_power_supply_health(::choreo::UInt32* power_supply_health);

  // .choreo.UInt32 power_supply_technology = 14;
  bool has_power_supply_technology() const;
  void clear_power_supply_technology();
  static const int kPowerSupplyTechnologyFieldNumber = 14;
  const ::choreo::UInt32& power_supply_technology() const;
  ::choreo::UInt32* mutable_power_supply_technology();
  ::choreo::UInt32* release_power_supply_technology();
  void set_allocated_power_supply_technology(::choreo::UInt32* power_supply_technology);

  // .choreo.Bool present = 15;
  bool has_present() const;
  void clear_present();
  static const int kPresentFieldNumber = 15;
  const ::choreo::Bool& present() const;
  ::choreo::Bool* mutable_present();
  ::choreo::Bool* release_present();
  void set_allocated_present(::choreo::Bool* present);

  // .choreo.Float32 cell_voltage = 16;
  bool has_cell_voltage() const;
  void clear_cell_voltage();
  static const int kCellVoltageFieldNumber = 16;
  const ::choreo::Float32& cell_voltage() const;
  ::choreo::Float32* mutable_cell_voltage();
  ::choreo::Float32* release_cell_voltage();
  void set_allocated_cell_voltage(::choreo::Float32* cell_voltage);

  // .choreo.String location = 17;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 17;
  const ::choreo::String& location() const;
  ::choreo::String* mutable_location();
  ::choreo::String* release_location();
  void set_allocated_location(::choreo::String* location);

  // .choreo.String serial_number = 18;
  bool has_serial_number() const;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 18;
  const ::choreo::String& serial_number() const;
  ::choreo::String* mutable_serial_number();
  ::choreo::String* release_serial_number();
  void set_allocated_serial_number(::choreo::String* serial_number);

  // .choreo.BatteryState.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::choreo::BatteryState_Status status() const;
  void set_status(::choreo::BatteryState_Status value);

  // .choreo.BatteryState.Health health = 2;
  void clear_health();
  static const int kHealthFieldNumber = 2;
  ::choreo::BatteryState_Health health() const;
  void set_health(::choreo::BatteryState_Health value);

  // .choreo.BatteryState.Technology technology = 3;
  void clear_technology();
  static const int kTechnologyFieldNumber = 3;
  ::choreo::BatteryState_Technology technology() const;
  void set_technology(::choreo::BatteryState_Technology value);

  // @@protoc_insertion_point(class_scope:choreo.BatteryState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::Header* header_;
  ::choreo::Float32* voltage_;
  ::choreo::Float32* current_;
  ::choreo::Float32* charge_;
  ::choreo::Float32* capacity_;
  ::choreo::Float32* design_capacity_;
  ::choreo::Float32* percentage_;
  ::choreo::UInt32* power_supply_status_;
  ::choreo::UInt32* power_supply_health_;
  ::choreo::UInt32* power_supply_technology_;
  ::choreo::Bool* present_;
  ::choreo::Float32* cell_voltage_;
  ::choreo::String* location_;
  ::choreo::String* serial_number_;
  int status_;
  int health_;
  int technology_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fbattery_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// BatteryState

// .choreo.BatteryState.Status status = 1;
inline void BatteryState::clear_status() {
  status_ = 0;
}
inline ::choreo::BatteryState_Status BatteryState::status() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.status)
  return static_cast< ::choreo::BatteryState_Status >(status_);
}
inline void BatteryState::set_status(::choreo::BatteryState_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:choreo.BatteryState.status)
}

// .choreo.BatteryState.Health health = 2;
inline void BatteryState::clear_health() {
  health_ = 0;
}
inline ::choreo::BatteryState_Health BatteryState::health() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.health)
  return static_cast< ::choreo::BatteryState_Health >(health_);
}
inline void BatteryState::set_health(::choreo::BatteryState_Health value) {
  
  health_ = value;
  // @@protoc_insertion_point(field_set:choreo.BatteryState.health)
}

// .choreo.BatteryState.Technology technology = 3;
inline void BatteryState::clear_technology() {
  technology_ = 0;
}
inline ::choreo::BatteryState_Technology BatteryState::technology() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.technology)
  return static_cast< ::choreo::BatteryState_Technology >(technology_);
}
inline void BatteryState::set_technology(::choreo::BatteryState_Technology value) {
  
  technology_ = value;
  // @@protoc_insertion_point(field_set:choreo.BatteryState.technology)
}

// .choreo.Header header = 4;
inline bool BatteryState::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void BatteryState::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& BatteryState::header() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* BatteryState::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.header)
  return header_;
}
inline ::choreo::Header* BatteryState::release_header() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.header)
}

// .choreo.Float32 voltage = 5;
inline bool BatteryState::has_voltage() const {
  return this != internal_default_instance() && voltage_ != NULL;
}
inline void BatteryState::clear_voltage() {
  if (GetArenaNoVirtual() == NULL && voltage_ != NULL) delete voltage_;
  voltage_ = NULL;
}
inline const ::choreo::Float32& BatteryState::voltage() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.voltage)
  return voltage_ != NULL ? *voltage_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* BatteryState::mutable_voltage() {
  
  if (voltage_ == NULL) {
    voltage_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.voltage)
  return voltage_;
}
inline ::choreo::Float32* BatteryState::release_voltage() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.voltage)
  
  ::choreo::Float32* temp = voltage_;
  voltage_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_voltage(::choreo::Float32* voltage) {
  delete voltage_;
  voltage_ = voltage;
  if (voltage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.voltage)
}

// .choreo.Float32 current = 6;
inline bool BatteryState::has_current() const {
  return this != internal_default_instance() && current_ != NULL;
}
inline void BatteryState::clear_current() {
  if (GetArenaNoVirtual() == NULL && current_ != NULL) delete current_;
  current_ = NULL;
}
inline const ::choreo::Float32& BatteryState::current() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.current)
  return current_ != NULL ? *current_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* BatteryState::mutable_current() {
  
  if (current_ == NULL) {
    current_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.current)
  return current_;
}
inline ::choreo::Float32* BatteryState::release_current() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.current)
  
  ::choreo::Float32* temp = current_;
  current_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_current(::choreo::Float32* current) {
  delete current_;
  current_ = current;
  if (current) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.current)
}

// .choreo.Float32 charge = 7;
inline bool BatteryState::has_charge() const {
  return this != internal_default_instance() && charge_ != NULL;
}
inline void BatteryState::clear_charge() {
  if (GetArenaNoVirtual() == NULL && charge_ != NULL) delete charge_;
  charge_ = NULL;
}
inline const ::choreo::Float32& BatteryState::charge() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.charge)
  return charge_ != NULL ? *charge_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* BatteryState::mutable_charge() {
  
  if (charge_ == NULL) {
    charge_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.charge)
  return charge_;
}
inline ::choreo::Float32* BatteryState::release_charge() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.charge)
  
  ::choreo::Float32* temp = charge_;
  charge_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_charge(::choreo::Float32* charge) {
  delete charge_;
  charge_ = charge;
  if (charge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.charge)
}

// .choreo.Float32 capacity = 8;
inline bool BatteryState::has_capacity() const {
  return this != internal_default_instance() && capacity_ != NULL;
}
inline void BatteryState::clear_capacity() {
  if (GetArenaNoVirtual() == NULL && capacity_ != NULL) delete capacity_;
  capacity_ = NULL;
}
inline const ::choreo::Float32& BatteryState::capacity() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.capacity)
  return capacity_ != NULL ? *capacity_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* BatteryState::mutable_capacity() {
  
  if (capacity_ == NULL) {
    capacity_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.capacity)
  return capacity_;
}
inline ::choreo::Float32* BatteryState::release_capacity() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.capacity)
  
  ::choreo::Float32* temp = capacity_;
  capacity_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_capacity(::choreo::Float32* capacity) {
  delete capacity_;
  capacity_ = capacity;
  if (capacity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.capacity)
}

// .choreo.Float32 design_capacity = 9;
inline bool BatteryState::has_design_capacity() const {
  return this != internal_default_instance() && design_capacity_ != NULL;
}
inline void BatteryState::clear_design_capacity() {
  if (GetArenaNoVirtual() == NULL && design_capacity_ != NULL) delete design_capacity_;
  design_capacity_ = NULL;
}
inline const ::choreo::Float32& BatteryState::design_capacity() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.design_capacity)
  return design_capacity_ != NULL ? *design_capacity_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* BatteryState::mutable_design_capacity() {
  
  if (design_capacity_ == NULL) {
    design_capacity_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.design_capacity)
  return design_capacity_;
}
inline ::choreo::Float32* BatteryState::release_design_capacity() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.design_capacity)
  
  ::choreo::Float32* temp = design_capacity_;
  design_capacity_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_design_capacity(::choreo::Float32* design_capacity) {
  delete design_capacity_;
  design_capacity_ = design_capacity;
  if (design_capacity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.design_capacity)
}

// .choreo.Float32 percentage = 10;
inline bool BatteryState::has_percentage() const {
  return this != internal_default_instance() && percentage_ != NULL;
}
inline void BatteryState::clear_percentage() {
  if (GetArenaNoVirtual() == NULL && percentage_ != NULL) delete percentage_;
  percentage_ = NULL;
}
inline const ::choreo::Float32& BatteryState::percentage() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.percentage)
  return percentage_ != NULL ? *percentage_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* BatteryState::mutable_percentage() {
  
  if (percentage_ == NULL) {
    percentage_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.percentage)
  return percentage_;
}
inline ::choreo::Float32* BatteryState::release_percentage() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.percentage)
  
  ::choreo::Float32* temp = percentage_;
  percentage_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_percentage(::choreo::Float32* percentage) {
  delete percentage_;
  percentage_ = percentage;
  if (percentage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.percentage)
}

// .choreo.UInt32 power_supply_status = 12;
inline bool BatteryState::has_power_supply_status() const {
  return this != internal_default_instance() && power_supply_status_ != NULL;
}
inline void BatteryState::clear_power_supply_status() {
  if (GetArenaNoVirtual() == NULL && power_supply_status_ != NULL) delete power_supply_status_;
  power_supply_status_ = NULL;
}
inline const ::choreo::UInt32& BatteryState::power_supply_status() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.power_supply_status)
  return power_supply_status_ != NULL ? *power_supply_status_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* BatteryState::mutable_power_supply_status() {
  
  if (power_supply_status_ == NULL) {
    power_supply_status_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.power_supply_status)
  return power_supply_status_;
}
inline ::choreo::UInt32* BatteryState::release_power_supply_status() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.power_supply_status)
  
  ::choreo::UInt32* temp = power_supply_status_;
  power_supply_status_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_power_supply_status(::choreo::UInt32* power_supply_status) {
  delete power_supply_status_;
  power_supply_status_ = power_supply_status;
  if (power_supply_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.power_supply_status)
}

// .choreo.UInt32 power_supply_health = 13;
inline bool BatteryState::has_power_supply_health() const {
  return this != internal_default_instance() && power_supply_health_ != NULL;
}
inline void BatteryState::clear_power_supply_health() {
  if (GetArenaNoVirtual() == NULL && power_supply_health_ != NULL) delete power_supply_health_;
  power_supply_health_ = NULL;
}
inline const ::choreo::UInt32& BatteryState::power_supply_health() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.power_supply_health)
  return power_supply_health_ != NULL ? *power_supply_health_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* BatteryState::mutable_power_supply_health() {
  
  if (power_supply_health_ == NULL) {
    power_supply_health_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.power_supply_health)
  return power_supply_health_;
}
inline ::choreo::UInt32* BatteryState::release_power_supply_health() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.power_supply_health)
  
  ::choreo::UInt32* temp = power_supply_health_;
  power_supply_health_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_power_supply_health(::choreo::UInt32* power_supply_health) {
  delete power_supply_health_;
  power_supply_health_ = power_supply_health;
  if (power_supply_health) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.power_supply_health)
}

// .choreo.UInt32 power_supply_technology = 14;
inline bool BatteryState::has_power_supply_technology() const {
  return this != internal_default_instance() && power_supply_technology_ != NULL;
}
inline void BatteryState::clear_power_supply_technology() {
  if (GetArenaNoVirtual() == NULL && power_supply_technology_ != NULL) delete power_supply_technology_;
  power_supply_technology_ = NULL;
}
inline const ::choreo::UInt32& BatteryState::power_supply_technology() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.power_supply_technology)
  return power_supply_technology_ != NULL ? *power_supply_technology_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* BatteryState::mutable_power_supply_technology() {
  
  if (power_supply_technology_ == NULL) {
    power_supply_technology_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.power_supply_technology)
  return power_supply_technology_;
}
inline ::choreo::UInt32* BatteryState::release_power_supply_technology() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.power_supply_technology)
  
  ::choreo::UInt32* temp = power_supply_technology_;
  power_supply_technology_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_power_supply_technology(::choreo::UInt32* power_supply_technology) {
  delete power_supply_technology_;
  power_supply_technology_ = power_supply_technology;
  if (power_supply_technology) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.power_supply_technology)
}

// .choreo.Bool present = 15;
inline bool BatteryState::has_present() const {
  return this != internal_default_instance() && present_ != NULL;
}
inline void BatteryState::clear_present() {
  if (GetArenaNoVirtual() == NULL && present_ != NULL) delete present_;
  present_ = NULL;
}
inline const ::choreo::Bool& BatteryState::present() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.present)
  return present_ != NULL ? *present_
                         : *::choreo::Bool::internal_default_instance();
}
inline ::choreo::Bool* BatteryState::mutable_present() {
  
  if (present_ == NULL) {
    present_ = new ::choreo::Bool;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.present)
  return present_;
}
inline ::choreo::Bool* BatteryState::release_present() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.present)
  
  ::choreo::Bool* temp = present_;
  present_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_present(::choreo::Bool* present) {
  delete present_;
  present_ = present;
  if (present) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.present)
}

// .choreo.Float32 cell_voltage = 16;
inline bool BatteryState::has_cell_voltage() const {
  return this != internal_default_instance() && cell_voltage_ != NULL;
}
inline void BatteryState::clear_cell_voltage() {
  if (GetArenaNoVirtual() == NULL && cell_voltage_ != NULL) delete cell_voltage_;
  cell_voltage_ = NULL;
}
inline const ::choreo::Float32& BatteryState::cell_voltage() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.cell_voltage)
  return cell_voltage_ != NULL ? *cell_voltage_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* BatteryState::mutable_cell_voltage() {
  
  if (cell_voltage_ == NULL) {
    cell_voltage_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.cell_voltage)
  return cell_voltage_;
}
inline ::choreo::Float32* BatteryState::release_cell_voltage() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.cell_voltage)
  
  ::choreo::Float32* temp = cell_voltage_;
  cell_voltage_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_cell_voltage(::choreo::Float32* cell_voltage) {
  delete cell_voltage_;
  cell_voltage_ = cell_voltage;
  if (cell_voltage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.cell_voltage)
}

// .choreo.String location = 17;
inline bool BatteryState::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void BatteryState::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::choreo::String& BatteryState::location() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.location)
  return location_ != NULL ? *location_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* BatteryState::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.location)
  return location_;
}
inline ::choreo::String* BatteryState::release_location() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.location)
  
  ::choreo::String* temp = location_;
  location_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_location(::choreo::String* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.location)
}

// .choreo.String serial_number = 18;
inline bool BatteryState::has_serial_number() const {
  return this != internal_default_instance() && serial_number_ != NULL;
}
inline void BatteryState::clear_serial_number() {
  if (GetArenaNoVirtual() == NULL && serial_number_ != NULL) delete serial_number_;
  serial_number_ = NULL;
}
inline const ::choreo::String& BatteryState::serial_number() const {
  // @@protoc_insertion_point(field_get:choreo.BatteryState.serial_number)
  return serial_number_ != NULL ? *serial_number_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* BatteryState::mutable_serial_number() {
  
  if (serial_number_ == NULL) {
    serial_number_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.BatteryState.serial_number)
  return serial_number_;
}
inline ::choreo::String* BatteryState::release_serial_number() {
  // @@protoc_insertion_point(field_release:choreo.BatteryState.serial_number)
  
  ::choreo::String* temp = serial_number_;
  serial_number_ = NULL;
  return temp;
}
inline void BatteryState::set_allocated_serial_number(::choreo::String* serial_number) {
  delete serial_number_;
  serial_number_ = serial_number;
  if (serial_number) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.BatteryState.serial_number)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)


}  // namespace choreo

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::choreo::BatteryState_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::choreo::BatteryState_Status>() {
  return ::choreo::BatteryState_Status_descriptor();
}
template <> struct is_proto_enum< ::choreo::BatteryState_Health> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::choreo::BatteryState_Health>() {
  return ::choreo::BatteryState_Health_descriptor();
}
template <> struct is_proto_enum< ::choreo::BatteryState_Technology> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::choreo::BatteryState_Technology>() {
  return ::choreo::BatteryState_Technology_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sensor_2fbattery_2eproto__INCLUDED
