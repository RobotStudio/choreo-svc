// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor/camera.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "sensor/camera.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace choreo {
class RegionOfInterestDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RegionOfInterest> {
} _RegionOfInterest_default_instance_;
class CameraInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<CameraInfo> {
} _CameraInfo_default_instance_;
class ChannelFloat32DefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ChannelFloat32> {
} _ChannelFloat32_default_instance_;
class CompressedImageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<CompressedImage> {
} _CompressedImage_default_instance_;
class ImageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Image> {
} _Image_default_instance_;
class ColorRGBADefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ColorRGBA> {
} _ColorRGBA_default_instance_;

namespace protobuf_sensor_2fcamera_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[6];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegionOfInterest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegionOfInterest, x_offset_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegionOfInterest, y_offset_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegionOfInterest, height_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegionOfInterest, width_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegionOfInterest, do_rectify_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, height_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, width_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, distortion_model_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, d_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, k_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, p_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, binning_x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, binning_y_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, roi_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelFloat32, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelFloat32, name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelFloat32, values_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CompressedImage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CompressedImage, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CompressedImage, format_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CompressedImage, data_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, height_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, width_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, encoding_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, is_bigendian_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, step_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, data_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColorRGBA, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColorRGBA, r_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColorRGBA, g_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColorRGBA, b_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColorRGBA, a_),
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, -1, sizeof(RegionOfInterest)},
  { 10, -1, sizeof(CameraInfo)},
  { 25, -1, sizeof(ChannelFloat32)},
  { 32, -1, sizeof(CompressedImage)},
  { 40, -1, sizeof(Image)},
  { 52, -1, sizeof(ColorRGBA)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_RegionOfInterest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_CameraInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ChannelFloat32_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_CompressedImage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Image_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ColorRGBA_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "sensor/camera.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, NULL, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 6);
}

}  // namespace

void TableStruct::Shutdown() {
  _RegionOfInterest_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _CameraInfo_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _ChannelFloat32_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _CompressedImage_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _Image_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _ColorRGBA_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::choreo::protobuf_primitive_2fbool_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2ffloat_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2fheader_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2fint_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2fstring_2eproto::InitDefaults();
  _RegionOfInterest_default_instance_.DefaultConstruct();
  _CameraInfo_default_instance_.DefaultConstruct();
  _ChannelFloat32_default_instance_.DefaultConstruct();
  _CompressedImage_default_instance_.DefaultConstruct();
  _Image_default_instance_.DefaultConstruct();
  _ColorRGBA_default_instance_.DefaultConstruct();
  _RegionOfInterest_default_instance_.get_mutable()->x_offset_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _RegionOfInterest_default_instance_.get_mutable()->y_offset_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _RegionOfInterest_default_instance_.get_mutable()->height_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _RegionOfInterest_default_instance_.get_mutable()->width_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _RegionOfInterest_default_instance_.get_mutable()->do_rectify_ = const_cast< ::choreo::Bool*>(
      ::choreo::Bool::internal_default_instance());
  _CameraInfo_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _CameraInfo_default_instance_.get_mutable()->height_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _CameraInfo_default_instance_.get_mutable()->width_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _CameraInfo_default_instance_.get_mutable()->distortion_model_ = const_cast< ::choreo::String*>(
      ::choreo::String::internal_default_instance());
  _CameraInfo_default_instance_.get_mutable()->binning_x_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _CameraInfo_default_instance_.get_mutable()->binning_y_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _CameraInfo_default_instance_.get_mutable()->roi_ = const_cast< ::choreo::RegionOfInterest*>(
      ::choreo::RegionOfInterest::internal_default_instance());
  _ChannelFloat32_default_instance_.get_mutable()->name_ = const_cast< ::choreo::String*>(
      ::choreo::String::internal_default_instance());
  _CompressedImage_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _CompressedImage_default_instance_.get_mutable()->format_ = const_cast< ::choreo::String*>(
      ::choreo::String::internal_default_instance());
  _Image_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _Image_default_instance_.get_mutable()->height_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _Image_default_instance_.get_mutable()->width_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _Image_default_instance_.get_mutable()->encoding_ = const_cast< ::choreo::String*>(
      ::choreo::String::internal_default_instance());
  _Image_default_instance_.get_mutable()->is_bigendian_ = const_cast< ::choreo::Bool*>(
      ::choreo::Bool::internal_default_instance());
  _Image_default_instance_.get_mutable()->step_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _ColorRGBA_default_instance_.get_mutable()->r_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _ColorRGBA_default_instance_.get_mutable()->g_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _ColorRGBA_default_instance_.get_mutable()->b_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _ColorRGBA_default_instance_.get_mutable()->a_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\023sensor/camera.proto\022\006choreo\032\024primitive"
      "/bool.proto\032\025primitive/float.proto\032\026prim"
      "itive/header.proto\032\023primitive/int.proto\032"
      "\026primitive/string.proto\"\267\001\n\020RegionOfInte"
      "rest\022 \n\010x_offset\030\001 \001(\0132\016.choreo.UInt32\022 "
      "\n\010y_offset\030\002 \001(\0132\016.choreo.UInt32\022\036\n\006heig"
      "ht\030\003 \001(\0132\016.choreo.UInt32\022\035\n\005width\030\004 \001(\0132"
      "\016.choreo.UInt32\022 \n\ndo_rectify\030\005 \001(\0132\014.ch"
      "oreo.Bool\"\326\002\n\nCameraInfo\022\036\n\006header\030\001 \001(\013"
      "2\016.choreo.Header\022\036\n\006height\030\002 \001(\0132\016.chore"
      "o.UInt32\022\035\n\005width\030\003 \001(\0132\016.choreo.UInt32\022"
      "(\n\020distortion_model\030\004 \001(\0132\016.choreo.Strin"
      "g\022\032\n\001D\030\005 \003(\0132\017.choreo.Float64\022\032\n\001K\030\006 \003(\013"
      "2\017.choreo.Float64\022\032\n\001P\030\007 \003(\0132\017.choreo.Fl"
      "oat64\022!\n\tbinning_x\030\010 \001(\0132\016.choreo.UInt32"
      "\022!\n\tbinning_y\030\t \001(\0132\016.choreo.UInt32\022%\n\003r"
      "oi\030\n \001(\0132\030.choreo.RegionOfInterest\"O\n\016Ch"
      "annelFloat32\022\034\n\004name\030\001 \001(\0132\016.choreo.Stri"
      "ng\022\037\n\006values\030\002 \003(\0132\017.choreo.Float32\"o\n\017C"
      "ompressedImage\022\036\n\006header\030\001 \001(\0132\016.choreo."
      "Header\022\036\n\006format\030\002 \001(\0132\016.choreo.String\022\034"
      "\n\004data\030\003 \003(\0132\016.choreo.UInt32\"\350\001\n\005Image\022\036"
      "\n\006header\030\001 \001(\0132\016.choreo.Header\022\036\n\006height"
      "\030\002 \001(\0132\016.choreo.UInt32\022\035\n\005width\030\003 \001(\0132\016."
      "choreo.UInt32\022 \n\010encoding\030\004 \001(\0132\016.choreo"
      ".String\022\"\n\014is_bigendian\030\005 \001(\0132\014.choreo.B"
      "ool\022\034\n\004step\030\006 \001(\0132\016.choreo.UInt32\022\034\n\004dat"
      "a\030\007 \003(\0132\016.choreo.UInt32\"{\n\tColorRGBA\022\032\n\001"
      "r\030\001 \001(\0132\017.choreo.Float32\022\032\n\001g\030\002 \001(\0132\017.ch"
      "oreo.Float32\022\032\n\001b\030\003 \001(\0132\017.choreo.Float32"
      "\022\032\n\001a\030\004 \001(\0132\017.choreo.Float32B+Z)github.c"
      "om/RobotStudio/choreo-msg/msg;msgb\006proto"
      "3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 1281);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "sensor/camera.proto", &protobuf_RegisterTypes);
  ::choreo::protobuf_primitive_2fbool_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2ffloat_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2fheader_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2fint_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2fstring_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_sensor_2fcamera_2eproto


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RegionOfInterest::kXOffsetFieldNumber;
const int RegionOfInterest::kYOffsetFieldNumber;
const int RegionOfInterest::kHeightFieldNumber;
const int RegionOfInterest::kWidthFieldNumber;
const int RegionOfInterest::kDoRectifyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegionOfInterest::RegionOfInterest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_sensor_2fcamera_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.RegionOfInterest)
}
RegionOfInterest::RegionOfInterest(const RegionOfInterest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_x_offset()) {
    x_offset_ = new ::choreo::UInt32(*from.x_offset_);
  } else {
    x_offset_ = NULL;
  }
  if (from.has_y_offset()) {
    y_offset_ = new ::choreo::UInt32(*from.y_offset_);
  } else {
    y_offset_ = NULL;
  }
  if (from.has_height()) {
    height_ = new ::choreo::UInt32(*from.height_);
  } else {
    height_ = NULL;
  }
  if (from.has_width()) {
    width_ = new ::choreo::UInt32(*from.width_);
  } else {
    width_ = NULL;
  }
  if (from.has_do_rectify()) {
    do_rectify_ = new ::choreo::Bool(*from.do_rectify_);
  } else {
    do_rectify_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.RegionOfInterest)
}

void RegionOfInterest::SharedCtor() {
  ::memset(&x_offset_, 0, reinterpret_cast<char*>(&do_rectify_) -
    reinterpret_cast<char*>(&x_offset_) + sizeof(do_rectify_));
  _cached_size_ = 0;
}

RegionOfInterest::~RegionOfInterest() {
  // @@protoc_insertion_point(destructor:choreo.RegionOfInterest)
  SharedDtor();
}

void RegionOfInterest::SharedDtor() {
  if (this != internal_default_instance()) {
    delete x_offset_;
  }
  if (this != internal_default_instance()) {
    delete y_offset_;
  }
  if (this != internal_default_instance()) {
    delete height_;
  }
  if (this != internal_default_instance()) {
    delete width_;
  }
  if (this != internal_default_instance()) {
    delete do_rectify_;
  }
}

void RegionOfInterest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegionOfInterest::descriptor() {
  protobuf_sensor_2fcamera_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fcamera_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RegionOfInterest& RegionOfInterest::default_instance() {
  protobuf_sensor_2fcamera_2eproto::InitDefaults();
  return *internal_default_instance();
}

RegionOfInterest* RegionOfInterest::New(::google::protobuf::Arena* arena) const {
  RegionOfInterest* n = new RegionOfInterest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegionOfInterest::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.RegionOfInterest)
  if (GetArenaNoVirtual() == NULL && x_offset_ != NULL) {
    delete x_offset_;
  }
  x_offset_ = NULL;
  if (GetArenaNoVirtual() == NULL && y_offset_ != NULL) {
    delete y_offset_;
  }
  y_offset_ = NULL;
  if (GetArenaNoVirtual() == NULL && height_ != NULL) {
    delete height_;
  }
  height_ = NULL;
  if (GetArenaNoVirtual() == NULL && width_ != NULL) {
    delete width_;
  }
  width_ = NULL;
  if (GetArenaNoVirtual() == NULL && do_rectify_ != NULL) {
    delete do_rectify_;
  }
  do_rectify_ = NULL;
}

bool RegionOfInterest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.RegionOfInterest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.UInt32 x_offset = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_x_offset()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 y_offset = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_y_offset()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 height = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_height()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 width = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_width()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Bool do_rectify = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_do_rectify()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.RegionOfInterest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.RegionOfInterest)
  return false;
#undef DO_
}

void RegionOfInterest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.RegionOfInterest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.UInt32 x_offset = 1;
  if (this->has_x_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->x_offset_, output);
  }

  // .choreo.UInt32 y_offset = 2;
  if (this->has_y_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->y_offset_, output);
  }

  // .choreo.UInt32 height = 3;
  if (this->has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->height_, output);
  }

  // .choreo.UInt32 width = 4;
  if (this->has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->width_, output);
  }

  // .choreo.Bool do_rectify = 5;
  if (this->has_do_rectify()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->do_rectify_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.RegionOfInterest)
}

::google::protobuf::uint8* RegionOfInterest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.RegionOfInterest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.UInt32 x_offset = 1;
  if (this->has_x_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->x_offset_, deterministic, target);
  }

  // .choreo.UInt32 y_offset = 2;
  if (this->has_y_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->y_offset_, deterministic, target);
  }

  // .choreo.UInt32 height = 3;
  if (this->has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->height_, deterministic, target);
  }

  // .choreo.UInt32 width = 4;
  if (this->has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->width_, deterministic, target);
  }

  // .choreo.Bool do_rectify = 5;
  if (this->has_do_rectify()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->do_rectify_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.RegionOfInterest)
  return target;
}

size_t RegionOfInterest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.RegionOfInterest)
  size_t total_size = 0;

  // .choreo.UInt32 x_offset = 1;
  if (this->has_x_offset()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->x_offset_);
  }

  // .choreo.UInt32 y_offset = 2;
  if (this->has_y_offset()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->y_offset_);
  }

  // .choreo.UInt32 height = 3;
  if (this->has_height()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->height_);
  }

  // .choreo.UInt32 width = 4;
  if (this->has_width()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->width_);
  }

  // .choreo.Bool do_rectify = 5;
  if (this->has_do_rectify()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->do_rectify_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegionOfInterest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.RegionOfInterest)
  GOOGLE_DCHECK_NE(&from, this);
  const RegionOfInterest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RegionOfInterest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.RegionOfInterest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.RegionOfInterest)
    MergeFrom(*source);
  }
}

void RegionOfInterest::MergeFrom(const RegionOfInterest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.RegionOfInterest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_x_offset()) {
    mutable_x_offset()->::choreo::UInt32::MergeFrom(from.x_offset());
  }
  if (from.has_y_offset()) {
    mutable_y_offset()->::choreo::UInt32::MergeFrom(from.y_offset());
  }
  if (from.has_height()) {
    mutable_height()->::choreo::UInt32::MergeFrom(from.height());
  }
  if (from.has_width()) {
    mutable_width()->::choreo::UInt32::MergeFrom(from.width());
  }
  if (from.has_do_rectify()) {
    mutable_do_rectify()->::choreo::Bool::MergeFrom(from.do_rectify());
  }
}

void RegionOfInterest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.RegionOfInterest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegionOfInterest::CopyFrom(const RegionOfInterest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.RegionOfInterest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegionOfInterest::IsInitialized() const {
  return true;
}

void RegionOfInterest::Swap(RegionOfInterest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegionOfInterest::InternalSwap(RegionOfInterest* other) {
  std::swap(x_offset_, other->x_offset_);
  std::swap(y_offset_, other->y_offset_);
  std::swap(height_, other->height_);
  std::swap(width_, other->width_);
  std::swap(do_rectify_, other->do_rectify_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RegionOfInterest::GetMetadata() const {
  protobuf_sensor_2fcamera_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fcamera_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegionOfInterest

// .choreo.UInt32 x_offset = 1;
bool RegionOfInterest::has_x_offset() const {
  return this != internal_default_instance() && x_offset_ != NULL;
}
void RegionOfInterest::clear_x_offset() {
  if (GetArenaNoVirtual() == NULL && x_offset_ != NULL) delete x_offset_;
  x_offset_ = NULL;
}
const ::choreo::UInt32& RegionOfInterest::x_offset() const {
  // @@protoc_insertion_point(field_get:choreo.RegionOfInterest.x_offset)
  return x_offset_ != NULL ? *x_offset_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* RegionOfInterest::mutable_x_offset() {
  
  if (x_offset_ == NULL) {
    x_offset_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.RegionOfInterest.x_offset)
  return x_offset_;
}
::choreo::UInt32* RegionOfInterest::release_x_offset() {
  // @@protoc_insertion_point(field_release:choreo.RegionOfInterest.x_offset)
  
  ::choreo::UInt32* temp = x_offset_;
  x_offset_ = NULL;
  return temp;
}
void RegionOfInterest::set_allocated_x_offset(::choreo::UInt32* x_offset) {
  delete x_offset_;
  x_offset_ = x_offset;
  if (x_offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.RegionOfInterest.x_offset)
}

// .choreo.UInt32 y_offset = 2;
bool RegionOfInterest::has_y_offset() const {
  return this != internal_default_instance() && y_offset_ != NULL;
}
void RegionOfInterest::clear_y_offset() {
  if (GetArenaNoVirtual() == NULL && y_offset_ != NULL) delete y_offset_;
  y_offset_ = NULL;
}
const ::choreo::UInt32& RegionOfInterest::y_offset() const {
  // @@protoc_insertion_point(field_get:choreo.RegionOfInterest.y_offset)
  return y_offset_ != NULL ? *y_offset_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* RegionOfInterest::mutable_y_offset() {
  
  if (y_offset_ == NULL) {
    y_offset_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.RegionOfInterest.y_offset)
  return y_offset_;
}
::choreo::UInt32* RegionOfInterest::release_y_offset() {
  // @@protoc_insertion_point(field_release:choreo.RegionOfInterest.y_offset)
  
  ::choreo::UInt32* temp = y_offset_;
  y_offset_ = NULL;
  return temp;
}
void RegionOfInterest::set_allocated_y_offset(::choreo::UInt32* y_offset) {
  delete y_offset_;
  y_offset_ = y_offset;
  if (y_offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.RegionOfInterest.y_offset)
}

// .choreo.UInt32 height = 3;
bool RegionOfInterest::has_height() const {
  return this != internal_default_instance() && height_ != NULL;
}
void RegionOfInterest::clear_height() {
  if (GetArenaNoVirtual() == NULL && height_ != NULL) delete height_;
  height_ = NULL;
}
const ::choreo::UInt32& RegionOfInterest::height() const {
  // @@protoc_insertion_point(field_get:choreo.RegionOfInterest.height)
  return height_ != NULL ? *height_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* RegionOfInterest::mutable_height() {
  
  if (height_ == NULL) {
    height_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.RegionOfInterest.height)
  return height_;
}
::choreo::UInt32* RegionOfInterest::release_height() {
  // @@protoc_insertion_point(field_release:choreo.RegionOfInterest.height)
  
  ::choreo::UInt32* temp = height_;
  height_ = NULL;
  return temp;
}
void RegionOfInterest::set_allocated_height(::choreo::UInt32* height) {
  delete height_;
  height_ = height;
  if (height) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.RegionOfInterest.height)
}

// .choreo.UInt32 width = 4;
bool RegionOfInterest::has_width() const {
  return this != internal_default_instance() && width_ != NULL;
}
void RegionOfInterest::clear_width() {
  if (GetArenaNoVirtual() == NULL && width_ != NULL) delete width_;
  width_ = NULL;
}
const ::choreo::UInt32& RegionOfInterest::width() const {
  // @@protoc_insertion_point(field_get:choreo.RegionOfInterest.width)
  return width_ != NULL ? *width_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* RegionOfInterest::mutable_width() {
  
  if (width_ == NULL) {
    width_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.RegionOfInterest.width)
  return width_;
}
::choreo::UInt32* RegionOfInterest::release_width() {
  // @@protoc_insertion_point(field_release:choreo.RegionOfInterest.width)
  
  ::choreo::UInt32* temp = width_;
  width_ = NULL;
  return temp;
}
void RegionOfInterest::set_allocated_width(::choreo::UInt32* width) {
  delete width_;
  width_ = width;
  if (width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.RegionOfInterest.width)
}

// .choreo.Bool do_rectify = 5;
bool RegionOfInterest::has_do_rectify() const {
  return this != internal_default_instance() && do_rectify_ != NULL;
}
void RegionOfInterest::clear_do_rectify() {
  if (GetArenaNoVirtual() == NULL && do_rectify_ != NULL) delete do_rectify_;
  do_rectify_ = NULL;
}
const ::choreo::Bool& RegionOfInterest::do_rectify() const {
  // @@protoc_insertion_point(field_get:choreo.RegionOfInterest.do_rectify)
  return do_rectify_ != NULL ? *do_rectify_
                         : *::choreo::Bool::internal_default_instance();
}
::choreo::Bool* RegionOfInterest::mutable_do_rectify() {
  
  if (do_rectify_ == NULL) {
    do_rectify_ = new ::choreo::Bool;
  }
  // @@protoc_insertion_point(field_mutable:choreo.RegionOfInterest.do_rectify)
  return do_rectify_;
}
::choreo::Bool* RegionOfInterest::release_do_rectify() {
  // @@protoc_insertion_point(field_release:choreo.RegionOfInterest.do_rectify)
  
  ::choreo::Bool* temp = do_rectify_;
  do_rectify_ = NULL;
  return temp;
}
void RegionOfInterest::set_allocated_do_rectify(::choreo::Bool* do_rectify) {
  delete do_rectify_;
  do_rectify_ = do_rectify;
  if (do_rectify) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.RegionOfInterest.do_rectify)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CameraInfo::kHeaderFieldNumber;
const int CameraInfo::kHeightFieldNumber;
const int CameraInfo::kWidthFieldNumber;
const int CameraInfo::kDistortionModelFieldNumber;
const int CameraInfo::kDFieldNumber;
const int CameraInfo::kKFieldNumber;
const int CameraInfo::kPFieldNumber;
const int CameraInfo::kBinningXFieldNumber;
const int CameraInfo::kBinningYFieldNumber;
const int CameraInfo::kRoiFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CameraInfo::CameraInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_sensor_2fcamera_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.CameraInfo)
}
CameraInfo::CameraInfo(const CameraInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      d_(from.d_),
      k_(from.k_),
      p_(from.p_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_height()) {
    height_ = new ::choreo::UInt32(*from.height_);
  } else {
    height_ = NULL;
  }
  if (from.has_width()) {
    width_ = new ::choreo::UInt32(*from.width_);
  } else {
    width_ = NULL;
  }
  if (from.has_distortion_model()) {
    distortion_model_ = new ::choreo::String(*from.distortion_model_);
  } else {
    distortion_model_ = NULL;
  }
  if (from.has_binning_x()) {
    binning_x_ = new ::choreo::UInt32(*from.binning_x_);
  } else {
    binning_x_ = NULL;
  }
  if (from.has_binning_y()) {
    binning_y_ = new ::choreo::UInt32(*from.binning_y_);
  } else {
    binning_y_ = NULL;
  }
  if (from.has_roi()) {
    roi_ = new ::choreo::RegionOfInterest(*from.roi_);
  } else {
    roi_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.CameraInfo)
}

void CameraInfo::SharedCtor() {
  ::memset(&header_, 0, reinterpret_cast<char*>(&roi_) -
    reinterpret_cast<char*>(&header_) + sizeof(roi_));
  _cached_size_ = 0;
}

CameraInfo::~CameraInfo() {
  // @@protoc_insertion_point(destructor:choreo.CameraInfo)
  SharedDtor();
}

void CameraInfo::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete height_;
  }
  if (this != internal_default_instance()) {
    delete width_;
  }
  if (this != internal_default_instance()) {
    delete distortion_model_;
  }
  if (this != internal_default_instance()) {
    delete binning_x_;
  }
  if (this != internal_default_instance()) {
    delete binning_y_;
  }
  if (this != internal_default_instance()) {
    delete roi_;
  }
}

void CameraInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CameraInfo::descriptor() {
  protobuf_sensor_2fcamera_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fcamera_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CameraInfo& CameraInfo::default_instance() {
  protobuf_sensor_2fcamera_2eproto::InitDefaults();
  return *internal_default_instance();
}

CameraInfo* CameraInfo::New(::google::protobuf::Arena* arena) const {
  CameraInfo* n = new CameraInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CameraInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.CameraInfo)
  d_.Clear();
  k_.Clear();
  p_.Clear();
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && height_ != NULL) {
    delete height_;
  }
  height_ = NULL;
  if (GetArenaNoVirtual() == NULL && width_ != NULL) {
    delete width_;
  }
  width_ = NULL;
  if (GetArenaNoVirtual() == NULL && distortion_model_ != NULL) {
    delete distortion_model_;
  }
  distortion_model_ = NULL;
  if (GetArenaNoVirtual() == NULL && binning_x_ != NULL) {
    delete binning_x_;
  }
  binning_x_ = NULL;
  if (GetArenaNoVirtual() == NULL && binning_y_ != NULL) {
    delete binning_y_;
  }
  binning_y_ = NULL;
  if (GetArenaNoVirtual() == NULL && roi_ != NULL) {
    delete roi_;
  }
  roi_ = NULL;
}

bool CameraInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.CameraInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 height = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_height()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 width = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_width()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.String distortion_model = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_distortion_model()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.Float64 D = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_d()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.Float64 K = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_k()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.Float64 P = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_p()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 binning_x = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_binning_x()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 binning_y = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_binning_y()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.RegionOfInterest roi = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_roi()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.CameraInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.CameraInfo)
  return false;
#undef DO_
}

void CameraInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.CameraInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .choreo.UInt32 height = 2;
  if (this->has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->height_, output);
  }

  // .choreo.UInt32 width = 3;
  if (this->has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->width_, output);
  }

  // .choreo.String distortion_model = 4;
  if (this->has_distortion_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->distortion_model_, output);
  }

  // repeated .choreo.Float64 D = 5;
  for (unsigned int i = 0, n = this->d_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->d(i), output);
  }

  // repeated .choreo.Float64 K = 6;
  for (unsigned int i = 0, n = this->k_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->k(i), output);
  }

  // repeated .choreo.Float64 P = 7;
  for (unsigned int i = 0, n = this->p_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->p(i), output);
  }

  // .choreo.UInt32 binning_x = 8;
  if (this->has_binning_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->binning_x_, output);
  }

  // .choreo.UInt32 binning_y = 9;
  if (this->has_binning_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->binning_y_, output);
  }

  // .choreo.RegionOfInterest roi = 10;
  if (this->has_roi()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->roi_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.CameraInfo)
}

::google::protobuf::uint8* CameraInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.CameraInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // .choreo.UInt32 height = 2;
  if (this->has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->height_, deterministic, target);
  }

  // .choreo.UInt32 width = 3;
  if (this->has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->width_, deterministic, target);
  }

  // .choreo.String distortion_model = 4;
  if (this->has_distortion_model()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->distortion_model_, deterministic, target);
  }

  // repeated .choreo.Float64 D = 5;
  for (unsigned int i = 0, n = this->d_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->d(i), deterministic, target);
  }

  // repeated .choreo.Float64 K = 6;
  for (unsigned int i = 0, n = this->k_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, this->k(i), deterministic, target);
  }

  // repeated .choreo.Float64 P = 7;
  for (unsigned int i = 0, n = this->p_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, this->p(i), deterministic, target);
  }

  // .choreo.UInt32 binning_x = 8;
  if (this->has_binning_x()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->binning_x_, deterministic, target);
  }

  // .choreo.UInt32 binning_y = 9;
  if (this->has_binning_y()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *this->binning_y_, deterministic, target);
  }

  // .choreo.RegionOfInterest roi = 10;
  if (this->has_roi()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, *this->roi_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.CameraInfo)
  return target;
}

size_t CameraInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.CameraInfo)
  size_t total_size = 0;

  // repeated .choreo.Float64 D = 5;
  {
    unsigned int count = this->d_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->d(i));
    }
  }

  // repeated .choreo.Float64 K = 6;
  {
    unsigned int count = this->k_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->k(i));
    }
  }

  // repeated .choreo.Float64 P = 7;
  {
    unsigned int count = this->p_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->p(i));
    }
  }

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // .choreo.UInt32 height = 2;
  if (this->has_height()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->height_);
  }

  // .choreo.UInt32 width = 3;
  if (this->has_width()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->width_);
  }

  // .choreo.String distortion_model = 4;
  if (this->has_distortion_model()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->distortion_model_);
  }

  // .choreo.UInt32 binning_x = 8;
  if (this->has_binning_x()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->binning_x_);
  }

  // .choreo.UInt32 binning_y = 9;
  if (this->has_binning_y()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->binning_y_);
  }

  // .choreo.RegionOfInterest roi = 10;
  if (this->has_roi()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->roi_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CameraInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.CameraInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const CameraInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CameraInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.CameraInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.CameraInfo)
    MergeFrom(*source);
  }
}

void CameraInfo::MergeFrom(const CameraInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.CameraInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  d_.MergeFrom(from.d_);
  k_.MergeFrom(from.k_);
  p_.MergeFrom(from.p_);
  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
  if (from.has_height()) {
    mutable_height()->::choreo::UInt32::MergeFrom(from.height());
  }
  if (from.has_width()) {
    mutable_width()->::choreo::UInt32::MergeFrom(from.width());
  }
  if (from.has_distortion_model()) {
    mutable_distortion_model()->::choreo::String::MergeFrom(from.distortion_model());
  }
  if (from.has_binning_x()) {
    mutable_binning_x()->::choreo::UInt32::MergeFrom(from.binning_x());
  }
  if (from.has_binning_y()) {
    mutable_binning_y()->::choreo::UInt32::MergeFrom(from.binning_y());
  }
  if (from.has_roi()) {
    mutable_roi()->::choreo::RegionOfInterest::MergeFrom(from.roi());
  }
}

void CameraInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.CameraInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CameraInfo::CopyFrom(const CameraInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.CameraInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraInfo::IsInitialized() const {
  return true;
}

void CameraInfo::Swap(CameraInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CameraInfo::InternalSwap(CameraInfo* other) {
  d_.InternalSwap(&other->d_);
  k_.InternalSwap(&other->k_);
  p_.InternalSwap(&other->p_);
  std::swap(header_, other->header_);
  std::swap(height_, other->height_);
  std::swap(width_, other->width_);
  std::swap(distortion_model_, other->distortion_model_);
  std::swap(binning_x_, other->binning_x_);
  std::swap(binning_y_, other->binning_y_);
  std::swap(roi_, other->roi_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CameraInfo::GetMetadata() const {
  protobuf_sensor_2fcamera_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fcamera_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CameraInfo

// .choreo.Header header = 1;
bool CameraInfo::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void CameraInfo::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& CameraInfo::header() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* CameraInfo::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.header)
  return header_;
}
::choreo::Header* CameraInfo::release_header() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void CameraInfo::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.header)
}

// .choreo.UInt32 height = 2;
bool CameraInfo::has_height() const {
  return this != internal_default_instance() && height_ != NULL;
}
void CameraInfo::clear_height() {
  if (GetArenaNoVirtual() == NULL && height_ != NULL) delete height_;
  height_ = NULL;
}
const ::choreo::UInt32& CameraInfo::height() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.height)
  return height_ != NULL ? *height_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* CameraInfo::mutable_height() {
  
  if (height_ == NULL) {
    height_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.height)
  return height_;
}
::choreo::UInt32* CameraInfo::release_height() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.height)
  
  ::choreo::UInt32* temp = height_;
  height_ = NULL;
  return temp;
}
void CameraInfo::set_allocated_height(::choreo::UInt32* height) {
  delete height_;
  height_ = height;
  if (height) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.height)
}

// .choreo.UInt32 width = 3;
bool CameraInfo::has_width() const {
  return this != internal_default_instance() && width_ != NULL;
}
void CameraInfo::clear_width() {
  if (GetArenaNoVirtual() == NULL && width_ != NULL) delete width_;
  width_ = NULL;
}
const ::choreo::UInt32& CameraInfo::width() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.width)
  return width_ != NULL ? *width_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* CameraInfo::mutable_width() {
  
  if (width_ == NULL) {
    width_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.width)
  return width_;
}
::choreo::UInt32* CameraInfo::release_width() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.width)
  
  ::choreo::UInt32* temp = width_;
  width_ = NULL;
  return temp;
}
void CameraInfo::set_allocated_width(::choreo::UInt32* width) {
  delete width_;
  width_ = width;
  if (width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.width)
}

// .choreo.String distortion_model = 4;
bool CameraInfo::has_distortion_model() const {
  return this != internal_default_instance() && distortion_model_ != NULL;
}
void CameraInfo::clear_distortion_model() {
  if (GetArenaNoVirtual() == NULL && distortion_model_ != NULL) delete distortion_model_;
  distortion_model_ = NULL;
}
const ::choreo::String& CameraInfo::distortion_model() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.distortion_model)
  return distortion_model_ != NULL ? *distortion_model_
                         : *::choreo::String::internal_default_instance();
}
::choreo::String* CameraInfo::mutable_distortion_model() {
  
  if (distortion_model_ == NULL) {
    distortion_model_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.distortion_model)
  return distortion_model_;
}
::choreo::String* CameraInfo::release_distortion_model() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.distortion_model)
  
  ::choreo::String* temp = distortion_model_;
  distortion_model_ = NULL;
  return temp;
}
void CameraInfo::set_allocated_distortion_model(::choreo::String* distortion_model) {
  delete distortion_model_;
  distortion_model_ = distortion_model;
  if (distortion_model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.distortion_model)
}

// repeated .choreo.Float64 D = 5;
int CameraInfo::d_size() const {
  return d_.size();
}
void CameraInfo::clear_d() {
  d_.Clear();
}
const ::choreo::Float64& CameraInfo::d(int index) const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.D)
  return d_.Get(index);
}
::choreo::Float64* CameraInfo::mutable_d(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.D)
  return d_.Mutable(index);
}
::choreo::Float64* CameraInfo::add_d() {
  // @@protoc_insertion_point(field_add:choreo.CameraInfo.D)
  return d_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
CameraInfo::mutable_d() {
  // @@protoc_insertion_point(field_mutable_list:choreo.CameraInfo.D)
  return &d_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
CameraInfo::d() const {
  // @@protoc_insertion_point(field_list:choreo.CameraInfo.D)
  return d_;
}

// repeated .choreo.Float64 K = 6;
int CameraInfo::k_size() const {
  return k_.size();
}
void CameraInfo::clear_k() {
  k_.Clear();
}
const ::choreo::Float64& CameraInfo::k(int index) const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.K)
  return k_.Get(index);
}
::choreo::Float64* CameraInfo::mutable_k(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.K)
  return k_.Mutable(index);
}
::choreo::Float64* CameraInfo::add_k() {
  // @@protoc_insertion_point(field_add:choreo.CameraInfo.K)
  return k_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
CameraInfo::mutable_k() {
  // @@protoc_insertion_point(field_mutable_list:choreo.CameraInfo.K)
  return &k_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
CameraInfo::k() const {
  // @@protoc_insertion_point(field_list:choreo.CameraInfo.K)
  return k_;
}

// repeated .choreo.Float64 P = 7;
int CameraInfo::p_size() const {
  return p_.size();
}
void CameraInfo::clear_p() {
  p_.Clear();
}
const ::choreo::Float64& CameraInfo::p(int index) const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.P)
  return p_.Get(index);
}
::choreo::Float64* CameraInfo::mutable_p(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.P)
  return p_.Mutable(index);
}
::choreo::Float64* CameraInfo::add_p() {
  // @@protoc_insertion_point(field_add:choreo.CameraInfo.P)
  return p_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
CameraInfo::mutable_p() {
  // @@protoc_insertion_point(field_mutable_list:choreo.CameraInfo.P)
  return &p_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
CameraInfo::p() const {
  // @@protoc_insertion_point(field_list:choreo.CameraInfo.P)
  return p_;
}

// .choreo.UInt32 binning_x = 8;
bool CameraInfo::has_binning_x() const {
  return this != internal_default_instance() && binning_x_ != NULL;
}
void CameraInfo::clear_binning_x() {
  if (GetArenaNoVirtual() == NULL && binning_x_ != NULL) delete binning_x_;
  binning_x_ = NULL;
}
const ::choreo::UInt32& CameraInfo::binning_x() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.binning_x)
  return binning_x_ != NULL ? *binning_x_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* CameraInfo::mutable_binning_x() {
  
  if (binning_x_ == NULL) {
    binning_x_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.binning_x)
  return binning_x_;
}
::choreo::UInt32* CameraInfo::release_binning_x() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.binning_x)
  
  ::choreo::UInt32* temp = binning_x_;
  binning_x_ = NULL;
  return temp;
}
void CameraInfo::set_allocated_binning_x(::choreo::UInt32* binning_x) {
  delete binning_x_;
  binning_x_ = binning_x;
  if (binning_x) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.binning_x)
}

// .choreo.UInt32 binning_y = 9;
bool CameraInfo::has_binning_y() const {
  return this != internal_default_instance() && binning_y_ != NULL;
}
void CameraInfo::clear_binning_y() {
  if (GetArenaNoVirtual() == NULL && binning_y_ != NULL) delete binning_y_;
  binning_y_ = NULL;
}
const ::choreo::UInt32& CameraInfo::binning_y() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.binning_y)
  return binning_y_ != NULL ? *binning_y_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* CameraInfo::mutable_binning_y() {
  
  if (binning_y_ == NULL) {
    binning_y_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.binning_y)
  return binning_y_;
}
::choreo::UInt32* CameraInfo::release_binning_y() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.binning_y)
  
  ::choreo::UInt32* temp = binning_y_;
  binning_y_ = NULL;
  return temp;
}
void CameraInfo::set_allocated_binning_y(::choreo::UInt32* binning_y) {
  delete binning_y_;
  binning_y_ = binning_y;
  if (binning_y) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.binning_y)
}

// .choreo.RegionOfInterest roi = 10;
bool CameraInfo::has_roi() const {
  return this != internal_default_instance() && roi_ != NULL;
}
void CameraInfo::clear_roi() {
  if (GetArenaNoVirtual() == NULL && roi_ != NULL) delete roi_;
  roi_ = NULL;
}
const ::choreo::RegionOfInterest& CameraInfo::roi() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.roi)
  return roi_ != NULL ? *roi_
                         : *::choreo::RegionOfInterest::internal_default_instance();
}
::choreo::RegionOfInterest* CameraInfo::mutable_roi() {
  
  if (roi_ == NULL) {
    roi_ = new ::choreo::RegionOfInterest;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.roi)
  return roi_;
}
::choreo::RegionOfInterest* CameraInfo::release_roi() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.roi)
  
  ::choreo::RegionOfInterest* temp = roi_;
  roi_ = NULL;
  return temp;
}
void CameraInfo::set_allocated_roi(::choreo::RegionOfInterest* roi) {
  delete roi_;
  roi_ = roi;
  if (roi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.roi)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ChannelFloat32::kNameFieldNumber;
const int ChannelFloat32::kValuesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ChannelFloat32::ChannelFloat32()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_sensor_2fcamera_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.ChannelFloat32)
}
ChannelFloat32::ChannelFloat32(const ChannelFloat32& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      values_(from.values_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_name()) {
    name_ = new ::choreo::String(*from.name_);
  } else {
    name_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.ChannelFloat32)
}

void ChannelFloat32::SharedCtor() {
  name_ = NULL;
  _cached_size_ = 0;
}

ChannelFloat32::~ChannelFloat32() {
  // @@protoc_insertion_point(destructor:choreo.ChannelFloat32)
  SharedDtor();
}

void ChannelFloat32::SharedDtor() {
  if (this != internal_default_instance()) {
    delete name_;
  }
}

void ChannelFloat32::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChannelFloat32::descriptor() {
  protobuf_sensor_2fcamera_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fcamera_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ChannelFloat32& ChannelFloat32::default_instance() {
  protobuf_sensor_2fcamera_2eproto::InitDefaults();
  return *internal_default_instance();
}

ChannelFloat32* ChannelFloat32::New(::google::protobuf::Arena* arena) const {
  ChannelFloat32* n = new ChannelFloat32;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ChannelFloat32::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.ChannelFloat32)
  values_.Clear();
  if (GetArenaNoVirtual() == NULL && name_ != NULL) {
    delete name_;
  }
  name_ = NULL;
}

bool ChannelFloat32::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.ChannelFloat32)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.String name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.Float32 values = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_values()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.ChannelFloat32)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.ChannelFloat32)
  return false;
#undef DO_
}

void ChannelFloat32::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.ChannelFloat32)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.String name = 1;
  if (this->has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->name_, output);
  }

  // repeated .choreo.Float32 values = 2;
  for (unsigned int i = 0, n = this->values_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->values(i), output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.ChannelFloat32)
}

::google::protobuf::uint8* ChannelFloat32::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.ChannelFloat32)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.String name = 1;
  if (this->has_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->name_, deterministic, target);
  }

  // repeated .choreo.Float32 values = 2;
  for (unsigned int i = 0, n = this->values_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->values(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.ChannelFloat32)
  return target;
}

size_t ChannelFloat32::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.ChannelFloat32)
  size_t total_size = 0;

  // repeated .choreo.Float32 values = 2;
  {
    unsigned int count = this->values_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->values(i));
    }
  }

  // .choreo.String name = 1;
  if (this->has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->name_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChannelFloat32::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.ChannelFloat32)
  GOOGLE_DCHECK_NE(&from, this);
  const ChannelFloat32* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ChannelFloat32>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.ChannelFloat32)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.ChannelFloat32)
    MergeFrom(*source);
  }
}

void ChannelFloat32::MergeFrom(const ChannelFloat32& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.ChannelFloat32)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  if (from.has_name()) {
    mutable_name()->::choreo::String::MergeFrom(from.name());
  }
}

void ChannelFloat32::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.ChannelFloat32)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChannelFloat32::CopyFrom(const ChannelFloat32& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.ChannelFloat32)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChannelFloat32::IsInitialized() const {
  return true;
}

void ChannelFloat32::Swap(ChannelFloat32* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ChannelFloat32::InternalSwap(ChannelFloat32* other) {
  values_.InternalSwap(&other->values_);
  std::swap(name_, other->name_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ChannelFloat32::GetMetadata() const {
  protobuf_sensor_2fcamera_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fcamera_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ChannelFloat32

// .choreo.String name = 1;
bool ChannelFloat32::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
void ChannelFloat32::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) delete name_;
  name_ = NULL;
}
const ::choreo::String& ChannelFloat32::name() const {
  // @@protoc_insertion_point(field_get:choreo.ChannelFloat32.name)
  return name_ != NULL ? *name_
                         : *::choreo::String::internal_default_instance();
}
::choreo::String* ChannelFloat32::mutable_name() {
  
  if (name_ == NULL) {
    name_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ChannelFloat32.name)
  return name_;
}
::choreo::String* ChannelFloat32::release_name() {
  // @@protoc_insertion_point(field_release:choreo.ChannelFloat32.name)
  
  ::choreo::String* temp = name_;
  name_ = NULL;
  return temp;
}
void ChannelFloat32::set_allocated_name(::choreo::String* name) {
  delete name_;
  name_ = name;
  if (name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ChannelFloat32.name)
}

// repeated .choreo.Float32 values = 2;
int ChannelFloat32::values_size() const {
  return values_.size();
}
void ChannelFloat32::clear_values() {
  values_.Clear();
}
const ::choreo::Float32& ChannelFloat32::values(int index) const {
  // @@protoc_insertion_point(field_get:choreo.ChannelFloat32.values)
  return values_.Get(index);
}
::choreo::Float32* ChannelFloat32::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.ChannelFloat32.values)
  return values_.Mutable(index);
}
::choreo::Float32* ChannelFloat32::add_values() {
  // @@protoc_insertion_point(field_add:choreo.ChannelFloat32.values)
  return values_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::Float32 >*
ChannelFloat32::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:choreo.ChannelFloat32.values)
  return &values_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >&
ChannelFloat32::values() const {
  // @@protoc_insertion_point(field_list:choreo.ChannelFloat32.values)
  return values_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CompressedImage::kHeaderFieldNumber;
const int CompressedImage::kFormatFieldNumber;
const int CompressedImage::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CompressedImage::CompressedImage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_sensor_2fcamera_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.CompressedImage)
}
CompressedImage::CompressedImage(const CompressedImage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      data_(from.data_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_format()) {
    format_ = new ::choreo::String(*from.format_);
  } else {
    format_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.CompressedImage)
}

void CompressedImage::SharedCtor() {
  ::memset(&header_, 0, reinterpret_cast<char*>(&format_) -
    reinterpret_cast<char*>(&header_) + sizeof(format_));
  _cached_size_ = 0;
}

CompressedImage::~CompressedImage() {
  // @@protoc_insertion_point(destructor:choreo.CompressedImage)
  SharedDtor();
}

void CompressedImage::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete format_;
  }
}

void CompressedImage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CompressedImage::descriptor() {
  protobuf_sensor_2fcamera_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fcamera_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CompressedImage& CompressedImage::default_instance() {
  protobuf_sensor_2fcamera_2eproto::InitDefaults();
  return *internal_default_instance();
}

CompressedImage* CompressedImage::New(::google::protobuf::Arena* arena) const {
  CompressedImage* n = new CompressedImage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CompressedImage::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.CompressedImage)
  data_.Clear();
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && format_ != NULL) {
    delete format_;
  }
  format_ = NULL;
}

bool CompressedImage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.CompressedImage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.String format = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_format()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.UInt32 data = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.CompressedImage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.CompressedImage)
  return false;
#undef DO_
}

void CompressedImage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.CompressedImage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .choreo.String format = 2;
  if (this->has_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->format_, output);
  }

  // repeated .choreo.UInt32 data = 3;
  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->data(i), output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.CompressedImage)
}

::google::protobuf::uint8* CompressedImage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.CompressedImage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // .choreo.String format = 2;
  if (this->has_format()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->format_, deterministic, target);
  }

  // repeated .choreo.UInt32 data = 3;
  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->data(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.CompressedImage)
  return target;
}

size_t CompressedImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.CompressedImage)
  size_t total_size = 0;

  // repeated .choreo.UInt32 data = 3;
  {
    unsigned int count = this->data_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data(i));
    }
  }

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // .choreo.String format = 2;
  if (this->has_format()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->format_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CompressedImage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.CompressedImage)
  GOOGLE_DCHECK_NE(&from, this);
  const CompressedImage* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CompressedImage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.CompressedImage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.CompressedImage)
    MergeFrom(*source);
  }
}

void CompressedImage::MergeFrom(const CompressedImage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.CompressedImage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
  if (from.has_format()) {
    mutable_format()->::choreo::String::MergeFrom(from.format());
  }
}

void CompressedImage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.CompressedImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CompressedImage::CopyFrom(const CompressedImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.CompressedImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompressedImage::IsInitialized() const {
  return true;
}

void CompressedImage::Swap(CompressedImage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CompressedImage::InternalSwap(CompressedImage* other) {
  data_.InternalSwap(&other->data_);
  std::swap(header_, other->header_);
  std::swap(format_, other->format_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CompressedImage::GetMetadata() const {
  protobuf_sensor_2fcamera_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fcamera_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CompressedImage

// .choreo.Header header = 1;
bool CompressedImage::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void CompressedImage::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& CompressedImage::header() const {
  // @@protoc_insertion_point(field_get:choreo.CompressedImage.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* CompressedImage::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CompressedImage.header)
  return header_;
}
::choreo::Header* CompressedImage::release_header() {
  // @@protoc_insertion_point(field_release:choreo.CompressedImage.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void CompressedImage::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CompressedImage.header)
}

// .choreo.String format = 2;
bool CompressedImage::has_format() const {
  return this != internal_default_instance() && format_ != NULL;
}
void CompressedImage::clear_format() {
  if (GetArenaNoVirtual() == NULL && format_ != NULL) delete format_;
  format_ = NULL;
}
const ::choreo::String& CompressedImage::format() const {
  // @@protoc_insertion_point(field_get:choreo.CompressedImage.format)
  return format_ != NULL ? *format_
                         : *::choreo::String::internal_default_instance();
}
::choreo::String* CompressedImage::mutable_format() {
  
  if (format_ == NULL) {
    format_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CompressedImage.format)
  return format_;
}
::choreo::String* CompressedImage::release_format() {
  // @@protoc_insertion_point(field_release:choreo.CompressedImage.format)
  
  ::choreo::String* temp = format_;
  format_ = NULL;
  return temp;
}
void CompressedImage::set_allocated_format(::choreo::String* format) {
  delete format_;
  format_ = format;
  if (format) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CompressedImage.format)
}

// repeated .choreo.UInt32 data = 3;
int CompressedImage::data_size() const {
  return data_.size();
}
void CompressedImage::clear_data() {
  data_.Clear();
}
const ::choreo::UInt32& CompressedImage::data(int index) const {
  // @@protoc_insertion_point(field_get:choreo.CompressedImage.data)
  return data_.Get(index);
}
::choreo::UInt32* CompressedImage::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.CompressedImage.data)
  return data_.Mutable(index);
}
::choreo::UInt32* CompressedImage::add_data() {
  // @@protoc_insertion_point(field_add:choreo.CompressedImage.data)
  return data_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::UInt32 >*
CompressedImage::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:choreo.CompressedImage.data)
  return &data_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::UInt32 >&
CompressedImage::data() const {
  // @@protoc_insertion_point(field_list:choreo.CompressedImage.data)
  return data_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Image::kHeaderFieldNumber;
const int Image::kHeightFieldNumber;
const int Image::kWidthFieldNumber;
const int Image::kEncodingFieldNumber;
const int Image::kIsBigendianFieldNumber;
const int Image::kStepFieldNumber;
const int Image::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Image::Image()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_sensor_2fcamera_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.Image)
}
Image::Image(const Image& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      data_(from.data_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_height()) {
    height_ = new ::choreo::UInt32(*from.height_);
  } else {
    height_ = NULL;
  }
  if (from.has_width()) {
    width_ = new ::choreo::UInt32(*from.width_);
  } else {
    width_ = NULL;
  }
  if (from.has_encoding()) {
    encoding_ = new ::choreo::String(*from.encoding_);
  } else {
    encoding_ = NULL;
  }
  if (from.has_is_bigendian()) {
    is_bigendian_ = new ::choreo::Bool(*from.is_bigendian_);
  } else {
    is_bigendian_ = NULL;
  }
  if (from.has_step()) {
    step_ = new ::choreo::UInt32(*from.step_);
  } else {
    step_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.Image)
}

void Image::SharedCtor() {
  ::memset(&header_, 0, reinterpret_cast<char*>(&step_) -
    reinterpret_cast<char*>(&header_) + sizeof(step_));
  _cached_size_ = 0;
}

Image::~Image() {
  // @@protoc_insertion_point(destructor:choreo.Image)
  SharedDtor();
}

void Image::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete height_;
  }
  if (this != internal_default_instance()) {
    delete width_;
  }
  if (this != internal_default_instance()) {
    delete encoding_;
  }
  if (this != internal_default_instance()) {
    delete is_bigendian_;
  }
  if (this != internal_default_instance()) {
    delete step_;
  }
}

void Image::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Image::descriptor() {
  protobuf_sensor_2fcamera_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fcamera_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Image& Image::default_instance() {
  protobuf_sensor_2fcamera_2eproto::InitDefaults();
  return *internal_default_instance();
}

Image* Image::New(::google::protobuf::Arena* arena) const {
  Image* n = new Image;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Image::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.Image)
  data_.Clear();
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && height_ != NULL) {
    delete height_;
  }
  height_ = NULL;
  if (GetArenaNoVirtual() == NULL && width_ != NULL) {
    delete width_;
  }
  width_ = NULL;
  if (GetArenaNoVirtual() == NULL && encoding_ != NULL) {
    delete encoding_;
  }
  encoding_ = NULL;
  if (GetArenaNoVirtual() == NULL && is_bigendian_ != NULL) {
    delete is_bigendian_;
  }
  is_bigendian_ = NULL;
  if (GetArenaNoVirtual() == NULL && step_ != NULL) {
    delete step_;
  }
  step_ = NULL;
}

bool Image::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.Image)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 height = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_height()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 width = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_width()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.String encoding = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_encoding()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Bool is_bigendian = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_is_bigendian()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 step = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_step()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.UInt32 data = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.Image)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.Image)
  return false;
#undef DO_
}

void Image::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.Image)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .choreo.UInt32 height = 2;
  if (this->has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->height_, output);
  }

  // .choreo.UInt32 width = 3;
  if (this->has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->width_, output);
  }

  // .choreo.String encoding = 4;
  if (this->has_encoding()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->encoding_, output);
  }

  // .choreo.Bool is_bigendian = 5;
  if (this->has_is_bigendian()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->is_bigendian_, output);
  }

  // .choreo.UInt32 step = 6;
  if (this->has_step()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->step_, output);
  }

  // repeated .choreo.UInt32 data = 7;
  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->data(i), output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.Image)
}

::google::protobuf::uint8* Image::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.Image)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // .choreo.UInt32 height = 2;
  if (this->has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->height_, deterministic, target);
  }

  // .choreo.UInt32 width = 3;
  if (this->has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->width_, deterministic, target);
  }

  // .choreo.String encoding = 4;
  if (this->has_encoding()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->encoding_, deterministic, target);
  }

  // .choreo.Bool is_bigendian = 5;
  if (this->has_is_bigendian()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->is_bigendian_, deterministic, target);
  }

  // .choreo.UInt32 step = 6;
  if (this->has_step()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->step_, deterministic, target);
  }

  // repeated .choreo.UInt32 data = 7;
  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, this->data(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.Image)
  return target;
}

size_t Image::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.Image)
  size_t total_size = 0;

  // repeated .choreo.UInt32 data = 7;
  {
    unsigned int count = this->data_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data(i));
    }
  }

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // .choreo.UInt32 height = 2;
  if (this->has_height()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->height_);
  }

  // .choreo.UInt32 width = 3;
  if (this->has_width()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->width_);
  }

  // .choreo.String encoding = 4;
  if (this->has_encoding()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->encoding_);
  }

  // .choreo.Bool is_bigendian = 5;
  if (this->has_is_bigendian()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->is_bigendian_);
  }

  // .choreo.UInt32 step = 6;
  if (this->has_step()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->step_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.Image)
  GOOGLE_DCHECK_NE(&from, this);
  const Image* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Image>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.Image)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.Image)
    MergeFrom(*source);
  }
}

void Image::MergeFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.Image)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
  if (from.has_height()) {
    mutable_height()->::choreo::UInt32::MergeFrom(from.height());
  }
  if (from.has_width()) {
    mutable_width()->::choreo::UInt32::MergeFrom(from.width());
  }
  if (from.has_encoding()) {
    mutable_encoding()->::choreo::String::MergeFrom(from.encoding());
  }
  if (from.has_is_bigendian()) {
    mutable_is_bigendian()->::choreo::Bool::MergeFrom(from.is_bigendian());
  }
  if (from.has_step()) {
    mutable_step()->::choreo::UInt32::MergeFrom(from.step());
  }
}

void Image::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image::CopyFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {
  return true;
}

void Image::Swap(Image* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Image::InternalSwap(Image* other) {
  data_.InternalSwap(&other->data_);
  std::swap(header_, other->header_);
  std::swap(height_, other->height_);
  std::swap(width_, other->width_);
  std::swap(encoding_, other->encoding_);
  std::swap(is_bigendian_, other->is_bigendian_);
  std::swap(step_, other->step_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Image::GetMetadata() const {
  protobuf_sensor_2fcamera_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fcamera_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Image

// .choreo.Header header = 1;
bool Image::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void Image::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& Image::header() const {
  // @@protoc_insertion_point(field_get:choreo.Image.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* Image::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Image.header)
  return header_;
}
::choreo::Header* Image::release_header() {
  // @@protoc_insertion_point(field_release:choreo.Image.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void Image::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Image.header)
}

// .choreo.UInt32 height = 2;
bool Image::has_height() const {
  return this != internal_default_instance() && height_ != NULL;
}
void Image::clear_height() {
  if (GetArenaNoVirtual() == NULL && height_ != NULL) delete height_;
  height_ = NULL;
}
const ::choreo::UInt32& Image::height() const {
  // @@protoc_insertion_point(field_get:choreo.Image.height)
  return height_ != NULL ? *height_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* Image::mutable_height() {
  
  if (height_ == NULL) {
    height_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Image.height)
  return height_;
}
::choreo::UInt32* Image::release_height() {
  // @@protoc_insertion_point(field_release:choreo.Image.height)
  
  ::choreo::UInt32* temp = height_;
  height_ = NULL;
  return temp;
}
void Image::set_allocated_height(::choreo::UInt32* height) {
  delete height_;
  height_ = height;
  if (height) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Image.height)
}

// .choreo.UInt32 width = 3;
bool Image::has_width() const {
  return this != internal_default_instance() && width_ != NULL;
}
void Image::clear_width() {
  if (GetArenaNoVirtual() == NULL && width_ != NULL) delete width_;
  width_ = NULL;
}
const ::choreo::UInt32& Image::width() const {
  // @@protoc_insertion_point(field_get:choreo.Image.width)
  return width_ != NULL ? *width_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* Image::mutable_width() {
  
  if (width_ == NULL) {
    width_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Image.width)
  return width_;
}
::choreo::UInt32* Image::release_width() {
  // @@protoc_insertion_point(field_release:choreo.Image.width)
  
  ::choreo::UInt32* temp = width_;
  width_ = NULL;
  return temp;
}
void Image::set_allocated_width(::choreo::UInt32* width) {
  delete width_;
  width_ = width;
  if (width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Image.width)
}

// .choreo.String encoding = 4;
bool Image::has_encoding() const {
  return this != internal_default_instance() && encoding_ != NULL;
}
void Image::clear_encoding() {
  if (GetArenaNoVirtual() == NULL && encoding_ != NULL) delete encoding_;
  encoding_ = NULL;
}
const ::choreo::String& Image::encoding() const {
  // @@protoc_insertion_point(field_get:choreo.Image.encoding)
  return encoding_ != NULL ? *encoding_
                         : *::choreo::String::internal_default_instance();
}
::choreo::String* Image::mutable_encoding() {
  
  if (encoding_ == NULL) {
    encoding_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Image.encoding)
  return encoding_;
}
::choreo::String* Image::release_encoding() {
  // @@protoc_insertion_point(field_release:choreo.Image.encoding)
  
  ::choreo::String* temp = encoding_;
  encoding_ = NULL;
  return temp;
}
void Image::set_allocated_encoding(::choreo::String* encoding) {
  delete encoding_;
  encoding_ = encoding;
  if (encoding) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Image.encoding)
}

// .choreo.Bool is_bigendian = 5;
bool Image::has_is_bigendian() const {
  return this != internal_default_instance() && is_bigendian_ != NULL;
}
void Image::clear_is_bigendian() {
  if (GetArenaNoVirtual() == NULL && is_bigendian_ != NULL) delete is_bigendian_;
  is_bigendian_ = NULL;
}
const ::choreo::Bool& Image::is_bigendian() const {
  // @@protoc_insertion_point(field_get:choreo.Image.is_bigendian)
  return is_bigendian_ != NULL ? *is_bigendian_
                         : *::choreo::Bool::internal_default_instance();
}
::choreo::Bool* Image::mutable_is_bigendian() {
  
  if (is_bigendian_ == NULL) {
    is_bigendian_ = new ::choreo::Bool;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Image.is_bigendian)
  return is_bigendian_;
}
::choreo::Bool* Image::release_is_bigendian() {
  // @@protoc_insertion_point(field_release:choreo.Image.is_bigendian)
  
  ::choreo::Bool* temp = is_bigendian_;
  is_bigendian_ = NULL;
  return temp;
}
void Image::set_allocated_is_bigendian(::choreo::Bool* is_bigendian) {
  delete is_bigendian_;
  is_bigendian_ = is_bigendian;
  if (is_bigendian) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Image.is_bigendian)
}

// .choreo.UInt32 step = 6;
bool Image::has_step() const {
  return this != internal_default_instance() && step_ != NULL;
}
void Image::clear_step() {
  if (GetArenaNoVirtual() == NULL && step_ != NULL) delete step_;
  step_ = NULL;
}
const ::choreo::UInt32& Image::step() const {
  // @@protoc_insertion_point(field_get:choreo.Image.step)
  return step_ != NULL ? *step_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* Image::mutable_step() {
  
  if (step_ == NULL) {
    step_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Image.step)
  return step_;
}
::choreo::UInt32* Image::release_step() {
  // @@protoc_insertion_point(field_release:choreo.Image.step)
  
  ::choreo::UInt32* temp = step_;
  step_ = NULL;
  return temp;
}
void Image::set_allocated_step(::choreo::UInt32* step) {
  delete step_;
  step_ = step;
  if (step) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Image.step)
}

// repeated .choreo.UInt32 data = 7;
int Image::data_size() const {
  return data_.size();
}
void Image::clear_data() {
  data_.Clear();
}
const ::choreo::UInt32& Image::data(int index) const {
  // @@protoc_insertion_point(field_get:choreo.Image.data)
  return data_.Get(index);
}
::choreo::UInt32* Image::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.Image.data)
  return data_.Mutable(index);
}
::choreo::UInt32* Image::add_data() {
  // @@protoc_insertion_point(field_add:choreo.Image.data)
  return data_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::UInt32 >*
Image::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:choreo.Image.data)
  return &data_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::UInt32 >&
Image::data() const {
  // @@protoc_insertion_point(field_list:choreo.Image.data)
  return data_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ColorRGBA::kRFieldNumber;
const int ColorRGBA::kGFieldNumber;
const int ColorRGBA::kBFieldNumber;
const int ColorRGBA::kAFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ColorRGBA::ColorRGBA()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_sensor_2fcamera_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.ColorRGBA)
}
ColorRGBA::ColorRGBA(const ColorRGBA& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_r()) {
    r_ = new ::choreo::Float32(*from.r_);
  } else {
    r_ = NULL;
  }
  if (from.has_g()) {
    g_ = new ::choreo::Float32(*from.g_);
  } else {
    g_ = NULL;
  }
  if (from.has_b()) {
    b_ = new ::choreo::Float32(*from.b_);
  } else {
    b_ = NULL;
  }
  if (from.has_a()) {
    a_ = new ::choreo::Float32(*from.a_);
  } else {
    a_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.ColorRGBA)
}

void ColorRGBA::SharedCtor() {
  ::memset(&r_, 0, reinterpret_cast<char*>(&a_) -
    reinterpret_cast<char*>(&r_) + sizeof(a_));
  _cached_size_ = 0;
}

ColorRGBA::~ColorRGBA() {
  // @@protoc_insertion_point(destructor:choreo.ColorRGBA)
  SharedDtor();
}

void ColorRGBA::SharedDtor() {
  if (this != internal_default_instance()) {
    delete r_;
  }
  if (this != internal_default_instance()) {
    delete g_;
  }
  if (this != internal_default_instance()) {
    delete b_;
  }
  if (this != internal_default_instance()) {
    delete a_;
  }
}

void ColorRGBA::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ColorRGBA::descriptor() {
  protobuf_sensor_2fcamera_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fcamera_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ColorRGBA& ColorRGBA::default_instance() {
  protobuf_sensor_2fcamera_2eproto::InitDefaults();
  return *internal_default_instance();
}

ColorRGBA* ColorRGBA::New(::google::protobuf::Arena* arena) const {
  ColorRGBA* n = new ColorRGBA;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ColorRGBA::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.ColorRGBA)
  if (GetArenaNoVirtual() == NULL && r_ != NULL) {
    delete r_;
  }
  r_ = NULL;
  if (GetArenaNoVirtual() == NULL && g_ != NULL) {
    delete g_;
  }
  g_ = NULL;
  if (GetArenaNoVirtual() == NULL && b_ != NULL) {
    delete b_;
  }
  b_ = NULL;
  if (GetArenaNoVirtual() == NULL && a_ != NULL) {
    delete a_;
  }
  a_ = NULL;
}

bool ColorRGBA::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.ColorRGBA)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Float32 r = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_r()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 g = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_g()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 b = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_b()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 a = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_a()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.ColorRGBA)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.ColorRGBA)
  return false;
#undef DO_
}

void ColorRGBA::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.ColorRGBA)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Float32 r = 1;
  if (this->has_r()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->r_, output);
  }

  // .choreo.Float32 g = 2;
  if (this->has_g()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->g_, output);
  }

  // .choreo.Float32 b = 3;
  if (this->has_b()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->b_, output);
  }

  // .choreo.Float32 a = 4;
  if (this->has_a()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->a_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.ColorRGBA)
}

::google::protobuf::uint8* ColorRGBA::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.ColorRGBA)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Float32 r = 1;
  if (this->has_r()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->r_, deterministic, target);
  }

  // .choreo.Float32 g = 2;
  if (this->has_g()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->g_, deterministic, target);
  }

  // .choreo.Float32 b = 3;
  if (this->has_b()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->b_, deterministic, target);
  }

  // .choreo.Float32 a = 4;
  if (this->has_a()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->a_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.ColorRGBA)
  return target;
}

size_t ColorRGBA::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.ColorRGBA)
  size_t total_size = 0;

  // .choreo.Float32 r = 1;
  if (this->has_r()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->r_);
  }

  // .choreo.Float32 g = 2;
  if (this->has_g()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->g_);
  }

  // .choreo.Float32 b = 3;
  if (this->has_b()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->b_);
  }

  // .choreo.Float32 a = 4;
  if (this->has_a()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->a_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ColorRGBA::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.ColorRGBA)
  GOOGLE_DCHECK_NE(&from, this);
  const ColorRGBA* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ColorRGBA>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.ColorRGBA)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.ColorRGBA)
    MergeFrom(*source);
  }
}

void ColorRGBA::MergeFrom(const ColorRGBA& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.ColorRGBA)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_r()) {
    mutable_r()->::choreo::Float32::MergeFrom(from.r());
  }
  if (from.has_g()) {
    mutable_g()->::choreo::Float32::MergeFrom(from.g());
  }
  if (from.has_b()) {
    mutable_b()->::choreo::Float32::MergeFrom(from.b());
  }
  if (from.has_a()) {
    mutable_a()->::choreo::Float32::MergeFrom(from.a());
  }
}

void ColorRGBA::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.ColorRGBA)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ColorRGBA::CopyFrom(const ColorRGBA& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.ColorRGBA)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColorRGBA::IsInitialized() const {
  return true;
}

void ColorRGBA::Swap(ColorRGBA* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ColorRGBA::InternalSwap(ColorRGBA* other) {
  std::swap(r_, other->r_);
  std::swap(g_, other->g_);
  std::swap(b_, other->b_);
  std::swap(a_, other->a_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ColorRGBA::GetMetadata() const {
  protobuf_sensor_2fcamera_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fcamera_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ColorRGBA

// .choreo.Float32 r = 1;
bool ColorRGBA::has_r() const {
  return this != internal_default_instance() && r_ != NULL;
}
void ColorRGBA::clear_r() {
  if (GetArenaNoVirtual() == NULL && r_ != NULL) delete r_;
  r_ = NULL;
}
const ::choreo::Float32& ColorRGBA::r() const {
  // @@protoc_insertion_point(field_get:choreo.ColorRGBA.r)
  return r_ != NULL ? *r_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* ColorRGBA::mutable_r() {
  
  if (r_ == NULL) {
    r_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ColorRGBA.r)
  return r_;
}
::choreo::Float32* ColorRGBA::release_r() {
  // @@protoc_insertion_point(field_release:choreo.ColorRGBA.r)
  
  ::choreo::Float32* temp = r_;
  r_ = NULL;
  return temp;
}
void ColorRGBA::set_allocated_r(::choreo::Float32* r) {
  delete r_;
  r_ = r;
  if (r) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ColorRGBA.r)
}

// .choreo.Float32 g = 2;
bool ColorRGBA::has_g() const {
  return this != internal_default_instance() && g_ != NULL;
}
void ColorRGBA::clear_g() {
  if (GetArenaNoVirtual() == NULL && g_ != NULL) delete g_;
  g_ = NULL;
}
const ::choreo::Float32& ColorRGBA::g() const {
  // @@protoc_insertion_point(field_get:choreo.ColorRGBA.g)
  return g_ != NULL ? *g_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* ColorRGBA::mutable_g() {
  
  if (g_ == NULL) {
    g_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ColorRGBA.g)
  return g_;
}
::choreo::Float32* ColorRGBA::release_g() {
  // @@protoc_insertion_point(field_release:choreo.ColorRGBA.g)
  
  ::choreo::Float32* temp = g_;
  g_ = NULL;
  return temp;
}
void ColorRGBA::set_allocated_g(::choreo::Float32* g) {
  delete g_;
  g_ = g;
  if (g) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ColorRGBA.g)
}

// .choreo.Float32 b = 3;
bool ColorRGBA::has_b() const {
  return this != internal_default_instance() && b_ != NULL;
}
void ColorRGBA::clear_b() {
  if (GetArenaNoVirtual() == NULL && b_ != NULL) delete b_;
  b_ = NULL;
}
const ::choreo::Float32& ColorRGBA::b() const {
  // @@protoc_insertion_point(field_get:choreo.ColorRGBA.b)
  return b_ != NULL ? *b_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* ColorRGBA::mutable_b() {
  
  if (b_ == NULL) {
    b_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ColorRGBA.b)
  return b_;
}
::choreo::Float32* ColorRGBA::release_b() {
  // @@protoc_insertion_point(field_release:choreo.ColorRGBA.b)
  
  ::choreo::Float32* temp = b_;
  b_ = NULL;
  return temp;
}
void ColorRGBA::set_allocated_b(::choreo::Float32* b) {
  delete b_;
  b_ = b;
  if (b) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ColorRGBA.b)
}

// .choreo.Float32 a = 4;
bool ColorRGBA::has_a() const {
  return this != internal_default_instance() && a_ != NULL;
}
void ColorRGBA::clear_a() {
  if (GetArenaNoVirtual() == NULL && a_ != NULL) delete a_;
  a_ = NULL;
}
const ::choreo::Float32& ColorRGBA::a() const {
  // @@protoc_insertion_point(field_get:choreo.ColorRGBA.a)
  return a_ != NULL ? *a_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* ColorRGBA::mutable_a() {
  
  if (a_ == NULL) {
    a_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ColorRGBA.a)
  return a_;
}
::choreo::Float32* ColorRGBA::release_a() {
  // @@protoc_insertion_point(field_release:choreo.ColorRGBA.a)
  
  ::choreo::Float32* temp = a_;
  a_ = NULL;
  return temp;
}
void ColorRGBA::set_allocated_a(::choreo::Float32* a) {
  delete a_;
  a_ = a;
  if (a) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ColorRGBA.a)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace choreo

// @@protoc_insertion_point(global_scope)
