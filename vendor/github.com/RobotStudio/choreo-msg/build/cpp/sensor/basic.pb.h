// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor/basic.proto

#ifndef PROTOBUF_sensor_2fbasic_2eproto__INCLUDED
#define PROTOBUF_sensor_2fbasic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "primitive/float.pb.h"
#include "primitive/header.pb.h"
#include "primitive/string.pb.h"
// @@protoc_insertion_point(includes)
namespace choreo {
class Float;
class FloatDefaultTypeInternal;
extern FloatDefaultTypeInternal _Float_default_instance_;
class Float32;
class Float32DefaultTypeInternal;
extern Float32DefaultTypeInternal _Float32_default_instance_;
class Float32Array;
class Float32ArrayDefaultTypeInternal;
extern Float32ArrayDefaultTypeInternal _Float32Array_default_instance_;
class Float64;
class Float64DefaultTypeInternal;
extern Float64DefaultTypeInternal _Float64_default_instance_;
class Float64Array;
class Float64ArrayDefaultTypeInternal;
extern Float64ArrayDefaultTypeInternal _Float64Array_default_instance_;
class FloatArray;
class FloatArrayDefaultTypeInternal;
extern FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
class FluidPressure;
class FluidPressureDefaultTypeInternal;
extern FluidPressureDefaultTypeInternal _FluidPressure_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Humidity;
class HumidityDefaultTypeInternal;
extern HumidityDefaultTypeInternal _Humidity_default_instance_;
class Illuminance;
class IlluminanceDefaultTypeInternal;
extern IlluminanceDefaultTypeInternal _Illuminance_default_instance_;
class String;
class StringDefaultTypeInternal;
extern StringDefaultTypeInternal _String_default_instance_;
class Temperature;
class TemperatureDefaultTypeInternal;
extern TemperatureDefaultTypeInternal _Temperature_default_instance_;
class TimeReference;
class TimeReferenceDefaultTypeInternal;
extern TimeReferenceDefaultTypeInternal _TimeReference_default_instance_;
}  // namespace choreo
namespace google {
namespace protobuf {
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
}  // namespace protobuf
}  // namespace google

namespace choreo {

namespace protobuf_sensor_2fbasic_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_sensor_2fbasic_2eproto

// ===================================================================

class FluidPressure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.FluidPressure) */ {
 public:
  FluidPressure();
  virtual ~FluidPressure();

  FluidPressure(const FluidPressure& from);

  inline FluidPressure& operator=(const FluidPressure& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FluidPressure& default_instance();

  static inline const FluidPressure* internal_default_instance() {
    return reinterpret_cast<const FluidPressure*>(
               &_FluidPressure_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(FluidPressure* other);

  // implements Message ----------------------------------------------

  inline FluidPressure* New() const PROTOBUF_FINAL { return New(NULL); }

  FluidPressure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FluidPressure& from);
  void MergeFrom(const FluidPressure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FluidPressure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.Float64 fluid_pressure = 2;
  bool has_fluid_pressure() const;
  void clear_fluid_pressure();
  static const int kFluidPressureFieldNumber = 2;
  const ::choreo::Float64& fluid_pressure() const;
  ::choreo::Float64* mutable_fluid_pressure();
  ::choreo::Float64* release_fluid_pressure();
  void set_allocated_fluid_pressure(::choreo::Float64* fluid_pressure);

  // .choreo.Float64 variance = 3;
  bool has_variance() const;
  void clear_variance();
  static const int kVarianceFieldNumber = 3;
  const ::choreo::Float64& variance() const;
  ::choreo::Float64* mutable_variance();
  ::choreo::Float64* release_variance();
  void set_allocated_variance(::choreo::Float64* variance);

  // @@protoc_insertion_point(class_scope:choreo.FluidPressure)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::Header* header_;
  ::choreo::Float64* fluid_pressure_;
  ::choreo::Float64* variance_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fbasic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Illuminance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.Illuminance) */ {
 public:
  Illuminance();
  virtual ~Illuminance();

  Illuminance(const Illuminance& from);

  inline Illuminance& operator=(const Illuminance& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Illuminance& default_instance();

  static inline const Illuminance* internal_default_instance() {
    return reinterpret_cast<const Illuminance*>(
               &_Illuminance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Illuminance* other);

  // implements Message ----------------------------------------------

  inline Illuminance* New() const PROTOBUF_FINAL { return New(NULL); }

  Illuminance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Illuminance& from);
  void MergeFrom(const Illuminance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Illuminance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.Float64 illuminance = 2;
  bool has_illuminance() const;
  void clear_illuminance();
  static const int kIlluminanceFieldNumber = 2;
  const ::choreo::Float64& illuminance() const;
  ::choreo::Float64* mutable_illuminance();
  ::choreo::Float64* release_illuminance();
  void set_allocated_illuminance(::choreo::Float64* illuminance);

  // .choreo.Float64 variance = 3;
  bool has_variance() const;
  void clear_variance();
  static const int kVarianceFieldNumber = 3;
  const ::choreo::Float64& variance() const;
  ::choreo::Float64* mutable_variance();
  ::choreo::Float64* release_variance();
  void set_allocated_variance(::choreo::Float64* variance);

  // @@protoc_insertion_point(class_scope:choreo.Illuminance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::Header* header_;
  ::choreo::Float64* illuminance_;
  ::choreo::Float64* variance_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fbasic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Humidity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.Humidity) */ {
 public:
  Humidity();
  virtual ~Humidity();

  Humidity(const Humidity& from);

  inline Humidity& operator=(const Humidity& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Humidity& default_instance();

  static inline const Humidity* internal_default_instance() {
    return reinterpret_cast<const Humidity*>(
               &_Humidity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Humidity* other);

  // implements Message ----------------------------------------------

  inline Humidity* New() const PROTOBUF_FINAL { return New(NULL); }

  Humidity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Humidity& from);
  void MergeFrom(const Humidity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Humidity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.Float64 relative_humidity = 2;
  bool has_relative_humidity() const;
  void clear_relative_humidity();
  static const int kRelativeHumidityFieldNumber = 2;
  const ::choreo::Float64& relative_humidity() const;
  ::choreo::Float64* mutable_relative_humidity();
  ::choreo::Float64* release_relative_humidity();
  void set_allocated_relative_humidity(::choreo::Float64* relative_humidity);

  // .choreo.Float64 variance = 3;
  bool has_variance() const;
  void clear_variance();
  static const int kVarianceFieldNumber = 3;
  const ::choreo::Float64& variance() const;
  ::choreo::Float64* mutable_variance();
  ::choreo::Float64* release_variance();
  void set_allocated_variance(::choreo::Float64* variance);

  // @@protoc_insertion_point(class_scope:choreo.Humidity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::Header* header_;
  ::choreo::Float64* relative_humidity_;
  ::choreo::Float64* variance_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fbasic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Temperature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.Temperature) */ {
 public:
  Temperature();
  virtual ~Temperature();

  Temperature(const Temperature& from);

  inline Temperature& operator=(const Temperature& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Temperature& default_instance();

  static inline const Temperature* internal_default_instance() {
    return reinterpret_cast<const Temperature*>(
               &_Temperature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Temperature* other);

  // implements Message ----------------------------------------------

  inline Temperature* New() const PROTOBUF_FINAL { return New(NULL); }

  Temperature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Temperature& from);
  void MergeFrom(const Temperature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Temperature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.Float64 temperature = 2;
  bool has_temperature() const;
  void clear_temperature();
  static const int kTemperatureFieldNumber = 2;
  const ::choreo::Float64& temperature() const;
  ::choreo::Float64* mutable_temperature();
  ::choreo::Float64* release_temperature();
  void set_allocated_temperature(::choreo::Float64* temperature);

  // .choreo.Float64 variance = 3;
  bool has_variance() const;
  void clear_variance();
  static const int kVarianceFieldNumber = 3;
  const ::choreo::Float64& variance() const;
  ::choreo::Float64* mutable_variance();
  ::choreo::Float64* release_variance();
  void set_allocated_variance(::choreo::Float64* variance);

  // @@protoc_insertion_point(class_scope:choreo.Temperature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::Header* header_;
  ::choreo::Float64* temperature_;
  ::choreo::Float64* variance_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fbasic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TimeReference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.TimeReference) */ {
 public:
  TimeReference();
  virtual ~TimeReference();

  TimeReference(const TimeReference& from);

  inline TimeReference& operator=(const TimeReference& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeReference& default_instance();

  static inline const TimeReference* internal_default_instance() {
    return reinterpret_cast<const TimeReference*>(
               &_TimeReference_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(TimeReference* other);

  // implements Message ----------------------------------------------

  inline TimeReference* New() const PROTOBUF_FINAL { return New(NULL); }

  TimeReference* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimeReference& from);
  void MergeFrom(const TimeReference& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimeReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .google.protobuf.Timestamp time_ref = 2;
  bool has_time_ref() const;
  void clear_time_ref();
  static const int kTimeRefFieldNumber = 2;
  const ::google::protobuf::Timestamp& time_ref() const;
  ::google::protobuf::Timestamp* mutable_time_ref();
  ::google::protobuf::Timestamp* release_time_ref();
  void set_allocated_time_ref(::google::protobuf::Timestamp* time_ref);

  // .choreo.String source = 3;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 3;
  const ::choreo::String& source() const;
  ::choreo::String* mutable_source();
  ::choreo::String* release_source();
  void set_allocated_source(::choreo::String* source);

  // @@protoc_insertion_point(class_scope:choreo.TimeReference)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::Header* header_;
  ::google::protobuf::Timestamp* time_ref_;
  ::choreo::String* source_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fbasic_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// FluidPressure

// .choreo.Header header = 1;
inline bool FluidPressure::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void FluidPressure::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& FluidPressure::header() const {
  // @@protoc_insertion_point(field_get:choreo.FluidPressure.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* FluidPressure::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.FluidPressure.header)
  return header_;
}
inline ::choreo::Header* FluidPressure::release_header() {
  // @@protoc_insertion_point(field_release:choreo.FluidPressure.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void FluidPressure::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.FluidPressure.header)
}

// .choreo.Float64 fluid_pressure = 2;
inline bool FluidPressure::has_fluid_pressure() const {
  return this != internal_default_instance() && fluid_pressure_ != NULL;
}
inline void FluidPressure::clear_fluid_pressure() {
  if (GetArenaNoVirtual() == NULL && fluid_pressure_ != NULL) delete fluid_pressure_;
  fluid_pressure_ = NULL;
}
inline const ::choreo::Float64& FluidPressure::fluid_pressure() const {
  // @@protoc_insertion_point(field_get:choreo.FluidPressure.fluid_pressure)
  return fluid_pressure_ != NULL ? *fluid_pressure_
                         : *::choreo::Float64::internal_default_instance();
}
inline ::choreo::Float64* FluidPressure::mutable_fluid_pressure() {
  
  if (fluid_pressure_ == NULL) {
    fluid_pressure_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.FluidPressure.fluid_pressure)
  return fluid_pressure_;
}
inline ::choreo::Float64* FluidPressure::release_fluid_pressure() {
  // @@protoc_insertion_point(field_release:choreo.FluidPressure.fluid_pressure)
  
  ::choreo::Float64* temp = fluid_pressure_;
  fluid_pressure_ = NULL;
  return temp;
}
inline void FluidPressure::set_allocated_fluid_pressure(::choreo::Float64* fluid_pressure) {
  delete fluid_pressure_;
  fluid_pressure_ = fluid_pressure;
  if (fluid_pressure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.FluidPressure.fluid_pressure)
}

// .choreo.Float64 variance = 3;
inline bool FluidPressure::has_variance() const {
  return this != internal_default_instance() && variance_ != NULL;
}
inline void FluidPressure::clear_variance() {
  if (GetArenaNoVirtual() == NULL && variance_ != NULL) delete variance_;
  variance_ = NULL;
}
inline const ::choreo::Float64& FluidPressure::variance() const {
  // @@protoc_insertion_point(field_get:choreo.FluidPressure.variance)
  return variance_ != NULL ? *variance_
                         : *::choreo::Float64::internal_default_instance();
}
inline ::choreo::Float64* FluidPressure::mutable_variance() {
  
  if (variance_ == NULL) {
    variance_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.FluidPressure.variance)
  return variance_;
}
inline ::choreo::Float64* FluidPressure::release_variance() {
  // @@protoc_insertion_point(field_release:choreo.FluidPressure.variance)
  
  ::choreo::Float64* temp = variance_;
  variance_ = NULL;
  return temp;
}
inline void FluidPressure::set_allocated_variance(::choreo::Float64* variance) {
  delete variance_;
  variance_ = variance;
  if (variance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.FluidPressure.variance)
}

// -------------------------------------------------------------------

// Illuminance

// .choreo.Header header = 1;
inline bool Illuminance::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Illuminance::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& Illuminance::header() const {
  // @@protoc_insertion_point(field_get:choreo.Illuminance.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* Illuminance::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Illuminance.header)
  return header_;
}
inline ::choreo::Header* Illuminance::release_header() {
  // @@protoc_insertion_point(field_release:choreo.Illuminance.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Illuminance::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Illuminance.header)
}

// .choreo.Float64 illuminance = 2;
inline bool Illuminance::has_illuminance() const {
  return this != internal_default_instance() && illuminance_ != NULL;
}
inline void Illuminance::clear_illuminance() {
  if (GetArenaNoVirtual() == NULL && illuminance_ != NULL) delete illuminance_;
  illuminance_ = NULL;
}
inline const ::choreo::Float64& Illuminance::illuminance() const {
  // @@protoc_insertion_point(field_get:choreo.Illuminance.illuminance)
  return illuminance_ != NULL ? *illuminance_
                         : *::choreo::Float64::internal_default_instance();
}
inline ::choreo::Float64* Illuminance::mutable_illuminance() {
  
  if (illuminance_ == NULL) {
    illuminance_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Illuminance.illuminance)
  return illuminance_;
}
inline ::choreo::Float64* Illuminance::release_illuminance() {
  // @@protoc_insertion_point(field_release:choreo.Illuminance.illuminance)
  
  ::choreo::Float64* temp = illuminance_;
  illuminance_ = NULL;
  return temp;
}
inline void Illuminance::set_allocated_illuminance(::choreo::Float64* illuminance) {
  delete illuminance_;
  illuminance_ = illuminance;
  if (illuminance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Illuminance.illuminance)
}

// .choreo.Float64 variance = 3;
inline bool Illuminance::has_variance() const {
  return this != internal_default_instance() && variance_ != NULL;
}
inline void Illuminance::clear_variance() {
  if (GetArenaNoVirtual() == NULL && variance_ != NULL) delete variance_;
  variance_ = NULL;
}
inline const ::choreo::Float64& Illuminance::variance() const {
  // @@protoc_insertion_point(field_get:choreo.Illuminance.variance)
  return variance_ != NULL ? *variance_
                         : *::choreo::Float64::internal_default_instance();
}
inline ::choreo::Float64* Illuminance::mutable_variance() {
  
  if (variance_ == NULL) {
    variance_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Illuminance.variance)
  return variance_;
}
inline ::choreo::Float64* Illuminance::release_variance() {
  // @@protoc_insertion_point(field_release:choreo.Illuminance.variance)
  
  ::choreo::Float64* temp = variance_;
  variance_ = NULL;
  return temp;
}
inline void Illuminance::set_allocated_variance(::choreo::Float64* variance) {
  delete variance_;
  variance_ = variance;
  if (variance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Illuminance.variance)
}

// -------------------------------------------------------------------

// Humidity

// .choreo.Header header = 1;
inline bool Humidity::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Humidity::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& Humidity::header() const {
  // @@protoc_insertion_point(field_get:choreo.Humidity.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* Humidity::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Humidity.header)
  return header_;
}
inline ::choreo::Header* Humidity::release_header() {
  // @@protoc_insertion_point(field_release:choreo.Humidity.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Humidity::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Humidity.header)
}

// .choreo.Float64 relative_humidity = 2;
inline bool Humidity::has_relative_humidity() const {
  return this != internal_default_instance() && relative_humidity_ != NULL;
}
inline void Humidity::clear_relative_humidity() {
  if (GetArenaNoVirtual() == NULL && relative_humidity_ != NULL) delete relative_humidity_;
  relative_humidity_ = NULL;
}
inline const ::choreo::Float64& Humidity::relative_humidity() const {
  // @@protoc_insertion_point(field_get:choreo.Humidity.relative_humidity)
  return relative_humidity_ != NULL ? *relative_humidity_
                         : *::choreo::Float64::internal_default_instance();
}
inline ::choreo::Float64* Humidity::mutable_relative_humidity() {
  
  if (relative_humidity_ == NULL) {
    relative_humidity_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Humidity.relative_humidity)
  return relative_humidity_;
}
inline ::choreo::Float64* Humidity::release_relative_humidity() {
  // @@protoc_insertion_point(field_release:choreo.Humidity.relative_humidity)
  
  ::choreo::Float64* temp = relative_humidity_;
  relative_humidity_ = NULL;
  return temp;
}
inline void Humidity::set_allocated_relative_humidity(::choreo::Float64* relative_humidity) {
  delete relative_humidity_;
  relative_humidity_ = relative_humidity;
  if (relative_humidity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Humidity.relative_humidity)
}

// .choreo.Float64 variance = 3;
inline bool Humidity::has_variance() const {
  return this != internal_default_instance() && variance_ != NULL;
}
inline void Humidity::clear_variance() {
  if (GetArenaNoVirtual() == NULL && variance_ != NULL) delete variance_;
  variance_ = NULL;
}
inline const ::choreo::Float64& Humidity::variance() const {
  // @@protoc_insertion_point(field_get:choreo.Humidity.variance)
  return variance_ != NULL ? *variance_
                         : *::choreo::Float64::internal_default_instance();
}
inline ::choreo::Float64* Humidity::mutable_variance() {
  
  if (variance_ == NULL) {
    variance_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Humidity.variance)
  return variance_;
}
inline ::choreo::Float64* Humidity::release_variance() {
  // @@protoc_insertion_point(field_release:choreo.Humidity.variance)
  
  ::choreo::Float64* temp = variance_;
  variance_ = NULL;
  return temp;
}
inline void Humidity::set_allocated_variance(::choreo::Float64* variance) {
  delete variance_;
  variance_ = variance;
  if (variance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Humidity.variance)
}

// -------------------------------------------------------------------

// Temperature

// .choreo.Header header = 1;
inline bool Temperature::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Temperature::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& Temperature::header() const {
  // @@protoc_insertion_point(field_get:choreo.Temperature.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* Temperature::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Temperature.header)
  return header_;
}
inline ::choreo::Header* Temperature::release_header() {
  // @@protoc_insertion_point(field_release:choreo.Temperature.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Temperature::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Temperature.header)
}

// .choreo.Float64 temperature = 2;
inline bool Temperature::has_temperature() const {
  return this != internal_default_instance() && temperature_ != NULL;
}
inline void Temperature::clear_temperature() {
  if (GetArenaNoVirtual() == NULL && temperature_ != NULL) delete temperature_;
  temperature_ = NULL;
}
inline const ::choreo::Float64& Temperature::temperature() const {
  // @@protoc_insertion_point(field_get:choreo.Temperature.temperature)
  return temperature_ != NULL ? *temperature_
                         : *::choreo::Float64::internal_default_instance();
}
inline ::choreo::Float64* Temperature::mutable_temperature() {
  
  if (temperature_ == NULL) {
    temperature_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Temperature.temperature)
  return temperature_;
}
inline ::choreo::Float64* Temperature::release_temperature() {
  // @@protoc_insertion_point(field_release:choreo.Temperature.temperature)
  
  ::choreo::Float64* temp = temperature_;
  temperature_ = NULL;
  return temp;
}
inline void Temperature::set_allocated_temperature(::choreo::Float64* temperature) {
  delete temperature_;
  temperature_ = temperature;
  if (temperature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Temperature.temperature)
}

// .choreo.Float64 variance = 3;
inline bool Temperature::has_variance() const {
  return this != internal_default_instance() && variance_ != NULL;
}
inline void Temperature::clear_variance() {
  if (GetArenaNoVirtual() == NULL && variance_ != NULL) delete variance_;
  variance_ = NULL;
}
inline const ::choreo::Float64& Temperature::variance() const {
  // @@protoc_insertion_point(field_get:choreo.Temperature.variance)
  return variance_ != NULL ? *variance_
                         : *::choreo::Float64::internal_default_instance();
}
inline ::choreo::Float64* Temperature::mutable_variance() {
  
  if (variance_ == NULL) {
    variance_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Temperature.variance)
  return variance_;
}
inline ::choreo::Float64* Temperature::release_variance() {
  // @@protoc_insertion_point(field_release:choreo.Temperature.variance)
  
  ::choreo::Float64* temp = variance_;
  variance_ = NULL;
  return temp;
}
inline void Temperature::set_allocated_variance(::choreo::Float64* variance) {
  delete variance_;
  variance_ = variance;
  if (variance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Temperature.variance)
}

// -------------------------------------------------------------------

// TimeReference

// .choreo.Header header = 1;
inline bool TimeReference::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void TimeReference::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& TimeReference::header() const {
  // @@protoc_insertion_point(field_get:choreo.TimeReference.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* TimeReference::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.TimeReference.header)
  return header_;
}
inline ::choreo::Header* TimeReference::release_header() {
  // @@protoc_insertion_point(field_release:choreo.TimeReference.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TimeReference::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.TimeReference.header)
}

// .google.protobuf.Timestamp time_ref = 2;
inline bool TimeReference::has_time_ref() const {
  return this != internal_default_instance() && time_ref_ != NULL;
}
inline void TimeReference::clear_time_ref() {
  if (GetArenaNoVirtual() == NULL && time_ref_ != NULL) delete time_ref_;
  time_ref_ = NULL;
}
inline const ::google::protobuf::Timestamp& TimeReference::time_ref() const {
  // @@protoc_insertion_point(field_get:choreo.TimeReference.time_ref)
  return time_ref_ != NULL ? *time_ref_
                         : *::google::protobuf::Timestamp::internal_default_instance();
}
inline ::google::protobuf::Timestamp* TimeReference::mutable_time_ref() {
  
  if (time_ref_ == NULL) {
    time_ref_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:choreo.TimeReference.time_ref)
  return time_ref_;
}
inline ::google::protobuf::Timestamp* TimeReference::release_time_ref() {
  // @@protoc_insertion_point(field_release:choreo.TimeReference.time_ref)
  
  ::google::protobuf::Timestamp* temp = time_ref_;
  time_ref_ = NULL;
  return temp;
}
inline void TimeReference::set_allocated_time_ref(::google::protobuf::Timestamp* time_ref) {
  delete time_ref_;
  if (time_ref != NULL && time_ref->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_time_ref = new ::google::protobuf::Timestamp;
    new_time_ref->CopyFrom(*time_ref);
    time_ref = new_time_ref;
  }
  time_ref_ = time_ref;
  if (time_ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.TimeReference.time_ref)
}

// .choreo.String source = 3;
inline bool TimeReference::has_source() const {
  return this != internal_default_instance() && source_ != NULL;
}
inline void TimeReference::clear_source() {
  if (GetArenaNoVirtual() == NULL && source_ != NULL) delete source_;
  source_ = NULL;
}
inline const ::choreo::String& TimeReference::source() const {
  // @@protoc_insertion_point(field_get:choreo.TimeReference.source)
  return source_ != NULL ? *source_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* TimeReference::mutable_source() {
  
  if (source_ == NULL) {
    source_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.TimeReference.source)
  return source_;
}
inline ::choreo::String* TimeReference::release_source() {
  // @@protoc_insertion_point(field_release:choreo.TimeReference.source)
  
  ::choreo::String* temp = source_;
  source_ = NULL;
  return temp;
}
inline void TimeReference::set_allocated_source(::choreo::String* source) {
  delete source_;
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.TimeReference.source)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace choreo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sensor_2fbasic_2eproto__INCLUDED
