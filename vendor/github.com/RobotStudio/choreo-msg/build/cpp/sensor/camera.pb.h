// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor/camera.proto

#ifndef PROTOBUF_sensor_2fcamera_2eproto__INCLUDED
#define PROTOBUF_sensor_2fcamera_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "primitive/bool.pb.h"
#include "primitive/float.pb.h"
#include "primitive/header.pb.h"
#include "primitive/int.pb.h"
#include "primitive/string.pb.h"
// @@protoc_insertion_point(includes)
namespace choreo {
class Bool;
class BoolDefaultTypeInternal;
extern BoolDefaultTypeInternal _Bool_default_instance_;
class BoolArray;
class BoolArrayDefaultTypeInternal;
extern BoolArrayDefaultTypeInternal _BoolArray_default_instance_;
class CameraInfo;
class CameraInfoDefaultTypeInternal;
extern CameraInfoDefaultTypeInternal _CameraInfo_default_instance_;
class ChannelFloat32;
class ChannelFloat32DefaultTypeInternal;
extern ChannelFloat32DefaultTypeInternal _ChannelFloat32_default_instance_;
class ColorRGBA;
class ColorRGBADefaultTypeInternal;
extern ColorRGBADefaultTypeInternal _ColorRGBA_default_instance_;
class CompressedImage;
class CompressedImageDefaultTypeInternal;
extern CompressedImageDefaultTypeInternal _CompressedImage_default_instance_;
class Float;
class FloatDefaultTypeInternal;
extern FloatDefaultTypeInternal _Float_default_instance_;
class Float32;
class Float32DefaultTypeInternal;
extern Float32DefaultTypeInternal _Float32_default_instance_;
class Float32Array;
class Float32ArrayDefaultTypeInternal;
extern Float32ArrayDefaultTypeInternal _Float32Array_default_instance_;
class Float64;
class Float64DefaultTypeInternal;
extern Float64DefaultTypeInternal _Float64_default_instance_;
class Float64Array;
class Float64ArrayDefaultTypeInternal;
extern Float64ArrayDefaultTypeInternal _Float64Array_default_instance_;
class FloatArray;
class FloatArrayDefaultTypeInternal;
extern FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class Int32;
class Int32DefaultTypeInternal;
extern Int32DefaultTypeInternal _Int32_default_instance_;
class Int32Array;
class Int32ArrayDefaultTypeInternal;
extern Int32ArrayDefaultTypeInternal _Int32Array_default_instance_;
class Int64;
class Int64DefaultTypeInternal;
extern Int64DefaultTypeInternal _Int64_default_instance_;
class Int64Array;
class Int64ArrayDefaultTypeInternal;
extern Int64ArrayDefaultTypeInternal _Int64Array_default_instance_;
class RegionOfInterest;
class RegionOfInterestDefaultTypeInternal;
extern RegionOfInterestDefaultTypeInternal _RegionOfInterest_default_instance_;
class SInt32;
class SInt32DefaultTypeInternal;
extern SInt32DefaultTypeInternal _SInt32_default_instance_;
class SInt32Array;
class SInt32ArrayDefaultTypeInternal;
extern SInt32ArrayDefaultTypeInternal _SInt32Array_default_instance_;
class SInt64;
class SInt64DefaultTypeInternal;
extern SInt64DefaultTypeInternal _SInt64_default_instance_;
class SInt64Array;
class SInt64ArrayDefaultTypeInternal;
extern SInt64ArrayDefaultTypeInternal _SInt64Array_default_instance_;
class String;
class StringDefaultTypeInternal;
extern StringDefaultTypeInternal _String_default_instance_;
class UInt32;
class UInt32DefaultTypeInternal;
extern UInt32DefaultTypeInternal _UInt32_default_instance_;
class UInt32Array;
class UInt32ArrayDefaultTypeInternal;
extern UInt32ArrayDefaultTypeInternal _UInt32Array_default_instance_;
class UInt64;
class UInt64DefaultTypeInternal;
extern UInt64DefaultTypeInternal _UInt64_default_instance_;
class UInt64Array;
class UInt64ArrayDefaultTypeInternal;
extern UInt64ArrayDefaultTypeInternal _UInt64Array_default_instance_;
}  // namespace choreo

namespace choreo {

namespace protobuf_sensor_2fcamera_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_sensor_2fcamera_2eproto

// ===================================================================

class RegionOfInterest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.RegionOfInterest) */ {
 public:
  RegionOfInterest();
  virtual ~RegionOfInterest();

  RegionOfInterest(const RegionOfInterest& from);

  inline RegionOfInterest& operator=(const RegionOfInterest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionOfInterest& default_instance();

  static inline const RegionOfInterest* internal_default_instance() {
    return reinterpret_cast<const RegionOfInterest*>(
               &_RegionOfInterest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RegionOfInterest* other);

  // implements Message ----------------------------------------------

  inline RegionOfInterest* New() const PROTOBUF_FINAL { return New(NULL); }

  RegionOfInterest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegionOfInterest& from);
  void MergeFrom(const RegionOfInterest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegionOfInterest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .choreo.UInt32 x_offset = 1;
  bool has_x_offset() const;
  void clear_x_offset();
  static const int kXOffsetFieldNumber = 1;
  const ::choreo::UInt32& x_offset() const;
  ::choreo::UInt32* mutable_x_offset();
  ::choreo::UInt32* release_x_offset();
  void set_allocated_x_offset(::choreo::UInt32* x_offset);

  // .choreo.UInt32 y_offset = 2;
  bool has_y_offset() const;
  void clear_y_offset();
  static const int kYOffsetFieldNumber = 2;
  const ::choreo::UInt32& y_offset() const;
  ::choreo::UInt32* mutable_y_offset();
  ::choreo::UInt32* release_y_offset();
  void set_allocated_y_offset(::choreo::UInt32* y_offset);

  // .choreo.UInt32 height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  const ::choreo::UInt32& height() const;
  ::choreo::UInt32* mutable_height();
  ::choreo::UInt32* release_height();
  void set_allocated_height(::choreo::UInt32* height);

  // .choreo.UInt32 width = 4;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  const ::choreo::UInt32& width() const;
  ::choreo::UInt32* mutable_width();
  ::choreo::UInt32* release_width();
  void set_allocated_width(::choreo::UInt32* width);

  // .choreo.Bool do_rectify = 5;
  bool has_do_rectify() const;
  void clear_do_rectify();
  static const int kDoRectifyFieldNumber = 5;
  const ::choreo::Bool& do_rectify() const;
  ::choreo::Bool* mutable_do_rectify();
  ::choreo::Bool* release_do_rectify();
  void set_allocated_do_rectify(::choreo::Bool* do_rectify);

  // @@protoc_insertion_point(class_scope:choreo.RegionOfInterest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::UInt32* x_offset_;
  ::choreo::UInt32* y_offset_;
  ::choreo::UInt32* height_;
  ::choreo::UInt32* width_;
  ::choreo::Bool* do_rectify_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fcamera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CameraInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.CameraInfo) */ {
 public:
  CameraInfo();
  virtual ~CameraInfo();

  CameraInfo(const CameraInfo& from);

  inline CameraInfo& operator=(const CameraInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraInfo& default_instance();

  static inline const CameraInfo* internal_default_instance() {
    return reinterpret_cast<const CameraInfo*>(
               &_CameraInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CameraInfo* other);

  // implements Message ----------------------------------------------

  inline CameraInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CameraInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CameraInfo& from);
  void MergeFrom(const CameraInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CameraInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.Float64 D = 5;
  int d_size() const;
  void clear_d();
  static const int kDFieldNumber = 5;
  const ::choreo::Float64& d(int index) const;
  ::choreo::Float64* mutable_d(int index);
  ::choreo::Float64* add_d();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
      mutable_d();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
      d() const;

  // repeated .choreo.Float64 K = 6;
  int k_size() const;
  void clear_k();
  static const int kKFieldNumber = 6;
  const ::choreo::Float64& k(int index) const;
  ::choreo::Float64* mutable_k(int index);
  ::choreo::Float64* add_k();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
      mutable_k();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
      k() const;

  // repeated .choreo.Float64 P = 7;
  int p_size() const;
  void clear_p();
  static const int kPFieldNumber = 7;
  const ::choreo::Float64& p(int index) const;
  ::choreo::Float64* mutable_p(int index);
  ::choreo::Float64* add_p();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
      mutable_p();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
      p() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.UInt32 height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  const ::choreo::UInt32& height() const;
  ::choreo::UInt32* mutable_height();
  ::choreo::UInt32* release_height();
  void set_allocated_height(::choreo::UInt32* height);

  // .choreo.UInt32 width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  const ::choreo::UInt32& width() const;
  ::choreo::UInt32* mutable_width();
  ::choreo::UInt32* release_width();
  void set_allocated_width(::choreo::UInt32* width);

  // .choreo.String distortion_model = 4;
  bool has_distortion_model() const;
  void clear_distortion_model();
  static const int kDistortionModelFieldNumber = 4;
  const ::choreo::String& distortion_model() const;
  ::choreo::String* mutable_distortion_model();
  ::choreo::String* release_distortion_model();
  void set_allocated_distortion_model(::choreo::String* distortion_model);

  // .choreo.UInt32 binning_x = 8;
  bool has_binning_x() const;
  void clear_binning_x();
  static const int kBinningXFieldNumber = 8;
  const ::choreo::UInt32& binning_x() const;
  ::choreo::UInt32* mutable_binning_x();
  ::choreo::UInt32* release_binning_x();
  void set_allocated_binning_x(::choreo::UInt32* binning_x);

  // .choreo.UInt32 binning_y = 9;
  bool has_binning_y() const;
  void clear_binning_y();
  static const int kBinningYFieldNumber = 9;
  const ::choreo::UInt32& binning_y() const;
  ::choreo::UInt32* mutable_binning_y();
  ::choreo::UInt32* release_binning_y();
  void set_allocated_binning_y(::choreo::UInt32* binning_y);

  // .choreo.RegionOfInterest roi = 10;
  bool has_roi() const;
  void clear_roi();
  static const int kRoiFieldNumber = 10;
  const ::choreo::RegionOfInterest& roi() const;
  ::choreo::RegionOfInterest* mutable_roi();
  ::choreo::RegionOfInterest* release_roi();
  void set_allocated_roi(::choreo::RegionOfInterest* roi);

  // @@protoc_insertion_point(class_scope:choreo.CameraInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 > d_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 > k_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 > p_;
  ::choreo::Header* header_;
  ::choreo::UInt32* height_;
  ::choreo::UInt32* width_;
  ::choreo::String* distortion_model_;
  ::choreo::UInt32* binning_x_;
  ::choreo::UInt32* binning_y_;
  ::choreo::RegionOfInterest* roi_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fcamera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChannelFloat32 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.ChannelFloat32) */ {
 public:
  ChannelFloat32();
  virtual ~ChannelFloat32();

  ChannelFloat32(const ChannelFloat32& from);

  inline ChannelFloat32& operator=(const ChannelFloat32& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelFloat32& default_instance();

  static inline const ChannelFloat32* internal_default_instance() {
    return reinterpret_cast<const ChannelFloat32*>(
               &_ChannelFloat32_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ChannelFloat32* other);

  // implements Message ----------------------------------------------

  inline ChannelFloat32* New() const PROTOBUF_FINAL { return New(NULL); }

  ChannelFloat32* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChannelFloat32& from);
  void MergeFrom(const ChannelFloat32& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChannelFloat32* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.Float32 values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::choreo::Float32& values(int index) const;
  ::choreo::Float32* mutable_values(int index);
  ::choreo::Float32* add_values();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >&
      values() const;

  // .choreo.String name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::choreo::String& name() const;
  ::choreo::String* mutable_name();
  ::choreo::String* release_name();
  void set_allocated_name(::choreo::String* name);

  // @@protoc_insertion_point(class_scope:choreo.ChannelFloat32)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float32 > values_;
  ::choreo::String* name_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fcamera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CompressedImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.CompressedImage) */ {
 public:
  CompressedImage();
  virtual ~CompressedImage();

  CompressedImage(const CompressedImage& from);

  inline CompressedImage& operator=(const CompressedImage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CompressedImage& default_instance();

  static inline const CompressedImage* internal_default_instance() {
    return reinterpret_cast<const CompressedImage*>(
               &_CompressedImage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CompressedImage* other);

  // implements Message ----------------------------------------------

  inline CompressedImage* New() const PROTOBUF_FINAL { return New(NULL); }

  CompressedImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CompressedImage& from);
  void MergeFrom(const CompressedImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CompressedImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.UInt32 data = 3;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::choreo::UInt32& data(int index) const;
  ::choreo::UInt32* mutable_data(int index);
  ::choreo::UInt32* add_data();
  ::google::protobuf::RepeatedPtrField< ::choreo::UInt32 >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::choreo::UInt32 >&
      data() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.String format = 2;
  bool has_format() const;
  void clear_format();
  static const int kFormatFieldNumber = 2;
  const ::choreo::String& format() const;
  ::choreo::String* mutable_format();
  ::choreo::String* release_format();
  void set_allocated_format(::choreo::String* format);

  // @@protoc_insertion_point(class_scope:choreo.CompressedImage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::UInt32 > data_;
  ::choreo::Header* header_;
  ::choreo::String* format_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fcamera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Image* other);

  // implements Message ----------------------------------------------

  inline Image* New() const PROTOBUF_FINAL { return New(NULL); }

  Image* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Image* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.UInt32 data = 7;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 7;
  const ::choreo::UInt32& data(int index) const;
  ::choreo::UInt32* mutable_data(int index);
  ::choreo::UInt32* add_data();
  ::google::protobuf::RepeatedPtrField< ::choreo::UInt32 >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::choreo::UInt32 >&
      data() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.UInt32 height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  const ::choreo::UInt32& height() const;
  ::choreo::UInt32* mutable_height();
  ::choreo::UInt32* release_height();
  void set_allocated_height(::choreo::UInt32* height);

  // .choreo.UInt32 width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  const ::choreo::UInt32& width() const;
  ::choreo::UInt32* mutable_width();
  ::choreo::UInt32* release_width();
  void set_allocated_width(::choreo::UInt32* width);

  // .choreo.String encoding = 4;
  bool has_encoding() const;
  void clear_encoding();
  static const int kEncodingFieldNumber = 4;
  const ::choreo::String& encoding() const;
  ::choreo::String* mutable_encoding();
  ::choreo::String* release_encoding();
  void set_allocated_encoding(::choreo::String* encoding);

  // .choreo.Bool is_bigendian = 5;
  bool has_is_bigendian() const;
  void clear_is_bigendian();
  static const int kIsBigendianFieldNumber = 5;
  const ::choreo::Bool& is_bigendian() const;
  ::choreo::Bool* mutable_is_bigendian();
  ::choreo::Bool* release_is_bigendian();
  void set_allocated_is_bigendian(::choreo::Bool* is_bigendian);

  // .choreo.UInt32 step = 6;
  bool has_step() const;
  void clear_step();
  static const int kStepFieldNumber = 6;
  const ::choreo::UInt32& step() const;
  ::choreo::UInt32* mutable_step();
  ::choreo::UInt32* release_step();
  void set_allocated_step(::choreo::UInt32* step);

  // @@protoc_insertion_point(class_scope:choreo.Image)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::UInt32 > data_;
  ::choreo::Header* header_;
  ::choreo::UInt32* height_;
  ::choreo::UInt32* width_;
  ::choreo::String* encoding_;
  ::choreo::Bool* is_bigendian_;
  ::choreo::UInt32* step_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fcamera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ColorRGBA : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.ColorRGBA) */ {
 public:
  ColorRGBA();
  virtual ~ColorRGBA();

  ColorRGBA(const ColorRGBA& from);

  inline ColorRGBA& operator=(const ColorRGBA& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColorRGBA& default_instance();

  static inline const ColorRGBA* internal_default_instance() {
    return reinterpret_cast<const ColorRGBA*>(
               &_ColorRGBA_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ColorRGBA* other);

  // implements Message ----------------------------------------------

  inline ColorRGBA* New() const PROTOBUF_FINAL { return New(NULL); }

  ColorRGBA* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ColorRGBA& from);
  void MergeFrom(const ColorRGBA& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ColorRGBA* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .choreo.Float32 r = 1;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 1;
  const ::choreo::Float32& r() const;
  ::choreo::Float32* mutable_r();
  ::choreo::Float32* release_r();
  void set_allocated_r(::choreo::Float32* r);

  // .choreo.Float32 g = 2;
  bool has_g() const;
  void clear_g();
  static const int kGFieldNumber = 2;
  const ::choreo::Float32& g() const;
  ::choreo::Float32* mutable_g();
  ::choreo::Float32* release_g();
  void set_allocated_g(::choreo::Float32* g);

  // .choreo.Float32 b = 3;
  bool has_b() const;
  void clear_b();
  static const int kBFieldNumber = 3;
  const ::choreo::Float32& b() const;
  ::choreo::Float32* mutable_b();
  ::choreo::Float32* release_b();
  void set_allocated_b(::choreo::Float32* b);

  // .choreo.Float32 a = 4;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 4;
  const ::choreo::Float32& a() const;
  ::choreo::Float32* mutable_a();
  ::choreo::Float32* release_a();
  void set_allocated_a(::choreo::Float32* a);

  // @@protoc_insertion_point(class_scope:choreo.ColorRGBA)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::Float32* r_;
  ::choreo::Float32* g_;
  ::choreo::Float32* b_;
  ::choreo::Float32* a_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fcamera_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RegionOfInterest

// .choreo.UInt32 x_offset = 1;
inline bool RegionOfInterest::has_x_offset() const {
  return this != internal_default_instance() && x_offset_ != NULL;
}
inline void RegionOfInterest::clear_x_offset() {
  if (GetArenaNoVirtual() == NULL && x_offset_ != NULL) delete x_offset_;
  x_offset_ = NULL;
}
inline const ::choreo::UInt32& RegionOfInterest::x_offset() const {
  // @@protoc_insertion_point(field_get:choreo.RegionOfInterest.x_offset)
  return x_offset_ != NULL ? *x_offset_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* RegionOfInterest::mutable_x_offset() {
  
  if (x_offset_ == NULL) {
    x_offset_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.RegionOfInterest.x_offset)
  return x_offset_;
}
inline ::choreo::UInt32* RegionOfInterest::release_x_offset() {
  // @@protoc_insertion_point(field_release:choreo.RegionOfInterest.x_offset)
  
  ::choreo::UInt32* temp = x_offset_;
  x_offset_ = NULL;
  return temp;
}
inline void RegionOfInterest::set_allocated_x_offset(::choreo::UInt32* x_offset) {
  delete x_offset_;
  x_offset_ = x_offset;
  if (x_offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.RegionOfInterest.x_offset)
}

// .choreo.UInt32 y_offset = 2;
inline bool RegionOfInterest::has_y_offset() const {
  return this != internal_default_instance() && y_offset_ != NULL;
}
inline void RegionOfInterest::clear_y_offset() {
  if (GetArenaNoVirtual() == NULL && y_offset_ != NULL) delete y_offset_;
  y_offset_ = NULL;
}
inline const ::choreo::UInt32& RegionOfInterest::y_offset() const {
  // @@protoc_insertion_point(field_get:choreo.RegionOfInterest.y_offset)
  return y_offset_ != NULL ? *y_offset_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* RegionOfInterest::mutable_y_offset() {
  
  if (y_offset_ == NULL) {
    y_offset_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.RegionOfInterest.y_offset)
  return y_offset_;
}
inline ::choreo::UInt32* RegionOfInterest::release_y_offset() {
  // @@protoc_insertion_point(field_release:choreo.RegionOfInterest.y_offset)
  
  ::choreo::UInt32* temp = y_offset_;
  y_offset_ = NULL;
  return temp;
}
inline void RegionOfInterest::set_allocated_y_offset(::choreo::UInt32* y_offset) {
  delete y_offset_;
  y_offset_ = y_offset;
  if (y_offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.RegionOfInterest.y_offset)
}

// .choreo.UInt32 height = 3;
inline bool RegionOfInterest::has_height() const {
  return this != internal_default_instance() && height_ != NULL;
}
inline void RegionOfInterest::clear_height() {
  if (GetArenaNoVirtual() == NULL && height_ != NULL) delete height_;
  height_ = NULL;
}
inline const ::choreo::UInt32& RegionOfInterest::height() const {
  // @@protoc_insertion_point(field_get:choreo.RegionOfInterest.height)
  return height_ != NULL ? *height_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* RegionOfInterest::mutable_height() {
  
  if (height_ == NULL) {
    height_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.RegionOfInterest.height)
  return height_;
}
inline ::choreo::UInt32* RegionOfInterest::release_height() {
  // @@protoc_insertion_point(field_release:choreo.RegionOfInterest.height)
  
  ::choreo::UInt32* temp = height_;
  height_ = NULL;
  return temp;
}
inline void RegionOfInterest::set_allocated_height(::choreo::UInt32* height) {
  delete height_;
  height_ = height;
  if (height) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.RegionOfInterest.height)
}

// .choreo.UInt32 width = 4;
inline bool RegionOfInterest::has_width() const {
  return this != internal_default_instance() && width_ != NULL;
}
inline void RegionOfInterest::clear_width() {
  if (GetArenaNoVirtual() == NULL && width_ != NULL) delete width_;
  width_ = NULL;
}
inline const ::choreo::UInt32& RegionOfInterest::width() const {
  // @@protoc_insertion_point(field_get:choreo.RegionOfInterest.width)
  return width_ != NULL ? *width_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* RegionOfInterest::mutable_width() {
  
  if (width_ == NULL) {
    width_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.RegionOfInterest.width)
  return width_;
}
inline ::choreo::UInt32* RegionOfInterest::release_width() {
  // @@protoc_insertion_point(field_release:choreo.RegionOfInterest.width)
  
  ::choreo::UInt32* temp = width_;
  width_ = NULL;
  return temp;
}
inline void RegionOfInterest::set_allocated_width(::choreo::UInt32* width) {
  delete width_;
  width_ = width;
  if (width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.RegionOfInterest.width)
}

// .choreo.Bool do_rectify = 5;
inline bool RegionOfInterest::has_do_rectify() const {
  return this != internal_default_instance() && do_rectify_ != NULL;
}
inline void RegionOfInterest::clear_do_rectify() {
  if (GetArenaNoVirtual() == NULL && do_rectify_ != NULL) delete do_rectify_;
  do_rectify_ = NULL;
}
inline const ::choreo::Bool& RegionOfInterest::do_rectify() const {
  // @@protoc_insertion_point(field_get:choreo.RegionOfInterest.do_rectify)
  return do_rectify_ != NULL ? *do_rectify_
                         : *::choreo::Bool::internal_default_instance();
}
inline ::choreo::Bool* RegionOfInterest::mutable_do_rectify() {
  
  if (do_rectify_ == NULL) {
    do_rectify_ = new ::choreo::Bool;
  }
  // @@protoc_insertion_point(field_mutable:choreo.RegionOfInterest.do_rectify)
  return do_rectify_;
}
inline ::choreo::Bool* RegionOfInterest::release_do_rectify() {
  // @@protoc_insertion_point(field_release:choreo.RegionOfInterest.do_rectify)
  
  ::choreo::Bool* temp = do_rectify_;
  do_rectify_ = NULL;
  return temp;
}
inline void RegionOfInterest::set_allocated_do_rectify(::choreo::Bool* do_rectify) {
  delete do_rectify_;
  do_rectify_ = do_rectify;
  if (do_rectify) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.RegionOfInterest.do_rectify)
}

// -------------------------------------------------------------------

// CameraInfo

// .choreo.Header header = 1;
inline bool CameraInfo::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CameraInfo::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& CameraInfo::header() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* CameraInfo::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.header)
  return header_;
}
inline ::choreo::Header* CameraInfo::release_header() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CameraInfo::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.header)
}

// .choreo.UInt32 height = 2;
inline bool CameraInfo::has_height() const {
  return this != internal_default_instance() && height_ != NULL;
}
inline void CameraInfo::clear_height() {
  if (GetArenaNoVirtual() == NULL && height_ != NULL) delete height_;
  height_ = NULL;
}
inline const ::choreo::UInt32& CameraInfo::height() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.height)
  return height_ != NULL ? *height_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* CameraInfo::mutable_height() {
  
  if (height_ == NULL) {
    height_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.height)
  return height_;
}
inline ::choreo::UInt32* CameraInfo::release_height() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.height)
  
  ::choreo::UInt32* temp = height_;
  height_ = NULL;
  return temp;
}
inline void CameraInfo::set_allocated_height(::choreo::UInt32* height) {
  delete height_;
  height_ = height;
  if (height) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.height)
}

// .choreo.UInt32 width = 3;
inline bool CameraInfo::has_width() const {
  return this != internal_default_instance() && width_ != NULL;
}
inline void CameraInfo::clear_width() {
  if (GetArenaNoVirtual() == NULL && width_ != NULL) delete width_;
  width_ = NULL;
}
inline const ::choreo::UInt32& CameraInfo::width() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.width)
  return width_ != NULL ? *width_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* CameraInfo::mutable_width() {
  
  if (width_ == NULL) {
    width_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.width)
  return width_;
}
inline ::choreo::UInt32* CameraInfo::release_width() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.width)
  
  ::choreo::UInt32* temp = width_;
  width_ = NULL;
  return temp;
}
inline void CameraInfo::set_allocated_width(::choreo::UInt32* width) {
  delete width_;
  width_ = width;
  if (width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.width)
}

// .choreo.String distortion_model = 4;
inline bool CameraInfo::has_distortion_model() const {
  return this != internal_default_instance() && distortion_model_ != NULL;
}
inline void CameraInfo::clear_distortion_model() {
  if (GetArenaNoVirtual() == NULL && distortion_model_ != NULL) delete distortion_model_;
  distortion_model_ = NULL;
}
inline const ::choreo::String& CameraInfo::distortion_model() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.distortion_model)
  return distortion_model_ != NULL ? *distortion_model_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* CameraInfo::mutable_distortion_model() {
  
  if (distortion_model_ == NULL) {
    distortion_model_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.distortion_model)
  return distortion_model_;
}
inline ::choreo::String* CameraInfo::release_distortion_model() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.distortion_model)
  
  ::choreo::String* temp = distortion_model_;
  distortion_model_ = NULL;
  return temp;
}
inline void CameraInfo::set_allocated_distortion_model(::choreo::String* distortion_model) {
  delete distortion_model_;
  distortion_model_ = distortion_model;
  if (distortion_model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.distortion_model)
}

// repeated .choreo.Float64 D = 5;
inline int CameraInfo::d_size() const {
  return d_.size();
}
inline void CameraInfo::clear_d() {
  d_.Clear();
}
inline const ::choreo::Float64& CameraInfo::d(int index) const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.D)
  return d_.Get(index);
}
inline ::choreo::Float64* CameraInfo::mutable_d(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.D)
  return d_.Mutable(index);
}
inline ::choreo::Float64* CameraInfo::add_d() {
  // @@protoc_insertion_point(field_add:choreo.CameraInfo.D)
  return d_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
CameraInfo::mutable_d() {
  // @@protoc_insertion_point(field_mutable_list:choreo.CameraInfo.D)
  return &d_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
CameraInfo::d() const {
  // @@protoc_insertion_point(field_list:choreo.CameraInfo.D)
  return d_;
}

// repeated .choreo.Float64 K = 6;
inline int CameraInfo::k_size() const {
  return k_.size();
}
inline void CameraInfo::clear_k() {
  k_.Clear();
}
inline const ::choreo::Float64& CameraInfo::k(int index) const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.K)
  return k_.Get(index);
}
inline ::choreo::Float64* CameraInfo::mutable_k(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.K)
  return k_.Mutable(index);
}
inline ::choreo::Float64* CameraInfo::add_k() {
  // @@protoc_insertion_point(field_add:choreo.CameraInfo.K)
  return k_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
CameraInfo::mutable_k() {
  // @@protoc_insertion_point(field_mutable_list:choreo.CameraInfo.K)
  return &k_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
CameraInfo::k() const {
  // @@protoc_insertion_point(field_list:choreo.CameraInfo.K)
  return k_;
}

// repeated .choreo.Float64 P = 7;
inline int CameraInfo::p_size() const {
  return p_.size();
}
inline void CameraInfo::clear_p() {
  p_.Clear();
}
inline const ::choreo::Float64& CameraInfo::p(int index) const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.P)
  return p_.Get(index);
}
inline ::choreo::Float64* CameraInfo::mutable_p(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.P)
  return p_.Mutable(index);
}
inline ::choreo::Float64* CameraInfo::add_p() {
  // @@protoc_insertion_point(field_add:choreo.CameraInfo.P)
  return p_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
CameraInfo::mutable_p() {
  // @@protoc_insertion_point(field_mutable_list:choreo.CameraInfo.P)
  return &p_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
CameraInfo::p() const {
  // @@protoc_insertion_point(field_list:choreo.CameraInfo.P)
  return p_;
}

// .choreo.UInt32 binning_x = 8;
inline bool CameraInfo::has_binning_x() const {
  return this != internal_default_instance() && binning_x_ != NULL;
}
inline void CameraInfo::clear_binning_x() {
  if (GetArenaNoVirtual() == NULL && binning_x_ != NULL) delete binning_x_;
  binning_x_ = NULL;
}
inline const ::choreo::UInt32& CameraInfo::binning_x() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.binning_x)
  return binning_x_ != NULL ? *binning_x_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* CameraInfo::mutable_binning_x() {
  
  if (binning_x_ == NULL) {
    binning_x_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.binning_x)
  return binning_x_;
}
inline ::choreo::UInt32* CameraInfo::release_binning_x() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.binning_x)
  
  ::choreo::UInt32* temp = binning_x_;
  binning_x_ = NULL;
  return temp;
}
inline void CameraInfo::set_allocated_binning_x(::choreo::UInt32* binning_x) {
  delete binning_x_;
  binning_x_ = binning_x;
  if (binning_x) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.binning_x)
}

// .choreo.UInt32 binning_y = 9;
inline bool CameraInfo::has_binning_y() const {
  return this != internal_default_instance() && binning_y_ != NULL;
}
inline void CameraInfo::clear_binning_y() {
  if (GetArenaNoVirtual() == NULL && binning_y_ != NULL) delete binning_y_;
  binning_y_ = NULL;
}
inline const ::choreo::UInt32& CameraInfo::binning_y() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.binning_y)
  return binning_y_ != NULL ? *binning_y_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* CameraInfo::mutable_binning_y() {
  
  if (binning_y_ == NULL) {
    binning_y_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.binning_y)
  return binning_y_;
}
inline ::choreo::UInt32* CameraInfo::release_binning_y() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.binning_y)
  
  ::choreo::UInt32* temp = binning_y_;
  binning_y_ = NULL;
  return temp;
}
inline void CameraInfo::set_allocated_binning_y(::choreo::UInt32* binning_y) {
  delete binning_y_;
  binning_y_ = binning_y;
  if (binning_y) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.binning_y)
}

// .choreo.RegionOfInterest roi = 10;
inline bool CameraInfo::has_roi() const {
  return this != internal_default_instance() && roi_ != NULL;
}
inline void CameraInfo::clear_roi() {
  if (GetArenaNoVirtual() == NULL && roi_ != NULL) delete roi_;
  roi_ = NULL;
}
inline const ::choreo::RegionOfInterest& CameraInfo::roi() const {
  // @@protoc_insertion_point(field_get:choreo.CameraInfo.roi)
  return roi_ != NULL ? *roi_
                         : *::choreo::RegionOfInterest::internal_default_instance();
}
inline ::choreo::RegionOfInterest* CameraInfo::mutable_roi() {
  
  if (roi_ == NULL) {
    roi_ = new ::choreo::RegionOfInterest;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CameraInfo.roi)
  return roi_;
}
inline ::choreo::RegionOfInterest* CameraInfo::release_roi() {
  // @@protoc_insertion_point(field_release:choreo.CameraInfo.roi)
  
  ::choreo::RegionOfInterest* temp = roi_;
  roi_ = NULL;
  return temp;
}
inline void CameraInfo::set_allocated_roi(::choreo::RegionOfInterest* roi) {
  delete roi_;
  roi_ = roi;
  if (roi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CameraInfo.roi)
}

// -------------------------------------------------------------------

// ChannelFloat32

// .choreo.String name = 1;
inline bool ChannelFloat32::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline void ChannelFloat32::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) delete name_;
  name_ = NULL;
}
inline const ::choreo::String& ChannelFloat32::name() const {
  // @@protoc_insertion_point(field_get:choreo.ChannelFloat32.name)
  return name_ != NULL ? *name_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* ChannelFloat32::mutable_name() {
  
  if (name_ == NULL) {
    name_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ChannelFloat32.name)
  return name_;
}
inline ::choreo::String* ChannelFloat32::release_name() {
  // @@protoc_insertion_point(field_release:choreo.ChannelFloat32.name)
  
  ::choreo::String* temp = name_;
  name_ = NULL;
  return temp;
}
inline void ChannelFloat32::set_allocated_name(::choreo::String* name) {
  delete name_;
  name_ = name;
  if (name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ChannelFloat32.name)
}

// repeated .choreo.Float32 values = 2;
inline int ChannelFloat32::values_size() const {
  return values_.size();
}
inline void ChannelFloat32::clear_values() {
  values_.Clear();
}
inline const ::choreo::Float32& ChannelFloat32::values(int index) const {
  // @@protoc_insertion_point(field_get:choreo.ChannelFloat32.values)
  return values_.Get(index);
}
inline ::choreo::Float32* ChannelFloat32::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.ChannelFloat32.values)
  return values_.Mutable(index);
}
inline ::choreo::Float32* ChannelFloat32::add_values() {
  // @@protoc_insertion_point(field_add:choreo.ChannelFloat32.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >*
ChannelFloat32::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:choreo.ChannelFloat32.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >&
ChannelFloat32::values() const {
  // @@protoc_insertion_point(field_list:choreo.ChannelFloat32.values)
  return values_;
}

// -------------------------------------------------------------------

// CompressedImage

// .choreo.Header header = 1;
inline bool CompressedImage::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CompressedImage::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& CompressedImage::header() const {
  // @@protoc_insertion_point(field_get:choreo.CompressedImage.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* CompressedImage::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CompressedImage.header)
  return header_;
}
inline ::choreo::Header* CompressedImage::release_header() {
  // @@protoc_insertion_point(field_release:choreo.CompressedImage.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CompressedImage::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CompressedImage.header)
}

// .choreo.String format = 2;
inline bool CompressedImage::has_format() const {
  return this != internal_default_instance() && format_ != NULL;
}
inline void CompressedImage::clear_format() {
  if (GetArenaNoVirtual() == NULL && format_ != NULL) delete format_;
  format_ = NULL;
}
inline const ::choreo::String& CompressedImage::format() const {
  // @@protoc_insertion_point(field_get:choreo.CompressedImage.format)
  return format_ != NULL ? *format_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* CompressedImage::mutable_format() {
  
  if (format_ == NULL) {
    format_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.CompressedImage.format)
  return format_;
}
inline ::choreo::String* CompressedImage::release_format() {
  // @@protoc_insertion_point(field_release:choreo.CompressedImage.format)
  
  ::choreo::String* temp = format_;
  format_ = NULL;
  return temp;
}
inline void CompressedImage::set_allocated_format(::choreo::String* format) {
  delete format_;
  format_ = format;
  if (format) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.CompressedImage.format)
}

// repeated .choreo.UInt32 data = 3;
inline int CompressedImage::data_size() const {
  return data_.size();
}
inline void CompressedImage::clear_data() {
  data_.Clear();
}
inline const ::choreo::UInt32& CompressedImage::data(int index) const {
  // @@protoc_insertion_point(field_get:choreo.CompressedImage.data)
  return data_.Get(index);
}
inline ::choreo::UInt32* CompressedImage::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.CompressedImage.data)
  return data_.Mutable(index);
}
inline ::choreo::UInt32* CompressedImage::add_data() {
  // @@protoc_insertion_point(field_add:choreo.CompressedImage.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::UInt32 >*
CompressedImage::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:choreo.CompressedImage.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::UInt32 >&
CompressedImage::data() const {
  // @@protoc_insertion_point(field_list:choreo.CompressedImage.data)
  return data_;
}

// -------------------------------------------------------------------

// Image

// .choreo.Header header = 1;
inline bool Image::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Image::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& Image::header() const {
  // @@protoc_insertion_point(field_get:choreo.Image.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* Image::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Image.header)
  return header_;
}
inline ::choreo::Header* Image::release_header() {
  // @@protoc_insertion_point(field_release:choreo.Image.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Image::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Image.header)
}

// .choreo.UInt32 height = 2;
inline bool Image::has_height() const {
  return this != internal_default_instance() && height_ != NULL;
}
inline void Image::clear_height() {
  if (GetArenaNoVirtual() == NULL && height_ != NULL) delete height_;
  height_ = NULL;
}
inline const ::choreo::UInt32& Image::height() const {
  // @@protoc_insertion_point(field_get:choreo.Image.height)
  return height_ != NULL ? *height_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* Image::mutable_height() {
  
  if (height_ == NULL) {
    height_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Image.height)
  return height_;
}
inline ::choreo::UInt32* Image::release_height() {
  // @@protoc_insertion_point(field_release:choreo.Image.height)
  
  ::choreo::UInt32* temp = height_;
  height_ = NULL;
  return temp;
}
inline void Image::set_allocated_height(::choreo::UInt32* height) {
  delete height_;
  height_ = height;
  if (height) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Image.height)
}

// .choreo.UInt32 width = 3;
inline bool Image::has_width() const {
  return this != internal_default_instance() && width_ != NULL;
}
inline void Image::clear_width() {
  if (GetArenaNoVirtual() == NULL && width_ != NULL) delete width_;
  width_ = NULL;
}
inline const ::choreo::UInt32& Image::width() const {
  // @@protoc_insertion_point(field_get:choreo.Image.width)
  return width_ != NULL ? *width_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* Image::mutable_width() {
  
  if (width_ == NULL) {
    width_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Image.width)
  return width_;
}
inline ::choreo::UInt32* Image::release_width() {
  // @@protoc_insertion_point(field_release:choreo.Image.width)
  
  ::choreo::UInt32* temp = width_;
  width_ = NULL;
  return temp;
}
inline void Image::set_allocated_width(::choreo::UInt32* width) {
  delete width_;
  width_ = width;
  if (width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Image.width)
}

// .choreo.String encoding = 4;
inline bool Image::has_encoding() const {
  return this != internal_default_instance() && encoding_ != NULL;
}
inline void Image::clear_encoding() {
  if (GetArenaNoVirtual() == NULL && encoding_ != NULL) delete encoding_;
  encoding_ = NULL;
}
inline const ::choreo::String& Image::encoding() const {
  // @@protoc_insertion_point(field_get:choreo.Image.encoding)
  return encoding_ != NULL ? *encoding_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* Image::mutable_encoding() {
  
  if (encoding_ == NULL) {
    encoding_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Image.encoding)
  return encoding_;
}
inline ::choreo::String* Image::release_encoding() {
  // @@protoc_insertion_point(field_release:choreo.Image.encoding)
  
  ::choreo::String* temp = encoding_;
  encoding_ = NULL;
  return temp;
}
inline void Image::set_allocated_encoding(::choreo::String* encoding) {
  delete encoding_;
  encoding_ = encoding;
  if (encoding) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Image.encoding)
}

// .choreo.Bool is_bigendian = 5;
inline bool Image::has_is_bigendian() const {
  return this != internal_default_instance() && is_bigendian_ != NULL;
}
inline void Image::clear_is_bigendian() {
  if (GetArenaNoVirtual() == NULL && is_bigendian_ != NULL) delete is_bigendian_;
  is_bigendian_ = NULL;
}
inline const ::choreo::Bool& Image::is_bigendian() const {
  // @@protoc_insertion_point(field_get:choreo.Image.is_bigendian)
  return is_bigendian_ != NULL ? *is_bigendian_
                         : *::choreo::Bool::internal_default_instance();
}
inline ::choreo::Bool* Image::mutable_is_bigendian() {
  
  if (is_bigendian_ == NULL) {
    is_bigendian_ = new ::choreo::Bool;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Image.is_bigendian)
  return is_bigendian_;
}
inline ::choreo::Bool* Image::release_is_bigendian() {
  // @@protoc_insertion_point(field_release:choreo.Image.is_bigendian)
  
  ::choreo::Bool* temp = is_bigendian_;
  is_bigendian_ = NULL;
  return temp;
}
inline void Image::set_allocated_is_bigendian(::choreo::Bool* is_bigendian) {
  delete is_bigendian_;
  is_bigendian_ = is_bigendian;
  if (is_bigendian) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Image.is_bigendian)
}

// .choreo.UInt32 step = 6;
inline bool Image::has_step() const {
  return this != internal_default_instance() && step_ != NULL;
}
inline void Image::clear_step() {
  if (GetArenaNoVirtual() == NULL && step_ != NULL) delete step_;
  step_ = NULL;
}
inline const ::choreo::UInt32& Image::step() const {
  // @@protoc_insertion_point(field_get:choreo.Image.step)
  return step_ != NULL ? *step_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* Image::mutable_step() {
  
  if (step_ == NULL) {
    step_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Image.step)
  return step_;
}
inline ::choreo::UInt32* Image::release_step() {
  // @@protoc_insertion_point(field_release:choreo.Image.step)
  
  ::choreo::UInt32* temp = step_;
  step_ = NULL;
  return temp;
}
inline void Image::set_allocated_step(::choreo::UInt32* step) {
  delete step_;
  step_ = step;
  if (step) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Image.step)
}

// repeated .choreo.UInt32 data = 7;
inline int Image::data_size() const {
  return data_.size();
}
inline void Image::clear_data() {
  data_.Clear();
}
inline const ::choreo::UInt32& Image::data(int index) const {
  // @@protoc_insertion_point(field_get:choreo.Image.data)
  return data_.Get(index);
}
inline ::choreo::UInt32* Image::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.Image.data)
  return data_.Mutable(index);
}
inline ::choreo::UInt32* Image::add_data() {
  // @@protoc_insertion_point(field_add:choreo.Image.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::UInt32 >*
Image::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:choreo.Image.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::UInt32 >&
Image::data() const {
  // @@protoc_insertion_point(field_list:choreo.Image.data)
  return data_;
}

// -------------------------------------------------------------------

// ColorRGBA

// .choreo.Float32 r = 1;
inline bool ColorRGBA::has_r() const {
  return this != internal_default_instance() && r_ != NULL;
}
inline void ColorRGBA::clear_r() {
  if (GetArenaNoVirtual() == NULL && r_ != NULL) delete r_;
  r_ = NULL;
}
inline const ::choreo::Float32& ColorRGBA::r() const {
  // @@protoc_insertion_point(field_get:choreo.ColorRGBA.r)
  return r_ != NULL ? *r_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* ColorRGBA::mutable_r() {
  
  if (r_ == NULL) {
    r_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ColorRGBA.r)
  return r_;
}
inline ::choreo::Float32* ColorRGBA::release_r() {
  // @@protoc_insertion_point(field_release:choreo.ColorRGBA.r)
  
  ::choreo::Float32* temp = r_;
  r_ = NULL;
  return temp;
}
inline void ColorRGBA::set_allocated_r(::choreo::Float32* r) {
  delete r_;
  r_ = r;
  if (r) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ColorRGBA.r)
}

// .choreo.Float32 g = 2;
inline bool ColorRGBA::has_g() const {
  return this != internal_default_instance() && g_ != NULL;
}
inline void ColorRGBA::clear_g() {
  if (GetArenaNoVirtual() == NULL && g_ != NULL) delete g_;
  g_ = NULL;
}
inline const ::choreo::Float32& ColorRGBA::g() const {
  // @@protoc_insertion_point(field_get:choreo.ColorRGBA.g)
  return g_ != NULL ? *g_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* ColorRGBA::mutable_g() {
  
  if (g_ == NULL) {
    g_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ColorRGBA.g)
  return g_;
}
inline ::choreo::Float32* ColorRGBA::release_g() {
  // @@protoc_insertion_point(field_release:choreo.ColorRGBA.g)
  
  ::choreo::Float32* temp = g_;
  g_ = NULL;
  return temp;
}
inline void ColorRGBA::set_allocated_g(::choreo::Float32* g) {
  delete g_;
  g_ = g;
  if (g) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ColorRGBA.g)
}

// .choreo.Float32 b = 3;
inline bool ColorRGBA::has_b() const {
  return this != internal_default_instance() && b_ != NULL;
}
inline void ColorRGBA::clear_b() {
  if (GetArenaNoVirtual() == NULL && b_ != NULL) delete b_;
  b_ = NULL;
}
inline const ::choreo::Float32& ColorRGBA::b() const {
  // @@protoc_insertion_point(field_get:choreo.ColorRGBA.b)
  return b_ != NULL ? *b_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* ColorRGBA::mutable_b() {
  
  if (b_ == NULL) {
    b_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ColorRGBA.b)
  return b_;
}
inline ::choreo::Float32* ColorRGBA::release_b() {
  // @@protoc_insertion_point(field_release:choreo.ColorRGBA.b)
  
  ::choreo::Float32* temp = b_;
  b_ = NULL;
  return temp;
}
inline void ColorRGBA::set_allocated_b(::choreo::Float32* b) {
  delete b_;
  b_ = b;
  if (b) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ColorRGBA.b)
}

// .choreo.Float32 a = 4;
inline bool ColorRGBA::has_a() const {
  return this != internal_default_instance() && a_ != NULL;
}
inline void ColorRGBA::clear_a() {
  if (GetArenaNoVirtual() == NULL && a_ != NULL) delete a_;
  a_ = NULL;
}
inline const ::choreo::Float32& ColorRGBA::a() const {
  // @@protoc_insertion_point(field_get:choreo.ColorRGBA.a)
  return a_ != NULL ? *a_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* ColorRGBA::mutable_a() {
  
  if (a_ == NULL) {
    a_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ColorRGBA.a)
  return a_;
}
inline ::choreo::Float32* ColorRGBA::release_a() {
  // @@protoc_insertion_point(field_release:choreo.ColorRGBA.a)
  
  ::choreo::Float32* temp = a_;
  a_ = NULL;
  return temp;
}
inline void ColorRGBA::set_allocated_a(::choreo::Float32* a) {
  delete a_;
  a_ = a;
  if (a) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ColorRGBA.a)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace choreo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sensor_2fcamera_2eproto__INCLUDED
