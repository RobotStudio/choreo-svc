// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor/joint.proto

#ifndef PROTOBUF_sensor_2fjoint_2eproto__INCLUDED
#define PROTOBUF_sensor_2fjoint_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "primitive/float.pb.h"
#include "primitive/header.pb.h"
#include "primitive/string.pb.h"
#include "geometric/transform.pb.h"
#include "geometric/twist.pb.h"
#include "geometric/wrench.pb.h"
// @@protoc_insertion_point(includes)
namespace choreo {
class Float;
class FloatDefaultTypeInternal;
extern FloatDefaultTypeInternal _Float_default_instance_;
class Float32;
class Float32DefaultTypeInternal;
extern Float32DefaultTypeInternal _Float32_default_instance_;
class Float32Array;
class Float32ArrayDefaultTypeInternal;
extern Float32ArrayDefaultTypeInternal _Float32Array_default_instance_;
class Float64;
class Float64DefaultTypeInternal;
extern Float64DefaultTypeInternal _Float64_default_instance_;
class Float64Array;
class Float64ArrayDefaultTypeInternal;
extern Float64ArrayDefaultTypeInternal _Float64Array_default_instance_;
class FloatArray;
class FloatArrayDefaultTypeInternal;
extern FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class JointState;
class JointStateDefaultTypeInternal;
extern JointStateDefaultTypeInternal _JointState_default_instance_;
class MultiDOFJointState;
class MultiDOFJointStateDefaultTypeInternal;
extern MultiDOFJointStateDefaultTypeInternal _MultiDOFJointState_default_instance_;
class String;
class StringDefaultTypeInternal;
extern StringDefaultTypeInternal _String_default_instance_;
class Transform;
class TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
class TransformStamped;
class TransformStampedDefaultTypeInternal;
extern TransformStampedDefaultTypeInternal _TransformStamped_default_instance_;
class Twist;
class TwistDefaultTypeInternal;
extern TwistDefaultTypeInternal _Twist_default_instance_;
class TwistStamped;
class TwistStampedDefaultTypeInternal;
extern TwistStampedDefaultTypeInternal _TwistStamped_default_instance_;
class TwistWithCovariance;
class TwistWithCovarianceDefaultTypeInternal;
extern TwistWithCovarianceDefaultTypeInternal _TwistWithCovariance_default_instance_;
class TwistWithCovarianceStamped;
class TwistWithCovarianceStampedDefaultTypeInternal;
extern TwistWithCovarianceStampedDefaultTypeInternal _TwistWithCovarianceStamped_default_instance_;
class Wrench;
class WrenchDefaultTypeInternal;
extern WrenchDefaultTypeInternal _Wrench_default_instance_;
class WrenchStamped;
class WrenchStampedDefaultTypeInternal;
extern WrenchStampedDefaultTypeInternal _WrenchStamped_default_instance_;
}  // namespace choreo

namespace choreo {

namespace protobuf_sensor_2fjoint_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_sensor_2fjoint_2eproto

// ===================================================================

class JointState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.JointState) */ {
 public:
  JointState();
  virtual ~JointState();

  JointState(const JointState& from);

  inline JointState& operator=(const JointState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JointState& default_instance();

  static inline const JointState* internal_default_instance() {
    return reinterpret_cast<const JointState*>(
               &_JointState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(JointState* other);

  // implements Message ----------------------------------------------

  inline JointState* New() const PROTOBUF_FINAL { return New(NULL); }

  JointState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JointState& from);
  void MergeFrom(const JointState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JointState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.String names = 2;
  int names_size() const;
  void clear_names();
  static const int kNamesFieldNumber = 2;
  const ::choreo::String& names(int index) const;
  ::choreo::String* mutable_names(int index);
  ::choreo::String* add_names();
  ::google::protobuf::RepeatedPtrField< ::choreo::String >*
      mutable_names();
  const ::google::protobuf::RepeatedPtrField< ::choreo::String >&
      names() const;

  // repeated .choreo.Float64 positions = 3;
  int positions_size() const;
  void clear_positions();
  static const int kPositionsFieldNumber = 3;
  const ::choreo::Float64& positions(int index) const;
  ::choreo::Float64* mutable_positions(int index);
  ::choreo::Float64* add_positions();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
      mutable_positions();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
      positions() const;

  // repeated .choreo.Float64 velocities = 4;
  int velocities_size() const;
  void clear_velocities();
  static const int kVelocitiesFieldNumber = 4;
  const ::choreo::Float64& velocities(int index) const;
  ::choreo::Float64* mutable_velocities(int index);
  ::choreo::Float64* add_velocities();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
      mutable_velocities();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
      velocities() const;

  // repeated .choreo.Float64 efforts = 5;
  int efforts_size() const;
  void clear_efforts();
  static const int kEffortsFieldNumber = 5;
  const ::choreo::Float64& efforts(int index) const;
  ::choreo::Float64* mutable_efforts(int index);
  ::choreo::Float64* add_efforts();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
      mutable_efforts();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
      efforts() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // @@protoc_insertion_point(class_scope:choreo.JointState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::String > names_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 > positions_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 > velocities_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float64 > efforts_;
  ::choreo::Header* header_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fjoint_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiDOFJointState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.MultiDOFJointState) */ {
 public:
  MultiDOFJointState();
  virtual ~MultiDOFJointState();

  MultiDOFJointState(const MultiDOFJointState& from);

  inline MultiDOFJointState& operator=(const MultiDOFJointState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiDOFJointState& default_instance();

  static inline const MultiDOFJointState* internal_default_instance() {
    return reinterpret_cast<const MultiDOFJointState*>(
               &_MultiDOFJointState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MultiDOFJointState* other);

  // implements Message ----------------------------------------------

  inline MultiDOFJointState* New() const PROTOBUF_FINAL { return New(NULL); }

  MultiDOFJointState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MultiDOFJointState& from);
  void MergeFrom(const MultiDOFJointState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MultiDOFJointState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.Transform transforms = 2;
  int transforms_size() const;
  void clear_transforms();
  static const int kTransformsFieldNumber = 2;
  const ::choreo::Transform& transforms(int index) const;
  ::choreo::Transform* mutable_transforms(int index);
  ::choreo::Transform* add_transforms();
  ::google::protobuf::RepeatedPtrField< ::choreo::Transform >*
      mutable_transforms();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Transform >&
      transforms() const;

  // repeated .choreo.Twist twists = 3;
  int twists_size() const;
  void clear_twists();
  static const int kTwistsFieldNumber = 3;
  const ::choreo::Twist& twists(int index) const;
  ::choreo::Twist* mutable_twists(int index);
  ::choreo::Twist* add_twists();
  ::google::protobuf::RepeatedPtrField< ::choreo::Twist >*
      mutable_twists();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Twist >&
      twists() const;

  // repeated .choreo.Wrench wrenches = 4;
  int wrenches_size() const;
  void clear_wrenches();
  static const int kWrenchesFieldNumber = 4;
  const ::choreo::Wrench& wrenches(int index) const;
  ::choreo::Wrench* mutable_wrenches(int index);
  ::choreo::Wrench* add_wrenches();
  ::google::protobuf::RepeatedPtrField< ::choreo::Wrench >*
      mutable_wrenches();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Wrench >&
      wrenches() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // @@protoc_insertion_point(class_scope:choreo.MultiDOFJointState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Transform > transforms_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Twist > twists_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Wrench > wrenches_;
  ::choreo::Header* header_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fjoint_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// JointState

// .choreo.Header header = 1;
inline bool JointState::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void JointState::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& JointState::header() const {
  // @@protoc_insertion_point(field_get:choreo.JointState.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* JointState::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.JointState.header)
  return header_;
}
inline ::choreo::Header* JointState::release_header() {
  // @@protoc_insertion_point(field_release:choreo.JointState.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void JointState::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.JointState.header)
}

// repeated .choreo.String names = 2;
inline int JointState::names_size() const {
  return names_.size();
}
inline void JointState::clear_names() {
  names_.Clear();
}
inline const ::choreo::String& JointState::names(int index) const {
  // @@protoc_insertion_point(field_get:choreo.JointState.names)
  return names_.Get(index);
}
inline ::choreo::String* JointState::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.JointState.names)
  return names_.Mutable(index);
}
inline ::choreo::String* JointState::add_names() {
  // @@protoc_insertion_point(field_add:choreo.JointState.names)
  return names_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::String >*
JointState::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:choreo.JointState.names)
  return &names_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::String >&
JointState::names() const {
  // @@protoc_insertion_point(field_list:choreo.JointState.names)
  return names_;
}

// repeated .choreo.Float64 positions = 3;
inline int JointState::positions_size() const {
  return positions_.size();
}
inline void JointState::clear_positions() {
  positions_.Clear();
}
inline const ::choreo::Float64& JointState::positions(int index) const {
  // @@protoc_insertion_point(field_get:choreo.JointState.positions)
  return positions_.Get(index);
}
inline ::choreo::Float64* JointState::mutable_positions(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.JointState.positions)
  return positions_.Mutable(index);
}
inline ::choreo::Float64* JointState::add_positions() {
  // @@protoc_insertion_point(field_add:choreo.JointState.positions)
  return positions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
JointState::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:choreo.JointState.positions)
  return &positions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
JointState::positions() const {
  // @@protoc_insertion_point(field_list:choreo.JointState.positions)
  return positions_;
}

// repeated .choreo.Float64 velocities = 4;
inline int JointState::velocities_size() const {
  return velocities_.size();
}
inline void JointState::clear_velocities() {
  velocities_.Clear();
}
inline const ::choreo::Float64& JointState::velocities(int index) const {
  // @@protoc_insertion_point(field_get:choreo.JointState.velocities)
  return velocities_.Get(index);
}
inline ::choreo::Float64* JointState::mutable_velocities(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.JointState.velocities)
  return velocities_.Mutable(index);
}
inline ::choreo::Float64* JointState::add_velocities() {
  // @@protoc_insertion_point(field_add:choreo.JointState.velocities)
  return velocities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
JointState::mutable_velocities() {
  // @@protoc_insertion_point(field_mutable_list:choreo.JointState.velocities)
  return &velocities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
JointState::velocities() const {
  // @@protoc_insertion_point(field_list:choreo.JointState.velocities)
  return velocities_;
}

// repeated .choreo.Float64 efforts = 5;
inline int JointState::efforts_size() const {
  return efforts_.size();
}
inline void JointState::clear_efforts() {
  efforts_.Clear();
}
inline const ::choreo::Float64& JointState::efforts(int index) const {
  // @@protoc_insertion_point(field_get:choreo.JointState.efforts)
  return efforts_.Get(index);
}
inline ::choreo::Float64* JointState::mutable_efforts(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.JointState.efforts)
  return efforts_.Mutable(index);
}
inline ::choreo::Float64* JointState::add_efforts() {
  // @@protoc_insertion_point(field_add:choreo.JointState.efforts)
  return efforts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
JointState::mutable_efforts() {
  // @@protoc_insertion_point(field_mutable_list:choreo.JointState.efforts)
  return &efforts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
JointState::efforts() const {
  // @@protoc_insertion_point(field_list:choreo.JointState.efforts)
  return efforts_;
}

// -------------------------------------------------------------------

// MultiDOFJointState

// .choreo.Header header = 1;
inline bool MultiDOFJointState::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void MultiDOFJointState::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& MultiDOFJointState::header() const {
  // @@protoc_insertion_point(field_get:choreo.MultiDOFJointState.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* MultiDOFJointState::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiDOFJointState.header)
  return header_;
}
inline ::choreo::Header* MultiDOFJointState::release_header() {
  // @@protoc_insertion_point(field_release:choreo.MultiDOFJointState.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void MultiDOFJointState::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiDOFJointState.header)
}

// repeated .choreo.Transform transforms = 2;
inline int MultiDOFJointState::transforms_size() const {
  return transforms_.size();
}
inline void MultiDOFJointState::clear_transforms() {
  transforms_.Clear();
}
inline const ::choreo::Transform& MultiDOFJointState::transforms(int index) const {
  // @@protoc_insertion_point(field_get:choreo.MultiDOFJointState.transforms)
  return transforms_.Get(index);
}
inline ::choreo::Transform* MultiDOFJointState::mutable_transforms(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.MultiDOFJointState.transforms)
  return transforms_.Mutable(index);
}
inline ::choreo::Transform* MultiDOFJointState::add_transforms() {
  // @@protoc_insertion_point(field_add:choreo.MultiDOFJointState.transforms)
  return transforms_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Transform >*
MultiDOFJointState::mutable_transforms() {
  // @@protoc_insertion_point(field_mutable_list:choreo.MultiDOFJointState.transforms)
  return &transforms_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Transform >&
MultiDOFJointState::transforms() const {
  // @@protoc_insertion_point(field_list:choreo.MultiDOFJointState.transforms)
  return transforms_;
}

// repeated .choreo.Twist twists = 3;
inline int MultiDOFJointState::twists_size() const {
  return twists_.size();
}
inline void MultiDOFJointState::clear_twists() {
  twists_.Clear();
}
inline const ::choreo::Twist& MultiDOFJointState::twists(int index) const {
  // @@protoc_insertion_point(field_get:choreo.MultiDOFJointState.twists)
  return twists_.Get(index);
}
inline ::choreo::Twist* MultiDOFJointState::mutable_twists(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.MultiDOFJointState.twists)
  return twists_.Mutable(index);
}
inline ::choreo::Twist* MultiDOFJointState::add_twists() {
  // @@protoc_insertion_point(field_add:choreo.MultiDOFJointState.twists)
  return twists_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Twist >*
MultiDOFJointState::mutable_twists() {
  // @@protoc_insertion_point(field_mutable_list:choreo.MultiDOFJointState.twists)
  return &twists_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Twist >&
MultiDOFJointState::twists() const {
  // @@protoc_insertion_point(field_list:choreo.MultiDOFJointState.twists)
  return twists_;
}

// repeated .choreo.Wrench wrenches = 4;
inline int MultiDOFJointState::wrenches_size() const {
  return wrenches_.size();
}
inline void MultiDOFJointState::clear_wrenches() {
  wrenches_.Clear();
}
inline const ::choreo::Wrench& MultiDOFJointState::wrenches(int index) const {
  // @@protoc_insertion_point(field_get:choreo.MultiDOFJointState.wrenches)
  return wrenches_.Get(index);
}
inline ::choreo::Wrench* MultiDOFJointState::mutable_wrenches(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.MultiDOFJointState.wrenches)
  return wrenches_.Mutable(index);
}
inline ::choreo::Wrench* MultiDOFJointState::add_wrenches() {
  // @@protoc_insertion_point(field_add:choreo.MultiDOFJointState.wrenches)
  return wrenches_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Wrench >*
MultiDOFJointState::mutable_wrenches() {
  // @@protoc_insertion_point(field_mutable_list:choreo.MultiDOFJointState.wrenches)
  return &wrenches_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Wrench >&
MultiDOFJointState::wrenches() const {
  // @@protoc_insertion_point(field_list:choreo.MultiDOFJointState.wrenches)
  return wrenches_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace choreo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sensor_2fjoint_2eproto__INCLUDED
