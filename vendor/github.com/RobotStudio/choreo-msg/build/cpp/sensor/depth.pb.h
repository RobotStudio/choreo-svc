// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor/depth.proto

#ifndef PROTOBUF_sensor_2fdepth_2eproto__INCLUDED
#define PROTOBUF_sensor_2fdepth_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "primitive/bool.pb.h"
#include "primitive/bytes.pb.h"
#include "primitive/float.pb.h"
#include "primitive/header.pb.h"
#include "primitive/int.pb.h"
#include "primitive/string.pb.h"
#include "geometric/point.pb.h"
#include "sensor/camera.pb.h"
// @@protoc_insertion_point(includes)
namespace choreo {
class Bool;
class BoolDefaultTypeInternal;
extern BoolDefaultTypeInternal _Bool_default_instance_;
class BoolArray;
class BoolArrayDefaultTypeInternal;
extern BoolArrayDefaultTypeInternal _BoolArray_default_instance_;
class Bytes;
class BytesDefaultTypeInternal;
extern BytesDefaultTypeInternal _Bytes_default_instance_;
class CameraInfo;
class CameraInfoDefaultTypeInternal;
extern CameraInfoDefaultTypeInternal _CameraInfo_default_instance_;
class ChannelFloat32;
class ChannelFloat32DefaultTypeInternal;
extern ChannelFloat32DefaultTypeInternal _ChannelFloat32_default_instance_;
class ColorRGBA;
class ColorRGBADefaultTypeInternal;
extern ColorRGBADefaultTypeInternal _ColorRGBA_default_instance_;
class CompressedImage;
class CompressedImageDefaultTypeInternal;
extern CompressedImageDefaultTypeInternal _CompressedImage_default_instance_;
class Float;
class FloatDefaultTypeInternal;
extern FloatDefaultTypeInternal _Float_default_instance_;
class Float32;
class Float32DefaultTypeInternal;
extern Float32DefaultTypeInternal _Float32_default_instance_;
class Float32Array;
class Float32ArrayDefaultTypeInternal;
extern Float32ArrayDefaultTypeInternal _Float32Array_default_instance_;
class Float64;
class Float64DefaultTypeInternal;
extern Float64DefaultTypeInternal _Float64_default_instance_;
class Float64Array;
class Float64ArrayDefaultTypeInternal;
extern Float64ArrayDefaultTypeInternal _Float64Array_default_instance_;
class FloatArray;
class FloatArrayDefaultTypeInternal;
extern FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class Int32;
class Int32DefaultTypeInternal;
extern Int32DefaultTypeInternal _Int32_default_instance_;
class Int32Array;
class Int32ArrayDefaultTypeInternal;
extern Int32ArrayDefaultTypeInternal _Int32Array_default_instance_;
class Int64;
class Int64DefaultTypeInternal;
extern Int64DefaultTypeInternal _Int64_default_instance_;
class Int64Array;
class Int64ArrayDefaultTypeInternal;
extern Int64ArrayDefaultTypeInternal _Int64Array_default_instance_;
class LaserEcho;
class LaserEchoDefaultTypeInternal;
extern LaserEchoDefaultTypeInternal _LaserEcho_default_instance_;
class LaserScan;
class LaserScanDefaultTypeInternal;
extern LaserScanDefaultTypeInternal _LaserScan_default_instance_;
class MultiEchoLaserScan;
class MultiEchoLaserScanDefaultTypeInternal;
extern MultiEchoLaserScanDefaultTypeInternal _MultiEchoLaserScan_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Point32;
class Point32DefaultTypeInternal;
extern Point32DefaultTypeInternal _Point32_default_instance_;
class Point32Stamped;
class Point32StampedDefaultTypeInternal;
extern Point32StampedDefaultTypeInternal _Point32Stamped_default_instance_;
class PointCloud;
class PointCloudDefaultTypeInternal;
extern PointCloudDefaultTypeInternal _PointCloud_default_instance_;
class PointCloud2;
class PointCloud2DefaultTypeInternal;
extern PointCloud2DefaultTypeInternal _PointCloud2_default_instance_;
class PointField;
class PointFieldDefaultTypeInternal;
extern PointFieldDefaultTypeInternal _PointField_default_instance_;
class PointStamped;
class PointStampedDefaultTypeInternal;
extern PointStampedDefaultTypeInternal _PointStamped_default_instance_;
class Range;
class RangeDefaultTypeInternal;
extern RangeDefaultTypeInternal _Range_default_instance_;
class RegionOfInterest;
class RegionOfInterestDefaultTypeInternal;
extern RegionOfInterestDefaultTypeInternal _RegionOfInterest_default_instance_;
class SInt32;
class SInt32DefaultTypeInternal;
extern SInt32DefaultTypeInternal _SInt32_default_instance_;
class SInt32Array;
class SInt32ArrayDefaultTypeInternal;
extern SInt32ArrayDefaultTypeInternal _SInt32Array_default_instance_;
class SInt64;
class SInt64DefaultTypeInternal;
extern SInt64DefaultTypeInternal _SInt64_default_instance_;
class SInt64Array;
class SInt64ArrayDefaultTypeInternal;
extern SInt64ArrayDefaultTypeInternal _SInt64Array_default_instance_;
class String;
class StringDefaultTypeInternal;
extern StringDefaultTypeInternal _String_default_instance_;
class UInt32;
class UInt32DefaultTypeInternal;
extern UInt32DefaultTypeInternal _UInt32_default_instance_;
class UInt32Array;
class UInt32ArrayDefaultTypeInternal;
extern UInt32ArrayDefaultTypeInternal _UInt32Array_default_instance_;
class UInt64;
class UInt64DefaultTypeInternal;
extern UInt64DefaultTypeInternal _UInt64_default_instance_;
class UInt64Array;
class UInt64ArrayDefaultTypeInternal;
extern UInt64ArrayDefaultTypeInternal _UInt64Array_default_instance_;
}  // namespace choreo

namespace choreo {

namespace protobuf_sensor_2fdepth_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_sensor_2fdepth_2eproto

enum PointField_Datatype {
  PointField_Datatype_INT8 = 0,
  PointField_Datatype_UINT8 = 1,
  PointField_Datatype_INT16 = 2,
  PointField_Datatype_UINT16 = 3,
  PointField_Datatype_INT32 = 4,
  PointField_Datatype_UINT32 = 5,
  PointField_Datatype_FLOAT32 = 6,
  PointField_Datatype_FLOAT64 = 7,
  PointField_Datatype_PointField_Datatype_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PointField_Datatype_PointField_Datatype_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PointField_Datatype_IsValid(int value);
const PointField_Datatype PointField_Datatype_Datatype_MIN = PointField_Datatype_INT8;
const PointField_Datatype PointField_Datatype_Datatype_MAX = PointField_Datatype_FLOAT64;
const int PointField_Datatype_Datatype_ARRAYSIZE = PointField_Datatype_Datatype_MAX + 1;

const ::google::protobuf::EnumDescriptor* PointField_Datatype_descriptor();
inline const ::std::string& PointField_Datatype_Name(PointField_Datatype value) {
  return ::google::protobuf::internal::NameOfEnum(
    PointField_Datatype_descriptor(), value);
}
inline bool PointField_Datatype_Parse(
    const ::std::string& name, PointField_Datatype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PointField_Datatype>(
    PointField_Datatype_descriptor(), name, value);
}
enum Range_RadiationType {
  Range_RadiationType_ULTRASOUND = 0,
  Range_RadiationType_INFRARED = 1,
  Range_RadiationType_Range_RadiationType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Range_RadiationType_Range_RadiationType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Range_RadiationType_IsValid(int value);
const Range_RadiationType Range_RadiationType_RadiationType_MIN = Range_RadiationType_ULTRASOUND;
const Range_RadiationType Range_RadiationType_RadiationType_MAX = Range_RadiationType_INFRARED;
const int Range_RadiationType_RadiationType_ARRAYSIZE = Range_RadiationType_RadiationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Range_RadiationType_descriptor();
inline const ::std::string& Range_RadiationType_Name(Range_RadiationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Range_RadiationType_descriptor(), value);
}
inline bool Range_RadiationType_Parse(
    const ::std::string& name, Range_RadiationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Range_RadiationType>(
    Range_RadiationType_descriptor(), name, value);
}
// ===================================================================

class LaserEcho : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.LaserEcho) */ {
 public:
  LaserEcho();
  virtual ~LaserEcho();

  LaserEcho(const LaserEcho& from);

  inline LaserEcho& operator=(const LaserEcho& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaserEcho& default_instance();

  static inline const LaserEcho* internal_default_instance() {
    return reinterpret_cast<const LaserEcho*>(
               &_LaserEcho_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LaserEcho* other);

  // implements Message ----------------------------------------------

  inline LaserEcho* New() const PROTOBUF_FINAL { return New(NULL); }

  LaserEcho* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaserEcho& from);
  void MergeFrom(const LaserEcho& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaserEcho* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.Float32 echoes = 1;
  int echoes_size() const;
  void clear_echoes();
  static const int kEchoesFieldNumber = 1;
  const ::choreo::Float32& echoes(int index) const;
  ::choreo::Float32* mutable_echoes(int index);
  ::choreo::Float32* add_echoes();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >*
      mutable_echoes();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >&
      echoes() const;

  // @@protoc_insertion_point(class_scope:choreo.LaserEcho)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float32 > echoes_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fdepth_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaserScan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.LaserScan) */ {
 public:
  LaserScan();
  virtual ~LaserScan();

  LaserScan(const LaserScan& from);

  inline LaserScan& operator=(const LaserScan& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaserScan& default_instance();

  static inline const LaserScan* internal_default_instance() {
    return reinterpret_cast<const LaserScan*>(
               &_LaserScan_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(LaserScan* other);

  // implements Message ----------------------------------------------

  inline LaserScan* New() const PROTOBUF_FINAL { return New(NULL); }

  LaserScan* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaserScan& from);
  void MergeFrom(const LaserScan& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaserScan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.Float32 ranges = 9;
  int ranges_size() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 9;
  const ::choreo::Float32& ranges(int index) const;
  ::choreo::Float32* mutable_ranges(int index);
  ::choreo::Float32* add_ranges();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >*
      mutable_ranges();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >&
      ranges() const;

  // repeated .choreo.Float32 intensities = 10;
  int intensities_size() const;
  void clear_intensities();
  static const int kIntensitiesFieldNumber = 10;
  const ::choreo::Float32& intensities(int index) const;
  ::choreo::Float32* mutable_intensities(int index);
  ::choreo::Float32* add_intensities();
  ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >*
      mutable_intensities();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >&
      intensities() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.Float32 angle_min = 2;
  bool has_angle_min() const;
  void clear_angle_min();
  static const int kAngleMinFieldNumber = 2;
  const ::choreo::Float32& angle_min() const;
  ::choreo::Float32* mutable_angle_min();
  ::choreo::Float32* release_angle_min();
  void set_allocated_angle_min(::choreo::Float32* angle_min);

  // .choreo.Float32 angle_max = 3;
  bool has_angle_max() const;
  void clear_angle_max();
  static const int kAngleMaxFieldNumber = 3;
  const ::choreo::Float32& angle_max() const;
  ::choreo::Float32* mutable_angle_max();
  ::choreo::Float32* release_angle_max();
  void set_allocated_angle_max(::choreo::Float32* angle_max);

  // .choreo.Float32 angle_increment = 4;
  bool has_angle_increment() const;
  void clear_angle_increment();
  static const int kAngleIncrementFieldNumber = 4;
  const ::choreo::Float32& angle_increment() const;
  ::choreo::Float32* mutable_angle_increment();
  ::choreo::Float32* release_angle_increment();
  void set_allocated_angle_increment(::choreo::Float32* angle_increment);

  // .choreo.Float32 time_increment = 5;
  bool has_time_increment() const;
  void clear_time_increment();
  static const int kTimeIncrementFieldNumber = 5;
  const ::choreo::Float32& time_increment() const;
  ::choreo::Float32* mutable_time_increment();
  ::choreo::Float32* release_time_increment();
  void set_allocated_time_increment(::choreo::Float32* time_increment);

  // .choreo.Float32 scan_time = 6;
  bool has_scan_time() const;
  void clear_scan_time();
  static const int kScanTimeFieldNumber = 6;
  const ::choreo::Float32& scan_time() const;
  ::choreo::Float32* mutable_scan_time();
  ::choreo::Float32* release_scan_time();
  void set_allocated_scan_time(::choreo::Float32* scan_time);

  // .choreo.Float32 range_min = 7;
  bool has_range_min() const;
  void clear_range_min();
  static const int kRangeMinFieldNumber = 7;
  const ::choreo::Float32& range_min() const;
  ::choreo::Float32* mutable_range_min();
  ::choreo::Float32* release_range_min();
  void set_allocated_range_min(::choreo::Float32* range_min);

  // .choreo.Float32 range_max = 8;
  bool has_range_max() const;
  void clear_range_max();
  static const int kRangeMaxFieldNumber = 8;
  const ::choreo::Float32& range_max() const;
  ::choreo::Float32* mutable_range_max();
  ::choreo::Float32* release_range_max();
  void set_allocated_range_max(::choreo::Float32* range_max);

  // @@protoc_insertion_point(class_scope:choreo.LaserScan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float32 > ranges_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Float32 > intensities_;
  ::choreo::Header* header_;
  ::choreo::Float32* angle_min_;
  ::choreo::Float32* angle_max_;
  ::choreo::Float32* angle_increment_;
  ::choreo::Float32* time_increment_;
  ::choreo::Float32* scan_time_;
  ::choreo::Float32* range_min_;
  ::choreo::Float32* range_max_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fdepth_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiEchoLaserScan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.MultiEchoLaserScan) */ {
 public:
  MultiEchoLaserScan();
  virtual ~MultiEchoLaserScan();

  MultiEchoLaserScan(const MultiEchoLaserScan& from);

  inline MultiEchoLaserScan& operator=(const MultiEchoLaserScan& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiEchoLaserScan& default_instance();

  static inline const MultiEchoLaserScan* internal_default_instance() {
    return reinterpret_cast<const MultiEchoLaserScan*>(
               &_MultiEchoLaserScan_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(MultiEchoLaserScan* other);

  // implements Message ----------------------------------------------

  inline MultiEchoLaserScan* New() const PROTOBUF_FINAL { return New(NULL); }

  MultiEchoLaserScan* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MultiEchoLaserScan& from);
  void MergeFrom(const MultiEchoLaserScan& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MultiEchoLaserScan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.LaserEcho ranges = 9;
  int ranges_size() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 9;
  const ::choreo::LaserEcho& ranges(int index) const;
  ::choreo::LaserEcho* mutable_ranges(int index);
  ::choreo::LaserEcho* add_ranges();
  ::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho >*
      mutable_ranges();
  const ::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho >&
      ranges() const;

  // repeated .choreo.LaserEcho intensities = 10;
  int intensities_size() const;
  void clear_intensities();
  static const int kIntensitiesFieldNumber = 10;
  const ::choreo::LaserEcho& intensities(int index) const;
  ::choreo::LaserEcho* mutable_intensities(int index);
  ::choreo::LaserEcho* add_intensities();
  ::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho >*
      mutable_intensities();
  const ::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho >&
      intensities() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.Float32 angle_min = 2;
  bool has_angle_min() const;
  void clear_angle_min();
  static const int kAngleMinFieldNumber = 2;
  const ::choreo::Float32& angle_min() const;
  ::choreo::Float32* mutable_angle_min();
  ::choreo::Float32* release_angle_min();
  void set_allocated_angle_min(::choreo::Float32* angle_min);

  // .choreo.Float32 angle_max = 3;
  bool has_angle_max() const;
  void clear_angle_max();
  static const int kAngleMaxFieldNumber = 3;
  const ::choreo::Float32& angle_max() const;
  ::choreo::Float32* mutable_angle_max();
  ::choreo::Float32* release_angle_max();
  void set_allocated_angle_max(::choreo::Float32* angle_max);

  // .choreo.Float32 angle_increment = 4;
  bool has_angle_increment() const;
  void clear_angle_increment();
  static const int kAngleIncrementFieldNumber = 4;
  const ::choreo::Float32& angle_increment() const;
  ::choreo::Float32* mutable_angle_increment();
  ::choreo::Float32* release_angle_increment();
  void set_allocated_angle_increment(::choreo::Float32* angle_increment);

  // .choreo.Float32 time_increment = 5;
  bool has_time_increment() const;
  void clear_time_increment();
  static const int kTimeIncrementFieldNumber = 5;
  const ::choreo::Float32& time_increment() const;
  ::choreo::Float32* mutable_time_increment();
  ::choreo::Float32* release_time_increment();
  void set_allocated_time_increment(::choreo::Float32* time_increment);

  // .choreo.Float32 scan_time = 6;
  bool has_scan_time() const;
  void clear_scan_time();
  static const int kScanTimeFieldNumber = 6;
  const ::choreo::Float32& scan_time() const;
  ::choreo::Float32* mutable_scan_time();
  ::choreo::Float32* release_scan_time();
  void set_allocated_scan_time(::choreo::Float32* scan_time);

  // .choreo.Float32 range_min = 7;
  bool has_range_min() const;
  void clear_range_min();
  static const int kRangeMinFieldNumber = 7;
  const ::choreo::Float32& range_min() const;
  ::choreo::Float32* mutable_range_min();
  ::choreo::Float32* release_range_min();
  void set_allocated_range_min(::choreo::Float32* range_min);

  // .choreo.Float32 range_max = 8;
  bool has_range_max() const;
  void clear_range_max();
  static const int kRangeMaxFieldNumber = 8;
  const ::choreo::Float32& range_max() const;
  ::choreo::Float32* mutable_range_max();
  ::choreo::Float32* release_range_max();
  void set_allocated_range_max(::choreo::Float32* range_max);

  // @@protoc_insertion_point(class_scope:choreo.MultiEchoLaserScan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho > ranges_;
  ::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho > intensities_;
  ::choreo::Header* header_;
  ::choreo::Float32* angle_min_;
  ::choreo::Float32* angle_max_;
  ::choreo::Float32* angle_increment_;
  ::choreo::Float32* time_increment_;
  ::choreo::Float32* scan_time_;
  ::choreo::Float32* range_min_;
  ::choreo::Float32* range_max_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fdepth_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PointField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.PointField) */ {
 public:
  PointField();
  virtual ~PointField();

  PointField(const PointField& from);

  inline PointField& operator=(const PointField& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointField& default_instance();

  static inline const PointField* internal_default_instance() {
    return reinterpret_cast<const PointField*>(
               &_PointField_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(PointField* other);

  // implements Message ----------------------------------------------

  inline PointField* New() const PROTOBUF_FINAL { return New(NULL); }

  PointField* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PointField& from);
  void MergeFrom(const PointField& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PointField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PointField_Datatype Datatype;
  static const Datatype INT8 =
    PointField_Datatype_INT8;
  static const Datatype UINT8 =
    PointField_Datatype_UINT8;
  static const Datatype INT16 =
    PointField_Datatype_INT16;
  static const Datatype UINT16 =
    PointField_Datatype_UINT16;
  static const Datatype INT32 =
    PointField_Datatype_INT32;
  static const Datatype UINT32 =
    PointField_Datatype_UINT32;
  static const Datatype FLOAT32 =
    PointField_Datatype_FLOAT32;
  static const Datatype FLOAT64 =
    PointField_Datatype_FLOAT64;
  static inline bool Datatype_IsValid(int value) {
    return PointField_Datatype_IsValid(value);
  }
  static const Datatype Datatype_MIN =
    PointField_Datatype_Datatype_MIN;
  static const Datatype Datatype_MAX =
    PointField_Datatype_Datatype_MAX;
  static const int Datatype_ARRAYSIZE =
    PointField_Datatype_Datatype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Datatype_descriptor() {
    return PointField_Datatype_descriptor();
  }
  static inline const ::std::string& Datatype_Name(Datatype value) {
    return PointField_Datatype_Name(value);
  }
  static inline bool Datatype_Parse(const ::std::string& name,
      Datatype* value) {
    return PointField_Datatype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .choreo.String name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::choreo::String& name() const;
  ::choreo::String* mutable_name();
  ::choreo::String* release_name();
  void set_allocated_name(::choreo::String* name);

  // .choreo.UInt32 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  const ::choreo::UInt32& offset() const;
  ::choreo::UInt32* mutable_offset();
  ::choreo::UInt32* release_offset();
  void set_allocated_offset(::choreo::UInt32* offset);

  // .choreo.UInt32 count = 4;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 4;
  const ::choreo::UInt32& count() const;
  ::choreo::UInt32* mutable_count();
  ::choreo::UInt32* release_count();
  void set_allocated_count(::choreo::UInt32* count);

  // .choreo.PointField.Datatype datatype = 3;
  void clear_datatype();
  static const int kDatatypeFieldNumber = 3;
  ::choreo::PointField_Datatype datatype() const;
  void set_datatype(::choreo::PointField_Datatype value);

  // @@protoc_insertion_point(class_scope:choreo.PointField)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::String* name_;
  ::choreo::UInt32* offset_;
  ::choreo::UInt32* count_;
  int datatype_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fdepth_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PointCloud : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.PointCloud) */ {
 public:
  PointCloud();
  virtual ~PointCloud();

  PointCloud(const PointCloud& from);

  inline PointCloud& operator=(const PointCloud& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloud& default_instance();

  static inline const PointCloud* internal_default_instance() {
    return reinterpret_cast<const PointCloud*>(
               &_PointCloud_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(PointCloud* other);

  // implements Message ----------------------------------------------

  inline PointCloud* New() const PROTOBUF_FINAL { return New(NULL); }

  PointCloud* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PointCloud& from);
  void MergeFrom(const PointCloud& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PointCloud* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.Point32 points = 2;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 2;
  const ::choreo::Point32& points(int index) const;
  ::choreo::Point32* mutable_points(int index);
  ::choreo::Point32* add_points();
  ::google::protobuf::RepeatedPtrField< ::choreo::Point32 >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Point32 >&
      points() const;

  // repeated .choreo.ChannelFloat32 channels = 3;
  int channels_size() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 3;
  const ::choreo::ChannelFloat32& channels(int index) const;
  ::choreo::ChannelFloat32* mutable_channels(int index);
  ::choreo::ChannelFloat32* add_channels();
  ::google::protobuf::RepeatedPtrField< ::choreo::ChannelFloat32 >*
      mutable_channels();
  const ::google::protobuf::RepeatedPtrField< ::choreo::ChannelFloat32 >&
      channels() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // @@protoc_insertion_point(class_scope:choreo.PointCloud)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Point32 > points_;
  ::google::protobuf::RepeatedPtrField< ::choreo::ChannelFloat32 > channels_;
  ::choreo::Header* header_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fdepth_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PointCloud2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.PointCloud2) */ {
 public:
  PointCloud2();
  virtual ~PointCloud2();

  PointCloud2(const PointCloud2& from);

  inline PointCloud2& operator=(const PointCloud2& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloud2& default_instance();

  static inline const PointCloud2* internal_default_instance() {
    return reinterpret_cast<const PointCloud2*>(
               &_PointCloud2_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(PointCloud2* other);

  // implements Message ----------------------------------------------

  inline PointCloud2* New() const PROTOBUF_FINAL { return New(NULL); }

  PointCloud2* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PointCloud2& from);
  void MergeFrom(const PointCloud2& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PointCloud2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.PointField fields = 4;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 4;
  const ::choreo::PointField& fields(int index) const;
  ::choreo::PointField* mutable_fields(int index);
  ::choreo::PointField* add_fields();
  ::google::protobuf::RepeatedPtrField< ::choreo::PointField >*
      mutable_fields();
  const ::google::protobuf::RepeatedPtrField< ::choreo::PointField >&
      fields() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.UInt32 height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  const ::choreo::UInt32& height() const;
  ::choreo::UInt32* mutable_height();
  ::choreo::UInt32* release_height();
  void set_allocated_height(::choreo::UInt32* height);

  // .choreo.UInt32 width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  const ::choreo::UInt32& width() const;
  ::choreo::UInt32* mutable_width();
  ::choreo::UInt32* release_width();
  void set_allocated_width(::choreo::UInt32* width);

  // .choreo.Bool is_bigendian = 5;
  bool has_is_bigendian() const;
  void clear_is_bigendian();
  static const int kIsBigendianFieldNumber = 5;
  const ::choreo::Bool& is_bigendian() const;
  ::choreo::Bool* mutable_is_bigendian();
  ::choreo::Bool* release_is_bigendian();
  void set_allocated_is_bigendian(::choreo::Bool* is_bigendian);

  // .choreo.UInt32 point_step = 6;
  bool has_point_step() const;
  void clear_point_step();
  static const int kPointStepFieldNumber = 6;
  const ::choreo::UInt32& point_step() const;
  ::choreo::UInt32* mutable_point_step();
  ::choreo::UInt32* release_point_step();
  void set_allocated_point_step(::choreo::UInt32* point_step);

  // .choreo.UInt32 row_step = 7;
  bool has_row_step() const;
  void clear_row_step();
  static const int kRowStepFieldNumber = 7;
  const ::choreo::UInt32& row_step() const;
  ::choreo::UInt32* mutable_row_step();
  ::choreo::UInt32* release_row_step();
  void set_allocated_row_step(::choreo::UInt32* row_step);

  // .choreo.Bytes data = 8;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 8;
  const ::choreo::Bytes& data() const;
  ::choreo::Bytes* mutable_data();
  ::choreo::Bytes* release_data();
  void set_allocated_data(::choreo::Bytes* data);

  // .choreo.Bool is_dense = 9;
  bool has_is_dense() const;
  void clear_is_dense();
  static const int kIsDenseFieldNumber = 9;
  const ::choreo::Bool& is_dense() const;
  ::choreo::Bool* mutable_is_dense();
  ::choreo::Bool* release_is_dense();
  void set_allocated_is_dense(::choreo::Bool* is_dense);

  // @@protoc_insertion_point(class_scope:choreo.PointCloud2)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::PointField > fields_;
  ::choreo::Header* header_;
  ::choreo::UInt32* height_;
  ::choreo::UInt32* width_;
  ::choreo::Bool* is_bigendian_;
  ::choreo::UInt32* point_step_;
  ::choreo::UInt32* row_step_;
  ::choreo::Bytes* data_;
  ::choreo::Bool* is_dense_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fdepth_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Range : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.Range) */ {
 public:
  Range();
  virtual ~Range();

  Range(const Range& from);

  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Range& default_instance();

  static inline const Range* internal_default_instance() {
    return reinterpret_cast<const Range*>(
               &_Range_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Range* other);

  // implements Message ----------------------------------------------

  inline Range* New() const PROTOBUF_FINAL { return New(NULL); }

  Range* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Range& from);
  void MergeFrom(const Range& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Range* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Range_RadiationType RadiationType;
  static const RadiationType ULTRASOUND =
    Range_RadiationType_ULTRASOUND;
  static const RadiationType INFRARED =
    Range_RadiationType_INFRARED;
  static inline bool RadiationType_IsValid(int value) {
    return Range_RadiationType_IsValid(value);
  }
  static const RadiationType RadiationType_MIN =
    Range_RadiationType_RadiationType_MIN;
  static const RadiationType RadiationType_MAX =
    Range_RadiationType_RadiationType_MAX;
  static const int RadiationType_ARRAYSIZE =
    Range_RadiationType_RadiationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RadiationType_descriptor() {
    return Range_RadiationType_descriptor();
  }
  static inline const ::std::string& RadiationType_Name(RadiationType value) {
    return Range_RadiationType_Name(value);
  }
  static inline bool RadiationType_Parse(const ::std::string& name,
      RadiationType* value) {
    return Range_RadiationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.Float32 field_of_view = 3;
  bool has_field_of_view() const;
  void clear_field_of_view();
  static const int kFieldOfViewFieldNumber = 3;
  const ::choreo::Float32& field_of_view() const;
  ::choreo::Float32* mutable_field_of_view();
  ::choreo::Float32* release_field_of_view();
  void set_allocated_field_of_view(::choreo::Float32* field_of_view);

  // .choreo.Float32 min_range = 4;
  bool has_min_range() const;
  void clear_min_range();
  static const int kMinRangeFieldNumber = 4;
  const ::choreo::Float32& min_range() const;
  ::choreo::Float32* mutable_min_range();
  ::choreo::Float32* release_min_range();
  void set_allocated_min_range(::choreo::Float32* min_range);

  // .choreo.Float32 max_range = 5;
  bool has_max_range() const;
  void clear_max_range();
  static const int kMaxRangeFieldNumber = 5;
  const ::choreo::Float32& max_range() const;
  ::choreo::Float32* mutable_max_range();
  ::choreo::Float32* release_max_range();
  void set_allocated_max_range(::choreo::Float32* max_range);

  // .choreo.Float32 range = 6;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 6;
  const ::choreo::Float32& range() const;
  ::choreo::Float32* mutable_range();
  ::choreo::Float32* release_range();
  void set_allocated_range(::choreo::Float32* range);

  // .choreo.Range.RadiationType radiation_type = 2;
  void clear_radiation_type();
  static const int kRadiationTypeFieldNumber = 2;
  ::choreo::Range_RadiationType radiation_type() const;
  void set_radiation_type(::choreo::Range_RadiationType value);

  // @@protoc_insertion_point(class_scope:choreo.Range)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::Header* header_;
  ::choreo::Float32* field_of_view_;
  ::choreo::Float32* min_range_;
  ::choreo::Float32* max_range_;
  ::choreo::Float32* range_;
  int radiation_type_;
  mutable int _cached_size_;
  friend struct protobuf_sensor_2fdepth_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LaserEcho

// repeated .choreo.Float32 echoes = 1;
inline int LaserEcho::echoes_size() const {
  return echoes_.size();
}
inline void LaserEcho::clear_echoes() {
  echoes_.Clear();
}
inline const ::choreo::Float32& LaserEcho::echoes(int index) const {
  // @@protoc_insertion_point(field_get:choreo.LaserEcho.echoes)
  return echoes_.Get(index);
}
inline ::choreo::Float32* LaserEcho::mutable_echoes(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.LaserEcho.echoes)
  return echoes_.Mutable(index);
}
inline ::choreo::Float32* LaserEcho::add_echoes() {
  // @@protoc_insertion_point(field_add:choreo.LaserEcho.echoes)
  return echoes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >*
LaserEcho::mutable_echoes() {
  // @@protoc_insertion_point(field_mutable_list:choreo.LaserEcho.echoes)
  return &echoes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >&
LaserEcho::echoes() const {
  // @@protoc_insertion_point(field_list:choreo.LaserEcho.echoes)
  return echoes_;
}

// -------------------------------------------------------------------

// LaserScan

// .choreo.Header header = 1;
inline bool LaserScan::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void LaserScan::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& LaserScan::header() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* LaserScan::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.header)
  return header_;
}
inline ::choreo::Header* LaserScan::release_header() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void LaserScan::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.header)
}

// .choreo.Float32 angle_min = 2;
inline bool LaserScan::has_angle_min() const {
  return this != internal_default_instance() && angle_min_ != NULL;
}
inline void LaserScan::clear_angle_min() {
  if (GetArenaNoVirtual() == NULL && angle_min_ != NULL) delete angle_min_;
  angle_min_ = NULL;
}
inline const ::choreo::Float32& LaserScan::angle_min() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.angle_min)
  return angle_min_ != NULL ? *angle_min_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* LaserScan::mutable_angle_min() {
  
  if (angle_min_ == NULL) {
    angle_min_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.angle_min)
  return angle_min_;
}
inline ::choreo::Float32* LaserScan::release_angle_min() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.angle_min)
  
  ::choreo::Float32* temp = angle_min_;
  angle_min_ = NULL;
  return temp;
}
inline void LaserScan::set_allocated_angle_min(::choreo::Float32* angle_min) {
  delete angle_min_;
  angle_min_ = angle_min;
  if (angle_min) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.angle_min)
}

// .choreo.Float32 angle_max = 3;
inline bool LaserScan::has_angle_max() const {
  return this != internal_default_instance() && angle_max_ != NULL;
}
inline void LaserScan::clear_angle_max() {
  if (GetArenaNoVirtual() == NULL && angle_max_ != NULL) delete angle_max_;
  angle_max_ = NULL;
}
inline const ::choreo::Float32& LaserScan::angle_max() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.angle_max)
  return angle_max_ != NULL ? *angle_max_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* LaserScan::mutable_angle_max() {
  
  if (angle_max_ == NULL) {
    angle_max_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.angle_max)
  return angle_max_;
}
inline ::choreo::Float32* LaserScan::release_angle_max() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.angle_max)
  
  ::choreo::Float32* temp = angle_max_;
  angle_max_ = NULL;
  return temp;
}
inline void LaserScan::set_allocated_angle_max(::choreo::Float32* angle_max) {
  delete angle_max_;
  angle_max_ = angle_max;
  if (angle_max) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.angle_max)
}

// .choreo.Float32 angle_increment = 4;
inline bool LaserScan::has_angle_increment() const {
  return this != internal_default_instance() && angle_increment_ != NULL;
}
inline void LaserScan::clear_angle_increment() {
  if (GetArenaNoVirtual() == NULL && angle_increment_ != NULL) delete angle_increment_;
  angle_increment_ = NULL;
}
inline const ::choreo::Float32& LaserScan::angle_increment() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.angle_increment)
  return angle_increment_ != NULL ? *angle_increment_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* LaserScan::mutable_angle_increment() {
  
  if (angle_increment_ == NULL) {
    angle_increment_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.angle_increment)
  return angle_increment_;
}
inline ::choreo::Float32* LaserScan::release_angle_increment() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.angle_increment)
  
  ::choreo::Float32* temp = angle_increment_;
  angle_increment_ = NULL;
  return temp;
}
inline void LaserScan::set_allocated_angle_increment(::choreo::Float32* angle_increment) {
  delete angle_increment_;
  angle_increment_ = angle_increment;
  if (angle_increment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.angle_increment)
}

// .choreo.Float32 time_increment = 5;
inline bool LaserScan::has_time_increment() const {
  return this != internal_default_instance() && time_increment_ != NULL;
}
inline void LaserScan::clear_time_increment() {
  if (GetArenaNoVirtual() == NULL && time_increment_ != NULL) delete time_increment_;
  time_increment_ = NULL;
}
inline const ::choreo::Float32& LaserScan::time_increment() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.time_increment)
  return time_increment_ != NULL ? *time_increment_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* LaserScan::mutable_time_increment() {
  
  if (time_increment_ == NULL) {
    time_increment_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.time_increment)
  return time_increment_;
}
inline ::choreo::Float32* LaserScan::release_time_increment() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.time_increment)
  
  ::choreo::Float32* temp = time_increment_;
  time_increment_ = NULL;
  return temp;
}
inline void LaserScan::set_allocated_time_increment(::choreo::Float32* time_increment) {
  delete time_increment_;
  time_increment_ = time_increment;
  if (time_increment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.time_increment)
}

// .choreo.Float32 scan_time = 6;
inline bool LaserScan::has_scan_time() const {
  return this != internal_default_instance() && scan_time_ != NULL;
}
inline void LaserScan::clear_scan_time() {
  if (GetArenaNoVirtual() == NULL && scan_time_ != NULL) delete scan_time_;
  scan_time_ = NULL;
}
inline const ::choreo::Float32& LaserScan::scan_time() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.scan_time)
  return scan_time_ != NULL ? *scan_time_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* LaserScan::mutable_scan_time() {
  
  if (scan_time_ == NULL) {
    scan_time_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.scan_time)
  return scan_time_;
}
inline ::choreo::Float32* LaserScan::release_scan_time() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.scan_time)
  
  ::choreo::Float32* temp = scan_time_;
  scan_time_ = NULL;
  return temp;
}
inline void LaserScan::set_allocated_scan_time(::choreo::Float32* scan_time) {
  delete scan_time_;
  scan_time_ = scan_time;
  if (scan_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.scan_time)
}

// .choreo.Float32 range_min = 7;
inline bool LaserScan::has_range_min() const {
  return this != internal_default_instance() && range_min_ != NULL;
}
inline void LaserScan::clear_range_min() {
  if (GetArenaNoVirtual() == NULL && range_min_ != NULL) delete range_min_;
  range_min_ = NULL;
}
inline const ::choreo::Float32& LaserScan::range_min() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.range_min)
  return range_min_ != NULL ? *range_min_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* LaserScan::mutable_range_min() {
  
  if (range_min_ == NULL) {
    range_min_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.range_min)
  return range_min_;
}
inline ::choreo::Float32* LaserScan::release_range_min() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.range_min)
  
  ::choreo::Float32* temp = range_min_;
  range_min_ = NULL;
  return temp;
}
inline void LaserScan::set_allocated_range_min(::choreo::Float32* range_min) {
  delete range_min_;
  range_min_ = range_min;
  if (range_min) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.range_min)
}

// .choreo.Float32 range_max = 8;
inline bool LaserScan::has_range_max() const {
  return this != internal_default_instance() && range_max_ != NULL;
}
inline void LaserScan::clear_range_max() {
  if (GetArenaNoVirtual() == NULL && range_max_ != NULL) delete range_max_;
  range_max_ = NULL;
}
inline const ::choreo::Float32& LaserScan::range_max() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.range_max)
  return range_max_ != NULL ? *range_max_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* LaserScan::mutable_range_max() {
  
  if (range_max_ == NULL) {
    range_max_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.range_max)
  return range_max_;
}
inline ::choreo::Float32* LaserScan::release_range_max() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.range_max)
  
  ::choreo::Float32* temp = range_max_;
  range_max_ = NULL;
  return temp;
}
inline void LaserScan::set_allocated_range_max(::choreo::Float32* range_max) {
  delete range_max_;
  range_max_ = range_max;
  if (range_max) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.range_max)
}

// repeated .choreo.Float32 ranges = 9;
inline int LaserScan::ranges_size() const {
  return ranges_.size();
}
inline void LaserScan::clear_ranges() {
  ranges_.Clear();
}
inline const ::choreo::Float32& LaserScan::ranges(int index) const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.ranges)
  return ranges_.Get(index);
}
inline ::choreo::Float32* LaserScan::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.ranges)
  return ranges_.Mutable(index);
}
inline ::choreo::Float32* LaserScan::add_ranges() {
  // @@protoc_insertion_point(field_add:choreo.LaserScan.ranges)
  return ranges_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >*
LaserScan::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:choreo.LaserScan.ranges)
  return &ranges_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >&
LaserScan::ranges() const {
  // @@protoc_insertion_point(field_list:choreo.LaserScan.ranges)
  return ranges_;
}

// repeated .choreo.Float32 intensities = 10;
inline int LaserScan::intensities_size() const {
  return intensities_.size();
}
inline void LaserScan::clear_intensities() {
  intensities_.Clear();
}
inline const ::choreo::Float32& LaserScan::intensities(int index) const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.intensities)
  return intensities_.Get(index);
}
inline ::choreo::Float32* LaserScan::mutable_intensities(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.intensities)
  return intensities_.Mutable(index);
}
inline ::choreo::Float32* LaserScan::add_intensities() {
  // @@protoc_insertion_point(field_add:choreo.LaserScan.intensities)
  return intensities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >*
LaserScan::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:choreo.LaserScan.intensities)
  return &intensities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >&
LaserScan::intensities() const {
  // @@protoc_insertion_point(field_list:choreo.LaserScan.intensities)
  return intensities_;
}

// -------------------------------------------------------------------

// MultiEchoLaserScan

// .choreo.Header header = 1;
inline bool MultiEchoLaserScan::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void MultiEchoLaserScan::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& MultiEchoLaserScan::header() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* MultiEchoLaserScan::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.header)
  return header_;
}
inline ::choreo::Header* MultiEchoLaserScan::release_header() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void MultiEchoLaserScan::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.header)
}

// .choreo.Float32 angle_min = 2;
inline bool MultiEchoLaserScan::has_angle_min() const {
  return this != internal_default_instance() && angle_min_ != NULL;
}
inline void MultiEchoLaserScan::clear_angle_min() {
  if (GetArenaNoVirtual() == NULL && angle_min_ != NULL) delete angle_min_;
  angle_min_ = NULL;
}
inline const ::choreo::Float32& MultiEchoLaserScan::angle_min() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.angle_min)
  return angle_min_ != NULL ? *angle_min_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* MultiEchoLaserScan::mutable_angle_min() {
  
  if (angle_min_ == NULL) {
    angle_min_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.angle_min)
  return angle_min_;
}
inline ::choreo::Float32* MultiEchoLaserScan::release_angle_min() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.angle_min)
  
  ::choreo::Float32* temp = angle_min_;
  angle_min_ = NULL;
  return temp;
}
inline void MultiEchoLaserScan::set_allocated_angle_min(::choreo::Float32* angle_min) {
  delete angle_min_;
  angle_min_ = angle_min;
  if (angle_min) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.angle_min)
}

// .choreo.Float32 angle_max = 3;
inline bool MultiEchoLaserScan::has_angle_max() const {
  return this != internal_default_instance() && angle_max_ != NULL;
}
inline void MultiEchoLaserScan::clear_angle_max() {
  if (GetArenaNoVirtual() == NULL && angle_max_ != NULL) delete angle_max_;
  angle_max_ = NULL;
}
inline const ::choreo::Float32& MultiEchoLaserScan::angle_max() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.angle_max)
  return angle_max_ != NULL ? *angle_max_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* MultiEchoLaserScan::mutable_angle_max() {
  
  if (angle_max_ == NULL) {
    angle_max_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.angle_max)
  return angle_max_;
}
inline ::choreo::Float32* MultiEchoLaserScan::release_angle_max() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.angle_max)
  
  ::choreo::Float32* temp = angle_max_;
  angle_max_ = NULL;
  return temp;
}
inline void MultiEchoLaserScan::set_allocated_angle_max(::choreo::Float32* angle_max) {
  delete angle_max_;
  angle_max_ = angle_max;
  if (angle_max) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.angle_max)
}

// .choreo.Float32 angle_increment = 4;
inline bool MultiEchoLaserScan::has_angle_increment() const {
  return this != internal_default_instance() && angle_increment_ != NULL;
}
inline void MultiEchoLaserScan::clear_angle_increment() {
  if (GetArenaNoVirtual() == NULL && angle_increment_ != NULL) delete angle_increment_;
  angle_increment_ = NULL;
}
inline const ::choreo::Float32& MultiEchoLaserScan::angle_increment() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.angle_increment)
  return angle_increment_ != NULL ? *angle_increment_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* MultiEchoLaserScan::mutable_angle_increment() {
  
  if (angle_increment_ == NULL) {
    angle_increment_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.angle_increment)
  return angle_increment_;
}
inline ::choreo::Float32* MultiEchoLaserScan::release_angle_increment() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.angle_increment)
  
  ::choreo::Float32* temp = angle_increment_;
  angle_increment_ = NULL;
  return temp;
}
inline void MultiEchoLaserScan::set_allocated_angle_increment(::choreo::Float32* angle_increment) {
  delete angle_increment_;
  angle_increment_ = angle_increment;
  if (angle_increment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.angle_increment)
}

// .choreo.Float32 time_increment = 5;
inline bool MultiEchoLaserScan::has_time_increment() const {
  return this != internal_default_instance() && time_increment_ != NULL;
}
inline void MultiEchoLaserScan::clear_time_increment() {
  if (GetArenaNoVirtual() == NULL && time_increment_ != NULL) delete time_increment_;
  time_increment_ = NULL;
}
inline const ::choreo::Float32& MultiEchoLaserScan::time_increment() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.time_increment)
  return time_increment_ != NULL ? *time_increment_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* MultiEchoLaserScan::mutable_time_increment() {
  
  if (time_increment_ == NULL) {
    time_increment_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.time_increment)
  return time_increment_;
}
inline ::choreo::Float32* MultiEchoLaserScan::release_time_increment() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.time_increment)
  
  ::choreo::Float32* temp = time_increment_;
  time_increment_ = NULL;
  return temp;
}
inline void MultiEchoLaserScan::set_allocated_time_increment(::choreo::Float32* time_increment) {
  delete time_increment_;
  time_increment_ = time_increment;
  if (time_increment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.time_increment)
}

// .choreo.Float32 scan_time = 6;
inline bool MultiEchoLaserScan::has_scan_time() const {
  return this != internal_default_instance() && scan_time_ != NULL;
}
inline void MultiEchoLaserScan::clear_scan_time() {
  if (GetArenaNoVirtual() == NULL && scan_time_ != NULL) delete scan_time_;
  scan_time_ = NULL;
}
inline const ::choreo::Float32& MultiEchoLaserScan::scan_time() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.scan_time)
  return scan_time_ != NULL ? *scan_time_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* MultiEchoLaserScan::mutable_scan_time() {
  
  if (scan_time_ == NULL) {
    scan_time_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.scan_time)
  return scan_time_;
}
inline ::choreo::Float32* MultiEchoLaserScan::release_scan_time() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.scan_time)
  
  ::choreo::Float32* temp = scan_time_;
  scan_time_ = NULL;
  return temp;
}
inline void MultiEchoLaserScan::set_allocated_scan_time(::choreo::Float32* scan_time) {
  delete scan_time_;
  scan_time_ = scan_time;
  if (scan_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.scan_time)
}

// .choreo.Float32 range_min = 7;
inline bool MultiEchoLaserScan::has_range_min() const {
  return this != internal_default_instance() && range_min_ != NULL;
}
inline void MultiEchoLaserScan::clear_range_min() {
  if (GetArenaNoVirtual() == NULL && range_min_ != NULL) delete range_min_;
  range_min_ = NULL;
}
inline const ::choreo::Float32& MultiEchoLaserScan::range_min() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.range_min)
  return range_min_ != NULL ? *range_min_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* MultiEchoLaserScan::mutable_range_min() {
  
  if (range_min_ == NULL) {
    range_min_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.range_min)
  return range_min_;
}
inline ::choreo::Float32* MultiEchoLaserScan::release_range_min() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.range_min)
  
  ::choreo::Float32* temp = range_min_;
  range_min_ = NULL;
  return temp;
}
inline void MultiEchoLaserScan::set_allocated_range_min(::choreo::Float32* range_min) {
  delete range_min_;
  range_min_ = range_min;
  if (range_min) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.range_min)
}

// .choreo.Float32 range_max = 8;
inline bool MultiEchoLaserScan::has_range_max() const {
  return this != internal_default_instance() && range_max_ != NULL;
}
inline void MultiEchoLaserScan::clear_range_max() {
  if (GetArenaNoVirtual() == NULL && range_max_ != NULL) delete range_max_;
  range_max_ = NULL;
}
inline const ::choreo::Float32& MultiEchoLaserScan::range_max() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.range_max)
  return range_max_ != NULL ? *range_max_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* MultiEchoLaserScan::mutable_range_max() {
  
  if (range_max_ == NULL) {
    range_max_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.range_max)
  return range_max_;
}
inline ::choreo::Float32* MultiEchoLaserScan::release_range_max() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.range_max)
  
  ::choreo::Float32* temp = range_max_;
  range_max_ = NULL;
  return temp;
}
inline void MultiEchoLaserScan::set_allocated_range_max(::choreo::Float32* range_max) {
  delete range_max_;
  range_max_ = range_max;
  if (range_max) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.range_max)
}

// repeated .choreo.LaserEcho ranges = 9;
inline int MultiEchoLaserScan::ranges_size() const {
  return ranges_.size();
}
inline void MultiEchoLaserScan::clear_ranges() {
  ranges_.Clear();
}
inline const ::choreo::LaserEcho& MultiEchoLaserScan::ranges(int index) const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.ranges)
  return ranges_.Get(index);
}
inline ::choreo::LaserEcho* MultiEchoLaserScan::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.ranges)
  return ranges_.Mutable(index);
}
inline ::choreo::LaserEcho* MultiEchoLaserScan::add_ranges() {
  // @@protoc_insertion_point(field_add:choreo.MultiEchoLaserScan.ranges)
  return ranges_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho >*
MultiEchoLaserScan::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:choreo.MultiEchoLaserScan.ranges)
  return &ranges_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho >&
MultiEchoLaserScan::ranges() const {
  // @@protoc_insertion_point(field_list:choreo.MultiEchoLaserScan.ranges)
  return ranges_;
}

// repeated .choreo.LaserEcho intensities = 10;
inline int MultiEchoLaserScan::intensities_size() const {
  return intensities_.size();
}
inline void MultiEchoLaserScan::clear_intensities() {
  intensities_.Clear();
}
inline const ::choreo::LaserEcho& MultiEchoLaserScan::intensities(int index) const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.intensities)
  return intensities_.Get(index);
}
inline ::choreo::LaserEcho* MultiEchoLaserScan::mutable_intensities(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.intensities)
  return intensities_.Mutable(index);
}
inline ::choreo::LaserEcho* MultiEchoLaserScan::add_intensities() {
  // @@protoc_insertion_point(field_add:choreo.MultiEchoLaserScan.intensities)
  return intensities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho >*
MultiEchoLaserScan::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:choreo.MultiEchoLaserScan.intensities)
  return &intensities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho >&
MultiEchoLaserScan::intensities() const {
  // @@protoc_insertion_point(field_list:choreo.MultiEchoLaserScan.intensities)
  return intensities_;
}

// -------------------------------------------------------------------

// PointField

// .choreo.String name = 1;
inline bool PointField::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline void PointField::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) delete name_;
  name_ = NULL;
}
inline const ::choreo::String& PointField::name() const {
  // @@protoc_insertion_point(field_get:choreo.PointField.name)
  return name_ != NULL ? *name_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* PointField::mutable_name() {
  
  if (name_ == NULL) {
    name_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointField.name)
  return name_;
}
inline ::choreo::String* PointField::release_name() {
  // @@protoc_insertion_point(field_release:choreo.PointField.name)
  
  ::choreo::String* temp = name_;
  name_ = NULL;
  return temp;
}
inline void PointField::set_allocated_name(::choreo::String* name) {
  delete name_;
  name_ = name;
  if (name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointField.name)
}

// .choreo.UInt32 offset = 2;
inline bool PointField::has_offset() const {
  return this != internal_default_instance() && offset_ != NULL;
}
inline void PointField::clear_offset() {
  if (GetArenaNoVirtual() == NULL && offset_ != NULL) delete offset_;
  offset_ = NULL;
}
inline const ::choreo::UInt32& PointField::offset() const {
  // @@protoc_insertion_point(field_get:choreo.PointField.offset)
  return offset_ != NULL ? *offset_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* PointField::mutable_offset() {
  
  if (offset_ == NULL) {
    offset_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointField.offset)
  return offset_;
}
inline ::choreo::UInt32* PointField::release_offset() {
  // @@protoc_insertion_point(field_release:choreo.PointField.offset)
  
  ::choreo::UInt32* temp = offset_;
  offset_ = NULL;
  return temp;
}
inline void PointField::set_allocated_offset(::choreo::UInt32* offset) {
  delete offset_;
  offset_ = offset;
  if (offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointField.offset)
}

// .choreo.PointField.Datatype datatype = 3;
inline void PointField::clear_datatype() {
  datatype_ = 0;
}
inline ::choreo::PointField_Datatype PointField::datatype() const {
  // @@protoc_insertion_point(field_get:choreo.PointField.datatype)
  return static_cast< ::choreo::PointField_Datatype >(datatype_);
}
inline void PointField::set_datatype(::choreo::PointField_Datatype value) {
  
  datatype_ = value;
  // @@protoc_insertion_point(field_set:choreo.PointField.datatype)
}

// .choreo.UInt32 count = 4;
inline bool PointField::has_count() const {
  return this != internal_default_instance() && count_ != NULL;
}
inline void PointField::clear_count() {
  if (GetArenaNoVirtual() == NULL && count_ != NULL) delete count_;
  count_ = NULL;
}
inline const ::choreo::UInt32& PointField::count() const {
  // @@protoc_insertion_point(field_get:choreo.PointField.count)
  return count_ != NULL ? *count_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* PointField::mutable_count() {
  
  if (count_ == NULL) {
    count_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointField.count)
  return count_;
}
inline ::choreo::UInt32* PointField::release_count() {
  // @@protoc_insertion_point(field_release:choreo.PointField.count)
  
  ::choreo::UInt32* temp = count_;
  count_ = NULL;
  return temp;
}
inline void PointField::set_allocated_count(::choreo::UInt32* count) {
  delete count_;
  count_ = count;
  if (count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointField.count)
}

// -------------------------------------------------------------------

// PointCloud

// .choreo.Header header = 1;
inline bool PointCloud::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PointCloud::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& PointCloud::header() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* PointCloud::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud.header)
  return header_;
}
inline ::choreo::Header* PointCloud::release_header() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PointCloud::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud.header)
}

// repeated .choreo.Point32 points = 2;
inline int PointCloud::points_size() const {
  return points_.size();
}
inline void PointCloud::clear_points() {
  points_.Clear();
}
inline const ::choreo::Point32& PointCloud::points(int index) const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud.points)
  return points_.Get(index);
}
inline ::choreo::Point32* PointCloud::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud.points)
  return points_.Mutable(index);
}
inline ::choreo::Point32* PointCloud::add_points() {
  // @@protoc_insertion_point(field_add:choreo.PointCloud.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Point32 >*
PointCloud::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:choreo.PointCloud.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Point32 >&
PointCloud::points() const {
  // @@protoc_insertion_point(field_list:choreo.PointCloud.points)
  return points_;
}

// repeated .choreo.ChannelFloat32 channels = 3;
inline int PointCloud::channels_size() const {
  return channels_.size();
}
inline void PointCloud::clear_channels() {
  channels_.Clear();
}
inline const ::choreo::ChannelFloat32& PointCloud::channels(int index) const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud.channels)
  return channels_.Get(index);
}
inline ::choreo::ChannelFloat32* PointCloud::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud.channels)
  return channels_.Mutable(index);
}
inline ::choreo::ChannelFloat32* PointCloud::add_channels() {
  // @@protoc_insertion_point(field_add:choreo.PointCloud.channels)
  return channels_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::ChannelFloat32 >*
PointCloud::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:choreo.PointCloud.channels)
  return &channels_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::ChannelFloat32 >&
PointCloud::channels() const {
  // @@protoc_insertion_point(field_list:choreo.PointCloud.channels)
  return channels_;
}

// -------------------------------------------------------------------

// PointCloud2

// .choreo.Header header = 1;
inline bool PointCloud2::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PointCloud2::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& PointCloud2::header() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* PointCloud2::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.header)
  return header_;
}
inline ::choreo::Header* PointCloud2::release_header() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PointCloud2::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.header)
}

// .choreo.UInt32 height = 2;
inline bool PointCloud2::has_height() const {
  return this != internal_default_instance() && height_ != NULL;
}
inline void PointCloud2::clear_height() {
  if (GetArenaNoVirtual() == NULL && height_ != NULL) delete height_;
  height_ = NULL;
}
inline const ::choreo::UInt32& PointCloud2::height() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.height)
  return height_ != NULL ? *height_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* PointCloud2::mutable_height() {
  
  if (height_ == NULL) {
    height_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.height)
  return height_;
}
inline ::choreo::UInt32* PointCloud2::release_height() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.height)
  
  ::choreo::UInt32* temp = height_;
  height_ = NULL;
  return temp;
}
inline void PointCloud2::set_allocated_height(::choreo::UInt32* height) {
  delete height_;
  height_ = height;
  if (height) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.height)
}

// .choreo.UInt32 width = 3;
inline bool PointCloud2::has_width() const {
  return this != internal_default_instance() && width_ != NULL;
}
inline void PointCloud2::clear_width() {
  if (GetArenaNoVirtual() == NULL && width_ != NULL) delete width_;
  width_ = NULL;
}
inline const ::choreo::UInt32& PointCloud2::width() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.width)
  return width_ != NULL ? *width_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* PointCloud2::mutable_width() {
  
  if (width_ == NULL) {
    width_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.width)
  return width_;
}
inline ::choreo::UInt32* PointCloud2::release_width() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.width)
  
  ::choreo::UInt32* temp = width_;
  width_ = NULL;
  return temp;
}
inline void PointCloud2::set_allocated_width(::choreo::UInt32* width) {
  delete width_;
  width_ = width;
  if (width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.width)
}

// repeated .choreo.PointField fields = 4;
inline int PointCloud2::fields_size() const {
  return fields_.size();
}
inline void PointCloud2::clear_fields() {
  fields_.Clear();
}
inline const ::choreo::PointField& PointCloud2::fields(int index) const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.fields)
  return fields_.Get(index);
}
inline ::choreo::PointField* PointCloud2::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.fields)
  return fields_.Mutable(index);
}
inline ::choreo::PointField* PointCloud2::add_fields() {
  // @@protoc_insertion_point(field_add:choreo.PointCloud2.fields)
  return fields_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::PointField >*
PointCloud2::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:choreo.PointCloud2.fields)
  return &fields_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::PointField >&
PointCloud2::fields() const {
  // @@protoc_insertion_point(field_list:choreo.PointCloud2.fields)
  return fields_;
}

// .choreo.Bool is_bigendian = 5;
inline bool PointCloud2::has_is_bigendian() const {
  return this != internal_default_instance() && is_bigendian_ != NULL;
}
inline void PointCloud2::clear_is_bigendian() {
  if (GetArenaNoVirtual() == NULL && is_bigendian_ != NULL) delete is_bigendian_;
  is_bigendian_ = NULL;
}
inline const ::choreo::Bool& PointCloud2::is_bigendian() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.is_bigendian)
  return is_bigendian_ != NULL ? *is_bigendian_
                         : *::choreo::Bool::internal_default_instance();
}
inline ::choreo::Bool* PointCloud2::mutable_is_bigendian() {
  
  if (is_bigendian_ == NULL) {
    is_bigendian_ = new ::choreo::Bool;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.is_bigendian)
  return is_bigendian_;
}
inline ::choreo::Bool* PointCloud2::release_is_bigendian() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.is_bigendian)
  
  ::choreo::Bool* temp = is_bigendian_;
  is_bigendian_ = NULL;
  return temp;
}
inline void PointCloud2::set_allocated_is_bigendian(::choreo::Bool* is_bigendian) {
  delete is_bigendian_;
  is_bigendian_ = is_bigendian;
  if (is_bigendian) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.is_bigendian)
}

// .choreo.UInt32 point_step = 6;
inline bool PointCloud2::has_point_step() const {
  return this != internal_default_instance() && point_step_ != NULL;
}
inline void PointCloud2::clear_point_step() {
  if (GetArenaNoVirtual() == NULL && point_step_ != NULL) delete point_step_;
  point_step_ = NULL;
}
inline const ::choreo::UInt32& PointCloud2::point_step() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.point_step)
  return point_step_ != NULL ? *point_step_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* PointCloud2::mutable_point_step() {
  
  if (point_step_ == NULL) {
    point_step_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.point_step)
  return point_step_;
}
inline ::choreo::UInt32* PointCloud2::release_point_step() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.point_step)
  
  ::choreo::UInt32* temp = point_step_;
  point_step_ = NULL;
  return temp;
}
inline void PointCloud2::set_allocated_point_step(::choreo::UInt32* point_step) {
  delete point_step_;
  point_step_ = point_step;
  if (point_step) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.point_step)
}

// .choreo.UInt32 row_step = 7;
inline bool PointCloud2::has_row_step() const {
  return this != internal_default_instance() && row_step_ != NULL;
}
inline void PointCloud2::clear_row_step() {
  if (GetArenaNoVirtual() == NULL && row_step_ != NULL) delete row_step_;
  row_step_ = NULL;
}
inline const ::choreo::UInt32& PointCloud2::row_step() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.row_step)
  return row_step_ != NULL ? *row_step_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* PointCloud2::mutable_row_step() {
  
  if (row_step_ == NULL) {
    row_step_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.row_step)
  return row_step_;
}
inline ::choreo::UInt32* PointCloud2::release_row_step() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.row_step)
  
  ::choreo::UInt32* temp = row_step_;
  row_step_ = NULL;
  return temp;
}
inline void PointCloud2::set_allocated_row_step(::choreo::UInt32* row_step) {
  delete row_step_;
  row_step_ = row_step;
  if (row_step) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.row_step)
}

// .choreo.Bytes data = 8;
inline bool PointCloud2::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void PointCloud2::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
inline const ::choreo::Bytes& PointCloud2::data() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.data)
  return data_ != NULL ? *data_
                         : *::choreo::Bytes::internal_default_instance();
}
inline ::choreo::Bytes* PointCloud2::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::choreo::Bytes;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.data)
  return data_;
}
inline ::choreo::Bytes* PointCloud2::release_data() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.data)
  
  ::choreo::Bytes* temp = data_;
  data_ = NULL;
  return temp;
}
inline void PointCloud2::set_allocated_data(::choreo::Bytes* data) {
  delete data_;
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.data)
}

// .choreo.Bool is_dense = 9;
inline bool PointCloud2::has_is_dense() const {
  return this != internal_default_instance() && is_dense_ != NULL;
}
inline void PointCloud2::clear_is_dense() {
  if (GetArenaNoVirtual() == NULL && is_dense_ != NULL) delete is_dense_;
  is_dense_ = NULL;
}
inline const ::choreo::Bool& PointCloud2::is_dense() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.is_dense)
  return is_dense_ != NULL ? *is_dense_
                         : *::choreo::Bool::internal_default_instance();
}
inline ::choreo::Bool* PointCloud2::mutable_is_dense() {
  
  if (is_dense_ == NULL) {
    is_dense_ = new ::choreo::Bool;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.is_dense)
  return is_dense_;
}
inline ::choreo::Bool* PointCloud2::release_is_dense() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.is_dense)
  
  ::choreo::Bool* temp = is_dense_;
  is_dense_ = NULL;
  return temp;
}
inline void PointCloud2::set_allocated_is_dense(::choreo::Bool* is_dense) {
  delete is_dense_;
  is_dense_ = is_dense;
  if (is_dense) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.is_dense)
}

// -------------------------------------------------------------------

// Range

// .choreo.Header header = 1;
inline bool Range::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Range::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& Range::header() const {
  // @@protoc_insertion_point(field_get:choreo.Range.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* Range::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Range.header)
  return header_;
}
inline ::choreo::Header* Range::release_header() {
  // @@protoc_insertion_point(field_release:choreo.Range.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Range::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Range.header)
}

// .choreo.Range.RadiationType radiation_type = 2;
inline void Range::clear_radiation_type() {
  radiation_type_ = 0;
}
inline ::choreo::Range_RadiationType Range::radiation_type() const {
  // @@protoc_insertion_point(field_get:choreo.Range.radiation_type)
  return static_cast< ::choreo::Range_RadiationType >(radiation_type_);
}
inline void Range::set_radiation_type(::choreo::Range_RadiationType value) {
  
  radiation_type_ = value;
  // @@protoc_insertion_point(field_set:choreo.Range.radiation_type)
}

// .choreo.Float32 field_of_view = 3;
inline bool Range::has_field_of_view() const {
  return this != internal_default_instance() && field_of_view_ != NULL;
}
inline void Range::clear_field_of_view() {
  if (GetArenaNoVirtual() == NULL && field_of_view_ != NULL) delete field_of_view_;
  field_of_view_ = NULL;
}
inline const ::choreo::Float32& Range::field_of_view() const {
  // @@protoc_insertion_point(field_get:choreo.Range.field_of_view)
  return field_of_view_ != NULL ? *field_of_view_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* Range::mutable_field_of_view() {
  
  if (field_of_view_ == NULL) {
    field_of_view_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Range.field_of_view)
  return field_of_view_;
}
inline ::choreo::Float32* Range::release_field_of_view() {
  // @@protoc_insertion_point(field_release:choreo.Range.field_of_view)
  
  ::choreo::Float32* temp = field_of_view_;
  field_of_view_ = NULL;
  return temp;
}
inline void Range::set_allocated_field_of_view(::choreo::Float32* field_of_view) {
  delete field_of_view_;
  field_of_view_ = field_of_view;
  if (field_of_view) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Range.field_of_view)
}

// .choreo.Float32 min_range = 4;
inline bool Range::has_min_range() const {
  return this != internal_default_instance() && min_range_ != NULL;
}
inline void Range::clear_min_range() {
  if (GetArenaNoVirtual() == NULL && min_range_ != NULL) delete min_range_;
  min_range_ = NULL;
}
inline const ::choreo::Float32& Range::min_range() const {
  // @@protoc_insertion_point(field_get:choreo.Range.min_range)
  return min_range_ != NULL ? *min_range_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* Range::mutable_min_range() {
  
  if (min_range_ == NULL) {
    min_range_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Range.min_range)
  return min_range_;
}
inline ::choreo::Float32* Range::release_min_range() {
  // @@protoc_insertion_point(field_release:choreo.Range.min_range)
  
  ::choreo::Float32* temp = min_range_;
  min_range_ = NULL;
  return temp;
}
inline void Range::set_allocated_min_range(::choreo::Float32* min_range) {
  delete min_range_;
  min_range_ = min_range;
  if (min_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Range.min_range)
}

// .choreo.Float32 max_range = 5;
inline bool Range::has_max_range() const {
  return this != internal_default_instance() && max_range_ != NULL;
}
inline void Range::clear_max_range() {
  if (GetArenaNoVirtual() == NULL && max_range_ != NULL) delete max_range_;
  max_range_ = NULL;
}
inline const ::choreo::Float32& Range::max_range() const {
  // @@protoc_insertion_point(field_get:choreo.Range.max_range)
  return max_range_ != NULL ? *max_range_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* Range::mutable_max_range() {
  
  if (max_range_ == NULL) {
    max_range_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Range.max_range)
  return max_range_;
}
inline ::choreo::Float32* Range::release_max_range() {
  // @@protoc_insertion_point(field_release:choreo.Range.max_range)
  
  ::choreo::Float32* temp = max_range_;
  max_range_ = NULL;
  return temp;
}
inline void Range::set_allocated_max_range(::choreo::Float32* max_range) {
  delete max_range_;
  max_range_ = max_range;
  if (max_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Range.max_range)
}

// .choreo.Float32 range = 6;
inline bool Range::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void Range::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::choreo::Float32& Range::range() const {
  // @@protoc_insertion_point(field_get:choreo.Range.range)
  return range_ != NULL ? *range_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* Range::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Range.range)
  return range_;
}
inline ::choreo::Float32* Range::release_range() {
  // @@protoc_insertion_point(field_release:choreo.Range.range)
  
  ::choreo::Float32* temp = range_;
  range_ = NULL;
  return temp;
}
inline void Range::set_allocated_range(::choreo::Float32* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Range.range)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace choreo

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::choreo::PointField_Datatype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::choreo::PointField_Datatype>() {
  return ::choreo::PointField_Datatype_descriptor();
}
template <> struct is_proto_enum< ::choreo::Range_RadiationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::choreo::Range_RadiationType>() {
  return ::choreo::Range_RadiationType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sensor_2fdepth_2eproto__INCLUDED
