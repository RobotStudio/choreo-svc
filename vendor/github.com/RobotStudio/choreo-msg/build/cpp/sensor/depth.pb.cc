// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor/depth.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "sensor/depth.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace choreo {
class LaserEchoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<LaserEcho> {
} _LaserEcho_default_instance_;
class LaserScanDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<LaserScan> {
} _LaserScan_default_instance_;
class MultiEchoLaserScanDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<MultiEchoLaserScan> {
} _MultiEchoLaserScan_default_instance_;
class PointFieldDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PointField> {
} _PointField_default_instance_;
class PointCloudDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PointCloud> {
} _PointCloud_default_instance_;
class PointCloud2DefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PointCloud2> {
} _PointCloud2_default_instance_;
class RangeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Range> {
} _Range_default_instance_;

namespace protobuf_sensor_2fdepth_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[7];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[2];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserEcho, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserEcho, echoes_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserScan, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserScan, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserScan, angle_min_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserScan, angle_max_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserScan, angle_increment_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserScan, time_increment_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserScan, scan_time_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserScan, range_min_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserScan, range_max_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserScan, ranges_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserScan, intensities_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiEchoLaserScan, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiEchoLaserScan, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiEchoLaserScan, angle_min_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiEchoLaserScan, angle_max_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiEchoLaserScan, angle_increment_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiEchoLaserScan, time_increment_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiEchoLaserScan, scan_time_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiEchoLaserScan, range_min_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiEchoLaserScan, range_max_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiEchoLaserScan, ranges_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiEchoLaserScan, intensities_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointField, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointField, name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointField, offset_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointField, datatype_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointField, count_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud, points_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud, channels_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud2, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud2, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud2, height_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud2, width_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud2, fields_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud2, is_bigendian_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud2, point_step_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud2, row_step_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud2, data_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointCloud2, is_dense_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, radiation_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, field_of_view_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, min_range_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, max_range_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, range_),
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, -1, sizeof(LaserEcho)},
  { 6, -1, sizeof(LaserScan)},
  { 21, -1, sizeof(MultiEchoLaserScan)},
  { 36, -1, sizeof(PointField)},
  { 45, -1, sizeof(PointCloud)},
  { 53, -1, sizeof(PointCloud2)},
  { 67, -1, sizeof(Range)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_LaserEcho_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_LaserScan_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_MultiEchoLaserScan_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PointField_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PointCloud_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PointCloud2_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Range_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "sensor/depth.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 7);
}

}  // namespace

void TableStruct::Shutdown() {
  _LaserEcho_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _LaserScan_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _MultiEchoLaserScan_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _PointField_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _PointCloud_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _PointCloud2_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
  _Range_default_instance_.Shutdown();
  delete file_level_metadata[6].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::choreo::protobuf_primitive_2fbool_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2fbytes_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2ffloat_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2fheader_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2fint_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2fstring_2eproto::InitDefaults();
  ::choreo::protobuf_geometric_2fpoint_2eproto::InitDefaults();
  ::choreo::protobuf_sensor_2fcamera_2eproto::InitDefaults();
  _LaserEcho_default_instance_.DefaultConstruct();
  _LaserScan_default_instance_.DefaultConstruct();
  _MultiEchoLaserScan_default_instance_.DefaultConstruct();
  _PointField_default_instance_.DefaultConstruct();
  _PointCloud_default_instance_.DefaultConstruct();
  _PointCloud2_default_instance_.DefaultConstruct();
  _Range_default_instance_.DefaultConstruct();
  _LaserScan_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _LaserScan_default_instance_.get_mutable()->angle_min_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _LaserScan_default_instance_.get_mutable()->angle_max_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _LaserScan_default_instance_.get_mutable()->angle_increment_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _LaserScan_default_instance_.get_mutable()->time_increment_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _LaserScan_default_instance_.get_mutable()->scan_time_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _LaserScan_default_instance_.get_mutable()->range_min_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _LaserScan_default_instance_.get_mutable()->range_max_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _MultiEchoLaserScan_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _MultiEchoLaserScan_default_instance_.get_mutable()->angle_min_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _MultiEchoLaserScan_default_instance_.get_mutable()->angle_max_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _MultiEchoLaserScan_default_instance_.get_mutable()->angle_increment_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _MultiEchoLaserScan_default_instance_.get_mutable()->time_increment_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _MultiEchoLaserScan_default_instance_.get_mutable()->scan_time_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _MultiEchoLaserScan_default_instance_.get_mutable()->range_min_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _MultiEchoLaserScan_default_instance_.get_mutable()->range_max_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _PointField_default_instance_.get_mutable()->name_ = const_cast< ::choreo::String*>(
      ::choreo::String::internal_default_instance());
  _PointField_default_instance_.get_mutable()->offset_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _PointField_default_instance_.get_mutable()->count_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _PointCloud_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _PointCloud2_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _PointCloud2_default_instance_.get_mutable()->height_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _PointCloud2_default_instance_.get_mutable()->width_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _PointCloud2_default_instance_.get_mutable()->is_bigendian_ = const_cast< ::choreo::Bool*>(
      ::choreo::Bool::internal_default_instance());
  _PointCloud2_default_instance_.get_mutable()->point_step_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _PointCloud2_default_instance_.get_mutable()->row_step_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _PointCloud2_default_instance_.get_mutable()->data_ = const_cast< ::choreo::Bytes*>(
      ::choreo::Bytes::internal_default_instance());
  _PointCloud2_default_instance_.get_mutable()->is_dense_ = const_cast< ::choreo::Bool*>(
      ::choreo::Bool::internal_default_instance());
  _Range_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _Range_default_instance_.get_mutable()->field_of_view_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _Range_default_instance_.get_mutable()->min_range_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _Range_default_instance_.get_mutable()->max_range_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _Range_default_instance_.get_mutable()->range_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\022sensor/depth.proto\022\006choreo\032\024primitive/"
      "bool.proto\032\025primitive/bytes.proto\032\025primi"
      "tive/float.proto\032\026primitive/header.proto"
      "\032\023primitive/int.proto\032\026primitive/string."
      "proto\032\025geometric/point.proto\032\023sensor/cam"
      "era.proto\",\n\tLaserEcho\022\037\n\006echoes\030\001 \003(\0132\017"
      ".choreo.Float32\"\371\002\n\tLaserScan\022\036\n\006header\030"
      "\001 \001(\0132\016.choreo.Header\022\"\n\tangle_min\030\002 \001(\013"
      "2\017.choreo.Float32\022\"\n\tangle_max\030\003 \001(\0132\017.c"
      "horeo.Float32\022(\n\017angle_increment\030\004 \001(\0132\017"
      ".choreo.Float32\022\'\n\016time_increment\030\005 \001(\0132"
      "\017.choreo.Float32\022\"\n\tscan_time\030\006 \001(\0132\017.ch"
      "oreo.Float32\022\"\n\trange_min\030\007 \001(\0132\017.choreo"
      ".Float32\022\"\n\trange_max\030\010 \001(\0132\017.choreo.Flo"
      "at32\022\037\n\006ranges\030\t \003(\0132\017.choreo.Float32\022$\n"
      "\013intensities\030\n \003(\0132\017.choreo.Float32\"\206\003\n\022"
      "MultiEchoLaserScan\022\036\n\006header\030\001 \001(\0132\016.cho"
      "reo.Header\022\"\n\tangle_min\030\002 \001(\0132\017.choreo.F"
      "loat32\022\"\n\tangle_max\030\003 \001(\0132\017.choreo.Float"
      "32\022(\n\017angle_increment\030\004 \001(\0132\017.choreo.Flo"
      "at32\022\'\n\016time_increment\030\005 \001(\0132\017.choreo.Fl"
      "oat32\022\"\n\tscan_time\030\006 \001(\0132\017.choreo.Float3"
      "2\022\"\n\trange_min\030\007 \001(\0132\017.choreo.Float32\022\"\n"
      "\trange_max\030\010 \001(\0132\017.choreo.Float32\022!\n\006ran"
      "ges\030\t \003(\0132\021.choreo.LaserEcho\022&\n\013intensit"
      "ies\030\n \003(\0132\021.choreo.LaserEcho\"\201\002\n\nPointFi"
      "eld\022\034\n\004name\030\001 \001(\0132\016.choreo.String\022\036\n\006off"
      "set\030\002 \001(\0132\016.choreo.UInt32\022-\n\010datatype\030\003 "
      "\001(\0162\033.choreo.PointField.Datatype\022\035\n\005coun"
      "t\030\004 \001(\0132\016.choreo.UInt32\"g\n\010Datatype\022\010\n\004I"
      "NT8\020\000\022\t\n\005UINT8\020\001\022\t\n\005INT16\020\002\022\n\n\006UINT16\020\003\022"
      "\t\n\005INT32\020\004\022\n\n\006UINT32\020\005\022\013\n\007FLOAT32\020\006\022\013\n\007F"
      "LOAT64\020\007\"w\n\nPointCloud\022\036\n\006header\030\001 \001(\0132\016"
      ".choreo.Header\022\037\n\006points\030\002 \003(\0132\017.choreo."
      "Point32\022(\n\010channels\030\003 \003(\0132\026.choreo.Chann"
      "elFloat32\"\267\002\n\013PointCloud2\022\036\n\006header\030\001 \001("
      "\0132\016.choreo.Header\022\036\n\006height\030\002 \001(\0132\016.chor"
      "eo.UInt32\022\035\n\005width\030\003 \001(\0132\016.choreo.UInt32"
      "\022\"\n\006fields\030\004 \003(\0132\022.choreo.PointField\022\"\n\014"
      "is_bigendian\030\005 \001(\0132\014.choreo.Bool\022\"\n\npoin"
      "t_step\030\006 \001(\0132\016.choreo.UInt32\022 \n\010row_step"
      "\030\007 \001(\0132\016.choreo.UInt32\022\033\n\004data\030\010 \001(\0132\r.c"
      "horeo.Bytes\022\036\n\010is_dense\030\t \001(\0132\014.choreo.B"
      "ool\"\233\002\n\005Range\022\036\n\006header\030\001 \001(\0132\016.choreo.H"
      "eader\0223\n\016radiation_type\030\002 \001(\0162\033.choreo.R"
      "ange.RadiationType\022&\n\rfield_of_view\030\003 \001("
      "\0132\017.choreo.Float32\022\"\n\tmin_range\030\004 \001(\0132\017."
      "choreo.Float32\022\"\n\tmax_range\030\005 \001(\0132\017.chor"
      "eo.Float32\022\036\n\005range\030\006 \001(\0132\017.choreo.Float"
      "32\"-\n\rRadiationType\022\016\n\nULTRASOUND\020\000\022\014\n\010I"
      "NFRARED\020\001B+Z)github.com/RobotStudio/chor"
      "eo-msg/msg;msgb\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 2062);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "sensor/depth.proto", &protobuf_RegisterTypes);
  ::choreo::protobuf_primitive_2fbool_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2fbytes_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2ffloat_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2fheader_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2fint_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2fstring_2eproto::AddDescriptors();
  ::choreo::protobuf_geometric_2fpoint_2eproto::AddDescriptors();
  ::choreo::protobuf_sensor_2fcamera_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_sensor_2fdepth_2eproto

const ::google::protobuf::EnumDescriptor* PointField_Datatype_descriptor() {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_enum_descriptors[0];
}
bool PointField_Datatype_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const PointField_Datatype PointField::INT8;
const PointField_Datatype PointField::UINT8;
const PointField_Datatype PointField::INT16;
const PointField_Datatype PointField::UINT16;
const PointField_Datatype PointField::INT32;
const PointField_Datatype PointField::UINT32;
const PointField_Datatype PointField::FLOAT32;
const PointField_Datatype PointField::FLOAT64;
const PointField_Datatype PointField::Datatype_MIN;
const PointField_Datatype PointField::Datatype_MAX;
const int PointField::Datatype_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Range_RadiationType_descriptor() {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_enum_descriptors[1];
}
bool Range_RadiationType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Range_RadiationType Range::ULTRASOUND;
const Range_RadiationType Range::INFRARED;
const Range_RadiationType Range::RadiationType_MIN;
const Range_RadiationType Range::RadiationType_MAX;
const int Range::RadiationType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaserEcho::kEchoesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaserEcho::LaserEcho()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_sensor_2fdepth_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.LaserEcho)
}
LaserEcho::LaserEcho(const LaserEcho& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      echoes_(from.echoes_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:choreo.LaserEcho)
}

void LaserEcho::SharedCtor() {
  _cached_size_ = 0;
}

LaserEcho::~LaserEcho() {
  // @@protoc_insertion_point(destructor:choreo.LaserEcho)
  SharedDtor();
}

void LaserEcho::SharedDtor() {
}

void LaserEcho::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaserEcho::descriptor() {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const LaserEcho& LaserEcho::default_instance() {
  protobuf_sensor_2fdepth_2eproto::InitDefaults();
  return *internal_default_instance();
}

LaserEcho* LaserEcho::New(::google::protobuf::Arena* arena) const {
  LaserEcho* n = new LaserEcho;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LaserEcho::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.LaserEcho)
  echoes_.Clear();
}

bool LaserEcho::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.LaserEcho)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .choreo.Float32 echoes = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_echoes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.LaserEcho)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.LaserEcho)
  return false;
#undef DO_
}

void LaserEcho::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.LaserEcho)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .choreo.Float32 echoes = 1;
  for (unsigned int i = 0, n = this->echoes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->echoes(i), output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.LaserEcho)
}

::google::protobuf::uint8* LaserEcho::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.LaserEcho)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .choreo.Float32 echoes = 1;
  for (unsigned int i = 0, n = this->echoes_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->echoes(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.LaserEcho)
  return target;
}

size_t LaserEcho::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.LaserEcho)
  size_t total_size = 0;

  // repeated .choreo.Float32 echoes = 1;
  {
    unsigned int count = this->echoes_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->echoes(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaserEcho::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.LaserEcho)
  GOOGLE_DCHECK_NE(&from, this);
  const LaserEcho* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const LaserEcho>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.LaserEcho)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.LaserEcho)
    MergeFrom(*source);
  }
}

void LaserEcho::MergeFrom(const LaserEcho& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.LaserEcho)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  echoes_.MergeFrom(from.echoes_);
}

void LaserEcho::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.LaserEcho)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaserEcho::CopyFrom(const LaserEcho& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.LaserEcho)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaserEcho::IsInitialized() const {
  return true;
}

void LaserEcho::Swap(LaserEcho* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaserEcho::InternalSwap(LaserEcho* other) {
  echoes_.InternalSwap(&other->echoes_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LaserEcho::GetMetadata() const {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LaserEcho

// repeated .choreo.Float32 echoes = 1;
int LaserEcho::echoes_size() const {
  return echoes_.size();
}
void LaserEcho::clear_echoes() {
  echoes_.Clear();
}
const ::choreo::Float32& LaserEcho::echoes(int index) const {
  // @@protoc_insertion_point(field_get:choreo.LaserEcho.echoes)
  return echoes_.Get(index);
}
::choreo::Float32* LaserEcho::mutable_echoes(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.LaserEcho.echoes)
  return echoes_.Mutable(index);
}
::choreo::Float32* LaserEcho::add_echoes() {
  // @@protoc_insertion_point(field_add:choreo.LaserEcho.echoes)
  return echoes_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::Float32 >*
LaserEcho::mutable_echoes() {
  // @@protoc_insertion_point(field_mutable_list:choreo.LaserEcho.echoes)
  return &echoes_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >&
LaserEcho::echoes() const {
  // @@protoc_insertion_point(field_list:choreo.LaserEcho.echoes)
  return echoes_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaserScan::kHeaderFieldNumber;
const int LaserScan::kAngleMinFieldNumber;
const int LaserScan::kAngleMaxFieldNumber;
const int LaserScan::kAngleIncrementFieldNumber;
const int LaserScan::kTimeIncrementFieldNumber;
const int LaserScan::kScanTimeFieldNumber;
const int LaserScan::kRangeMinFieldNumber;
const int LaserScan::kRangeMaxFieldNumber;
const int LaserScan::kRangesFieldNumber;
const int LaserScan::kIntensitiesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaserScan::LaserScan()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_sensor_2fdepth_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.LaserScan)
}
LaserScan::LaserScan(const LaserScan& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      ranges_(from.ranges_),
      intensities_(from.intensities_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_angle_min()) {
    angle_min_ = new ::choreo::Float32(*from.angle_min_);
  } else {
    angle_min_ = NULL;
  }
  if (from.has_angle_max()) {
    angle_max_ = new ::choreo::Float32(*from.angle_max_);
  } else {
    angle_max_ = NULL;
  }
  if (from.has_angle_increment()) {
    angle_increment_ = new ::choreo::Float32(*from.angle_increment_);
  } else {
    angle_increment_ = NULL;
  }
  if (from.has_time_increment()) {
    time_increment_ = new ::choreo::Float32(*from.time_increment_);
  } else {
    time_increment_ = NULL;
  }
  if (from.has_scan_time()) {
    scan_time_ = new ::choreo::Float32(*from.scan_time_);
  } else {
    scan_time_ = NULL;
  }
  if (from.has_range_min()) {
    range_min_ = new ::choreo::Float32(*from.range_min_);
  } else {
    range_min_ = NULL;
  }
  if (from.has_range_max()) {
    range_max_ = new ::choreo::Float32(*from.range_max_);
  } else {
    range_max_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.LaserScan)
}

void LaserScan::SharedCtor() {
  ::memset(&header_, 0, reinterpret_cast<char*>(&range_max_) -
    reinterpret_cast<char*>(&header_) + sizeof(range_max_));
  _cached_size_ = 0;
}

LaserScan::~LaserScan() {
  // @@protoc_insertion_point(destructor:choreo.LaserScan)
  SharedDtor();
}

void LaserScan::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete angle_min_;
  }
  if (this != internal_default_instance()) {
    delete angle_max_;
  }
  if (this != internal_default_instance()) {
    delete angle_increment_;
  }
  if (this != internal_default_instance()) {
    delete time_increment_;
  }
  if (this != internal_default_instance()) {
    delete scan_time_;
  }
  if (this != internal_default_instance()) {
    delete range_min_;
  }
  if (this != internal_default_instance()) {
    delete range_max_;
  }
}

void LaserScan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaserScan::descriptor() {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const LaserScan& LaserScan::default_instance() {
  protobuf_sensor_2fdepth_2eproto::InitDefaults();
  return *internal_default_instance();
}

LaserScan* LaserScan::New(::google::protobuf::Arena* arena) const {
  LaserScan* n = new LaserScan;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LaserScan::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.LaserScan)
  ranges_.Clear();
  intensities_.Clear();
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && angle_min_ != NULL) {
    delete angle_min_;
  }
  angle_min_ = NULL;
  if (GetArenaNoVirtual() == NULL && angle_max_ != NULL) {
    delete angle_max_;
  }
  angle_max_ = NULL;
  if (GetArenaNoVirtual() == NULL && angle_increment_ != NULL) {
    delete angle_increment_;
  }
  angle_increment_ = NULL;
  if (GetArenaNoVirtual() == NULL && time_increment_ != NULL) {
    delete time_increment_;
  }
  time_increment_ = NULL;
  if (GetArenaNoVirtual() == NULL && scan_time_ != NULL) {
    delete scan_time_;
  }
  scan_time_ = NULL;
  if (GetArenaNoVirtual() == NULL && range_min_ != NULL) {
    delete range_min_;
  }
  range_min_ = NULL;
  if (GetArenaNoVirtual() == NULL && range_max_ != NULL) {
    delete range_max_;
  }
  range_max_ = NULL;
}

bool LaserScan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.LaserScan)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 angle_min = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angle_min()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 angle_max = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angle_max()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 angle_increment = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angle_increment()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 time_increment = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_time_increment()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 scan_time = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scan_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 range_min = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_min()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 range_max = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_max()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.Float32 ranges = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ranges()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.Float32 intensities = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_intensities()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.LaserScan)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.LaserScan)
  return false;
#undef DO_
}

void LaserScan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.LaserScan)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .choreo.Float32 angle_min = 2;
  if (this->has_angle_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->angle_min_, output);
  }

  // .choreo.Float32 angle_max = 3;
  if (this->has_angle_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->angle_max_, output);
  }

  // .choreo.Float32 angle_increment = 4;
  if (this->has_angle_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->angle_increment_, output);
  }

  // .choreo.Float32 time_increment = 5;
  if (this->has_time_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->time_increment_, output);
  }

  // .choreo.Float32 scan_time = 6;
  if (this->has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->scan_time_, output);
  }

  // .choreo.Float32 range_min = 7;
  if (this->has_range_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->range_min_, output);
  }

  // .choreo.Float32 range_max = 8;
  if (this->has_range_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->range_max_, output);
  }

  // repeated .choreo.Float32 ranges = 9;
  for (unsigned int i = 0, n = this->ranges_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->ranges(i), output);
  }

  // repeated .choreo.Float32 intensities = 10;
  for (unsigned int i = 0, n = this->intensities_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->intensities(i), output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.LaserScan)
}

::google::protobuf::uint8* LaserScan::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.LaserScan)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // .choreo.Float32 angle_min = 2;
  if (this->has_angle_min()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->angle_min_, deterministic, target);
  }

  // .choreo.Float32 angle_max = 3;
  if (this->has_angle_max()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->angle_max_, deterministic, target);
  }

  // .choreo.Float32 angle_increment = 4;
  if (this->has_angle_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->angle_increment_, deterministic, target);
  }

  // .choreo.Float32 time_increment = 5;
  if (this->has_time_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->time_increment_, deterministic, target);
  }

  // .choreo.Float32 scan_time = 6;
  if (this->has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->scan_time_, deterministic, target);
  }

  // .choreo.Float32 range_min = 7;
  if (this->has_range_min()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->range_min_, deterministic, target);
  }

  // .choreo.Float32 range_max = 8;
  if (this->has_range_max()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->range_max_, deterministic, target);
  }

  // repeated .choreo.Float32 ranges = 9;
  for (unsigned int i = 0, n = this->ranges_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, this->ranges(i), deterministic, target);
  }

  // repeated .choreo.Float32 intensities = 10;
  for (unsigned int i = 0, n = this->intensities_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, this->intensities(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.LaserScan)
  return target;
}

size_t LaserScan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.LaserScan)
  size_t total_size = 0;

  // repeated .choreo.Float32 ranges = 9;
  {
    unsigned int count = this->ranges_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ranges(i));
    }
  }

  // repeated .choreo.Float32 intensities = 10;
  {
    unsigned int count = this->intensities_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->intensities(i));
    }
  }

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // .choreo.Float32 angle_min = 2;
  if (this->has_angle_min()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->angle_min_);
  }

  // .choreo.Float32 angle_max = 3;
  if (this->has_angle_max()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->angle_max_);
  }

  // .choreo.Float32 angle_increment = 4;
  if (this->has_angle_increment()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->angle_increment_);
  }

  // .choreo.Float32 time_increment = 5;
  if (this->has_time_increment()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->time_increment_);
  }

  // .choreo.Float32 scan_time = 6;
  if (this->has_scan_time()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->scan_time_);
  }

  // .choreo.Float32 range_min = 7;
  if (this->has_range_min()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->range_min_);
  }

  // .choreo.Float32 range_max = 8;
  if (this->has_range_max()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->range_max_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaserScan::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.LaserScan)
  GOOGLE_DCHECK_NE(&from, this);
  const LaserScan* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const LaserScan>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.LaserScan)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.LaserScan)
    MergeFrom(*source);
  }
}

void LaserScan::MergeFrom(const LaserScan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.LaserScan)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  ranges_.MergeFrom(from.ranges_);
  intensities_.MergeFrom(from.intensities_);
  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
  if (from.has_angle_min()) {
    mutable_angle_min()->::choreo::Float32::MergeFrom(from.angle_min());
  }
  if (from.has_angle_max()) {
    mutable_angle_max()->::choreo::Float32::MergeFrom(from.angle_max());
  }
  if (from.has_angle_increment()) {
    mutable_angle_increment()->::choreo::Float32::MergeFrom(from.angle_increment());
  }
  if (from.has_time_increment()) {
    mutable_time_increment()->::choreo::Float32::MergeFrom(from.time_increment());
  }
  if (from.has_scan_time()) {
    mutable_scan_time()->::choreo::Float32::MergeFrom(from.scan_time());
  }
  if (from.has_range_min()) {
    mutable_range_min()->::choreo::Float32::MergeFrom(from.range_min());
  }
  if (from.has_range_max()) {
    mutable_range_max()->::choreo::Float32::MergeFrom(from.range_max());
  }
}

void LaserScan::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.LaserScan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaserScan::CopyFrom(const LaserScan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.LaserScan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaserScan::IsInitialized() const {
  return true;
}

void LaserScan::Swap(LaserScan* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaserScan::InternalSwap(LaserScan* other) {
  ranges_.InternalSwap(&other->ranges_);
  intensities_.InternalSwap(&other->intensities_);
  std::swap(header_, other->header_);
  std::swap(angle_min_, other->angle_min_);
  std::swap(angle_max_, other->angle_max_);
  std::swap(angle_increment_, other->angle_increment_);
  std::swap(time_increment_, other->time_increment_);
  std::swap(scan_time_, other->scan_time_);
  std::swap(range_min_, other->range_min_);
  std::swap(range_max_, other->range_max_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LaserScan::GetMetadata() const {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LaserScan

// .choreo.Header header = 1;
bool LaserScan::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void LaserScan::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& LaserScan::header() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* LaserScan::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.header)
  return header_;
}
::choreo::Header* LaserScan::release_header() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void LaserScan::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.header)
}

// .choreo.Float32 angle_min = 2;
bool LaserScan::has_angle_min() const {
  return this != internal_default_instance() && angle_min_ != NULL;
}
void LaserScan::clear_angle_min() {
  if (GetArenaNoVirtual() == NULL && angle_min_ != NULL) delete angle_min_;
  angle_min_ = NULL;
}
const ::choreo::Float32& LaserScan::angle_min() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.angle_min)
  return angle_min_ != NULL ? *angle_min_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* LaserScan::mutable_angle_min() {
  
  if (angle_min_ == NULL) {
    angle_min_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.angle_min)
  return angle_min_;
}
::choreo::Float32* LaserScan::release_angle_min() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.angle_min)
  
  ::choreo::Float32* temp = angle_min_;
  angle_min_ = NULL;
  return temp;
}
void LaserScan::set_allocated_angle_min(::choreo::Float32* angle_min) {
  delete angle_min_;
  angle_min_ = angle_min;
  if (angle_min) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.angle_min)
}

// .choreo.Float32 angle_max = 3;
bool LaserScan::has_angle_max() const {
  return this != internal_default_instance() && angle_max_ != NULL;
}
void LaserScan::clear_angle_max() {
  if (GetArenaNoVirtual() == NULL && angle_max_ != NULL) delete angle_max_;
  angle_max_ = NULL;
}
const ::choreo::Float32& LaserScan::angle_max() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.angle_max)
  return angle_max_ != NULL ? *angle_max_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* LaserScan::mutable_angle_max() {
  
  if (angle_max_ == NULL) {
    angle_max_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.angle_max)
  return angle_max_;
}
::choreo::Float32* LaserScan::release_angle_max() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.angle_max)
  
  ::choreo::Float32* temp = angle_max_;
  angle_max_ = NULL;
  return temp;
}
void LaserScan::set_allocated_angle_max(::choreo::Float32* angle_max) {
  delete angle_max_;
  angle_max_ = angle_max;
  if (angle_max) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.angle_max)
}

// .choreo.Float32 angle_increment = 4;
bool LaserScan::has_angle_increment() const {
  return this != internal_default_instance() && angle_increment_ != NULL;
}
void LaserScan::clear_angle_increment() {
  if (GetArenaNoVirtual() == NULL && angle_increment_ != NULL) delete angle_increment_;
  angle_increment_ = NULL;
}
const ::choreo::Float32& LaserScan::angle_increment() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.angle_increment)
  return angle_increment_ != NULL ? *angle_increment_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* LaserScan::mutable_angle_increment() {
  
  if (angle_increment_ == NULL) {
    angle_increment_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.angle_increment)
  return angle_increment_;
}
::choreo::Float32* LaserScan::release_angle_increment() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.angle_increment)
  
  ::choreo::Float32* temp = angle_increment_;
  angle_increment_ = NULL;
  return temp;
}
void LaserScan::set_allocated_angle_increment(::choreo::Float32* angle_increment) {
  delete angle_increment_;
  angle_increment_ = angle_increment;
  if (angle_increment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.angle_increment)
}

// .choreo.Float32 time_increment = 5;
bool LaserScan::has_time_increment() const {
  return this != internal_default_instance() && time_increment_ != NULL;
}
void LaserScan::clear_time_increment() {
  if (GetArenaNoVirtual() == NULL && time_increment_ != NULL) delete time_increment_;
  time_increment_ = NULL;
}
const ::choreo::Float32& LaserScan::time_increment() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.time_increment)
  return time_increment_ != NULL ? *time_increment_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* LaserScan::mutable_time_increment() {
  
  if (time_increment_ == NULL) {
    time_increment_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.time_increment)
  return time_increment_;
}
::choreo::Float32* LaserScan::release_time_increment() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.time_increment)
  
  ::choreo::Float32* temp = time_increment_;
  time_increment_ = NULL;
  return temp;
}
void LaserScan::set_allocated_time_increment(::choreo::Float32* time_increment) {
  delete time_increment_;
  time_increment_ = time_increment;
  if (time_increment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.time_increment)
}

// .choreo.Float32 scan_time = 6;
bool LaserScan::has_scan_time() const {
  return this != internal_default_instance() && scan_time_ != NULL;
}
void LaserScan::clear_scan_time() {
  if (GetArenaNoVirtual() == NULL && scan_time_ != NULL) delete scan_time_;
  scan_time_ = NULL;
}
const ::choreo::Float32& LaserScan::scan_time() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.scan_time)
  return scan_time_ != NULL ? *scan_time_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* LaserScan::mutable_scan_time() {
  
  if (scan_time_ == NULL) {
    scan_time_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.scan_time)
  return scan_time_;
}
::choreo::Float32* LaserScan::release_scan_time() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.scan_time)
  
  ::choreo::Float32* temp = scan_time_;
  scan_time_ = NULL;
  return temp;
}
void LaserScan::set_allocated_scan_time(::choreo::Float32* scan_time) {
  delete scan_time_;
  scan_time_ = scan_time;
  if (scan_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.scan_time)
}

// .choreo.Float32 range_min = 7;
bool LaserScan::has_range_min() const {
  return this != internal_default_instance() && range_min_ != NULL;
}
void LaserScan::clear_range_min() {
  if (GetArenaNoVirtual() == NULL && range_min_ != NULL) delete range_min_;
  range_min_ = NULL;
}
const ::choreo::Float32& LaserScan::range_min() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.range_min)
  return range_min_ != NULL ? *range_min_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* LaserScan::mutable_range_min() {
  
  if (range_min_ == NULL) {
    range_min_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.range_min)
  return range_min_;
}
::choreo::Float32* LaserScan::release_range_min() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.range_min)
  
  ::choreo::Float32* temp = range_min_;
  range_min_ = NULL;
  return temp;
}
void LaserScan::set_allocated_range_min(::choreo::Float32* range_min) {
  delete range_min_;
  range_min_ = range_min;
  if (range_min) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.range_min)
}

// .choreo.Float32 range_max = 8;
bool LaserScan::has_range_max() const {
  return this != internal_default_instance() && range_max_ != NULL;
}
void LaserScan::clear_range_max() {
  if (GetArenaNoVirtual() == NULL && range_max_ != NULL) delete range_max_;
  range_max_ = NULL;
}
const ::choreo::Float32& LaserScan::range_max() const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.range_max)
  return range_max_ != NULL ? *range_max_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* LaserScan::mutable_range_max() {
  
  if (range_max_ == NULL) {
    range_max_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.range_max)
  return range_max_;
}
::choreo::Float32* LaserScan::release_range_max() {
  // @@protoc_insertion_point(field_release:choreo.LaserScan.range_max)
  
  ::choreo::Float32* temp = range_max_;
  range_max_ = NULL;
  return temp;
}
void LaserScan::set_allocated_range_max(::choreo::Float32* range_max) {
  delete range_max_;
  range_max_ = range_max;
  if (range_max) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.LaserScan.range_max)
}

// repeated .choreo.Float32 ranges = 9;
int LaserScan::ranges_size() const {
  return ranges_.size();
}
void LaserScan::clear_ranges() {
  ranges_.Clear();
}
const ::choreo::Float32& LaserScan::ranges(int index) const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.ranges)
  return ranges_.Get(index);
}
::choreo::Float32* LaserScan::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.ranges)
  return ranges_.Mutable(index);
}
::choreo::Float32* LaserScan::add_ranges() {
  // @@protoc_insertion_point(field_add:choreo.LaserScan.ranges)
  return ranges_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::Float32 >*
LaserScan::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:choreo.LaserScan.ranges)
  return &ranges_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >&
LaserScan::ranges() const {
  // @@protoc_insertion_point(field_list:choreo.LaserScan.ranges)
  return ranges_;
}

// repeated .choreo.Float32 intensities = 10;
int LaserScan::intensities_size() const {
  return intensities_.size();
}
void LaserScan::clear_intensities() {
  intensities_.Clear();
}
const ::choreo::Float32& LaserScan::intensities(int index) const {
  // @@protoc_insertion_point(field_get:choreo.LaserScan.intensities)
  return intensities_.Get(index);
}
::choreo::Float32* LaserScan::mutable_intensities(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.LaserScan.intensities)
  return intensities_.Mutable(index);
}
::choreo::Float32* LaserScan::add_intensities() {
  // @@protoc_insertion_point(field_add:choreo.LaserScan.intensities)
  return intensities_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::Float32 >*
LaserScan::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:choreo.LaserScan.intensities)
  return &intensities_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::Float32 >&
LaserScan::intensities() const {
  // @@protoc_insertion_point(field_list:choreo.LaserScan.intensities)
  return intensities_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MultiEchoLaserScan::kHeaderFieldNumber;
const int MultiEchoLaserScan::kAngleMinFieldNumber;
const int MultiEchoLaserScan::kAngleMaxFieldNumber;
const int MultiEchoLaserScan::kAngleIncrementFieldNumber;
const int MultiEchoLaserScan::kTimeIncrementFieldNumber;
const int MultiEchoLaserScan::kScanTimeFieldNumber;
const int MultiEchoLaserScan::kRangeMinFieldNumber;
const int MultiEchoLaserScan::kRangeMaxFieldNumber;
const int MultiEchoLaserScan::kRangesFieldNumber;
const int MultiEchoLaserScan::kIntensitiesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MultiEchoLaserScan::MultiEchoLaserScan()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_sensor_2fdepth_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.MultiEchoLaserScan)
}
MultiEchoLaserScan::MultiEchoLaserScan(const MultiEchoLaserScan& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      ranges_(from.ranges_),
      intensities_(from.intensities_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_angle_min()) {
    angle_min_ = new ::choreo::Float32(*from.angle_min_);
  } else {
    angle_min_ = NULL;
  }
  if (from.has_angle_max()) {
    angle_max_ = new ::choreo::Float32(*from.angle_max_);
  } else {
    angle_max_ = NULL;
  }
  if (from.has_angle_increment()) {
    angle_increment_ = new ::choreo::Float32(*from.angle_increment_);
  } else {
    angle_increment_ = NULL;
  }
  if (from.has_time_increment()) {
    time_increment_ = new ::choreo::Float32(*from.time_increment_);
  } else {
    time_increment_ = NULL;
  }
  if (from.has_scan_time()) {
    scan_time_ = new ::choreo::Float32(*from.scan_time_);
  } else {
    scan_time_ = NULL;
  }
  if (from.has_range_min()) {
    range_min_ = new ::choreo::Float32(*from.range_min_);
  } else {
    range_min_ = NULL;
  }
  if (from.has_range_max()) {
    range_max_ = new ::choreo::Float32(*from.range_max_);
  } else {
    range_max_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.MultiEchoLaserScan)
}

void MultiEchoLaserScan::SharedCtor() {
  ::memset(&header_, 0, reinterpret_cast<char*>(&range_max_) -
    reinterpret_cast<char*>(&header_) + sizeof(range_max_));
  _cached_size_ = 0;
}

MultiEchoLaserScan::~MultiEchoLaserScan() {
  // @@protoc_insertion_point(destructor:choreo.MultiEchoLaserScan)
  SharedDtor();
}

void MultiEchoLaserScan::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete angle_min_;
  }
  if (this != internal_default_instance()) {
    delete angle_max_;
  }
  if (this != internal_default_instance()) {
    delete angle_increment_;
  }
  if (this != internal_default_instance()) {
    delete time_increment_;
  }
  if (this != internal_default_instance()) {
    delete scan_time_;
  }
  if (this != internal_default_instance()) {
    delete range_min_;
  }
  if (this != internal_default_instance()) {
    delete range_max_;
  }
}

void MultiEchoLaserScan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MultiEchoLaserScan::descriptor() {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const MultiEchoLaserScan& MultiEchoLaserScan::default_instance() {
  protobuf_sensor_2fdepth_2eproto::InitDefaults();
  return *internal_default_instance();
}

MultiEchoLaserScan* MultiEchoLaserScan::New(::google::protobuf::Arena* arena) const {
  MultiEchoLaserScan* n = new MultiEchoLaserScan;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MultiEchoLaserScan::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.MultiEchoLaserScan)
  ranges_.Clear();
  intensities_.Clear();
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && angle_min_ != NULL) {
    delete angle_min_;
  }
  angle_min_ = NULL;
  if (GetArenaNoVirtual() == NULL && angle_max_ != NULL) {
    delete angle_max_;
  }
  angle_max_ = NULL;
  if (GetArenaNoVirtual() == NULL && angle_increment_ != NULL) {
    delete angle_increment_;
  }
  angle_increment_ = NULL;
  if (GetArenaNoVirtual() == NULL && time_increment_ != NULL) {
    delete time_increment_;
  }
  time_increment_ = NULL;
  if (GetArenaNoVirtual() == NULL && scan_time_ != NULL) {
    delete scan_time_;
  }
  scan_time_ = NULL;
  if (GetArenaNoVirtual() == NULL && range_min_ != NULL) {
    delete range_min_;
  }
  range_min_ = NULL;
  if (GetArenaNoVirtual() == NULL && range_max_ != NULL) {
    delete range_max_;
  }
  range_max_ = NULL;
}

bool MultiEchoLaserScan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.MultiEchoLaserScan)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 angle_min = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angle_min()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 angle_max = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angle_max()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 angle_increment = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angle_increment()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 time_increment = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_time_increment()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 scan_time = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scan_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 range_min = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_min()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 range_max = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_max()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.LaserEcho ranges = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ranges()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.LaserEcho intensities = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_intensities()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.MultiEchoLaserScan)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.MultiEchoLaserScan)
  return false;
#undef DO_
}

void MultiEchoLaserScan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.MultiEchoLaserScan)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .choreo.Float32 angle_min = 2;
  if (this->has_angle_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->angle_min_, output);
  }

  // .choreo.Float32 angle_max = 3;
  if (this->has_angle_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->angle_max_, output);
  }

  // .choreo.Float32 angle_increment = 4;
  if (this->has_angle_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->angle_increment_, output);
  }

  // .choreo.Float32 time_increment = 5;
  if (this->has_time_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->time_increment_, output);
  }

  // .choreo.Float32 scan_time = 6;
  if (this->has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->scan_time_, output);
  }

  // .choreo.Float32 range_min = 7;
  if (this->has_range_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->range_min_, output);
  }

  // .choreo.Float32 range_max = 8;
  if (this->has_range_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->range_max_, output);
  }

  // repeated .choreo.LaserEcho ranges = 9;
  for (unsigned int i = 0, n = this->ranges_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->ranges(i), output);
  }

  // repeated .choreo.LaserEcho intensities = 10;
  for (unsigned int i = 0, n = this->intensities_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->intensities(i), output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.MultiEchoLaserScan)
}

::google::protobuf::uint8* MultiEchoLaserScan::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.MultiEchoLaserScan)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // .choreo.Float32 angle_min = 2;
  if (this->has_angle_min()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->angle_min_, deterministic, target);
  }

  // .choreo.Float32 angle_max = 3;
  if (this->has_angle_max()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->angle_max_, deterministic, target);
  }

  // .choreo.Float32 angle_increment = 4;
  if (this->has_angle_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->angle_increment_, deterministic, target);
  }

  // .choreo.Float32 time_increment = 5;
  if (this->has_time_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->time_increment_, deterministic, target);
  }

  // .choreo.Float32 scan_time = 6;
  if (this->has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->scan_time_, deterministic, target);
  }

  // .choreo.Float32 range_min = 7;
  if (this->has_range_min()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->range_min_, deterministic, target);
  }

  // .choreo.Float32 range_max = 8;
  if (this->has_range_max()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->range_max_, deterministic, target);
  }

  // repeated .choreo.LaserEcho ranges = 9;
  for (unsigned int i = 0, n = this->ranges_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, this->ranges(i), deterministic, target);
  }

  // repeated .choreo.LaserEcho intensities = 10;
  for (unsigned int i = 0, n = this->intensities_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, this->intensities(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.MultiEchoLaserScan)
  return target;
}

size_t MultiEchoLaserScan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.MultiEchoLaserScan)
  size_t total_size = 0;

  // repeated .choreo.LaserEcho ranges = 9;
  {
    unsigned int count = this->ranges_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ranges(i));
    }
  }

  // repeated .choreo.LaserEcho intensities = 10;
  {
    unsigned int count = this->intensities_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->intensities(i));
    }
  }

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // .choreo.Float32 angle_min = 2;
  if (this->has_angle_min()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->angle_min_);
  }

  // .choreo.Float32 angle_max = 3;
  if (this->has_angle_max()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->angle_max_);
  }

  // .choreo.Float32 angle_increment = 4;
  if (this->has_angle_increment()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->angle_increment_);
  }

  // .choreo.Float32 time_increment = 5;
  if (this->has_time_increment()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->time_increment_);
  }

  // .choreo.Float32 scan_time = 6;
  if (this->has_scan_time()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->scan_time_);
  }

  // .choreo.Float32 range_min = 7;
  if (this->has_range_min()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->range_min_);
  }

  // .choreo.Float32 range_max = 8;
  if (this->has_range_max()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->range_max_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MultiEchoLaserScan::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.MultiEchoLaserScan)
  GOOGLE_DCHECK_NE(&from, this);
  const MultiEchoLaserScan* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const MultiEchoLaserScan>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.MultiEchoLaserScan)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.MultiEchoLaserScan)
    MergeFrom(*source);
  }
}

void MultiEchoLaserScan::MergeFrom(const MultiEchoLaserScan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.MultiEchoLaserScan)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  ranges_.MergeFrom(from.ranges_);
  intensities_.MergeFrom(from.intensities_);
  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
  if (from.has_angle_min()) {
    mutable_angle_min()->::choreo::Float32::MergeFrom(from.angle_min());
  }
  if (from.has_angle_max()) {
    mutable_angle_max()->::choreo::Float32::MergeFrom(from.angle_max());
  }
  if (from.has_angle_increment()) {
    mutable_angle_increment()->::choreo::Float32::MergeFrom(from.angle_increment());
  }
  if (from.has_time_increment()) {
    mutable_time_increment()->::choreo::Float32::MergeFrom(from.time_increment());
  }
  if (from.has_scan_time()) {
    mutable_scan_time()->::choreo::Float32::MergeFrom(from.scan_time());
  }
  if (from.has_range_min()) {
    mutable_range_min()->::choreo::Float32::MergeFrom(from.range_min());
  }
  if (from.has_range_max()) {
    mutable_range_max()->::choreo::Float32::MergeFrom(from.range_max());
  }
}

void MultiEchoLaserScan::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.MultiEchoLaserScan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MultiEchoLaserScan::CopyFrom(const MultiEchoLaserScan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.MultiEchoLaserScan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultiEchoLaserScan::IsInitialized() const {
  return true;
}

void MultiEchoLaserScan::Swap(MultiEchoLaserScan* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MultiEchoLaserScan::InternalSwap(MultiEchoLaserScan* other) {
  ranges_.InternalSwap(&other->ranges_);
  intensities_.InternalSwap(&other->intensities_);
  std::swap(header_, other->header_);
  std::swap(angle_min_, other->angle_min_);
  std::swap(angle_max_, other->angle_max_);
  std::swap(angle_increment_, other->angle_increment_);
  std::swap(time_increment_, other->time_increment_);
  std::swap(scan_time_, other->scan_time_);
  std::swap(range_min_, other->range_min_);
  std::swap(range_max_, other->range_max_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MultiEchoLaserScan::GetMetadata() const {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MultiEchoLaserScan

// .choreo.Header header = 1;
bool MultiEchoLaserScan::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void MultiEchoLaserScan::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& MultiEchoLaserScan::header() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* MultiEchoLaserScan::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.header)
  return header_;
}
::choreo::Header* MultiEchoLaserScan::release_header() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void MultiEchoLaserScan::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.header)
}

// .choreo.Float32 angle_min = 2;
bool MultiEchoLaserScan::has_angle_min() const {
  return this != internal_default_instance() && angle_min_ != NULL;
}
void MultiEchoLaserScan::clear_angle_min() {
  if (GetArenaNoVirtual() == NULL && angle_min_ != NULL) delete angle_min_;
  angle_min_ = NULL;
}
const ::choreo::Float32& MultiEchoLaserScan::angle_min() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.angle_min)
  return angle_min_ != NULL ? *angle_min_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* MultiEchoLaserScan::mutable_angle_min() {
  
  if (angle_min_ == NULL) {
    angle_min_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.angle_min)
  return angle_min_;
}
::choreo::Float32* MultiEchoLaserScan::release_angle_min() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.angle_min)
  
  ::choreo::Float32* temp = angle_min_;
  angle_min_ = NULL;
  return temp;
}
void MultiEchoLaserScan::set_allocated_angle_min(::choreo::Float32* angle_min) {
  delete angle_min_;
  angle_min_ = angle_min;
  if (angle_min) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.angle_min)
}

// .choreo.Float32 angle_max = 3;
bool MultiEchoLaserScan::has_angle_max() const {
  return this != internal_default_instance() && angle_max_ != NULL;
}
void MultiEchoLaserScan::clear_angle_max() {
  if (GetArenaNoVirtual() == NULL && angle_max_ != NULL) delete angle_max_;
  angle_max_ = NULL;
}
const ::choreo::Float32& MultiEchoLaserScan::angle_max() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.angle_max)
  return angle_max_ != NULL ? *angle_max_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* MultiEchoLaserScan::mutable_angle_max() {
  
  if (angle_max_ == NULL) {
    angle_max_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.angle_max)
  return angle_max_;
}
::choreo::Float32* MultiEchoLaserScan::release_angle_max() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.angle_max)
  
  ::choreo::Float32* temp = angle_max_;
  angle_max_ = NULL;
  return temp;
}
void MultiEchoLaserScan::set_allocated_angle_max(::choreo::Float32* angle_max) {
  delete angle_max_;
  angle_max_ = angle_max;
  if (angle_max) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.angle_max)
}

// .choreo.Float32 angle_increment = 4;
bool MultiEchoLaserScan::has_angle_increment() const {
  return this != internal_default_instance() && angle_increment_ != NULL;
}
void MultiEchoLaserScan::clear_angle_increment() {
  if (GetArenaNoVirtual() == NULL && angle_increment_ != NULL) delete angle_increment_;
  angle_increment_ = NULL;
}
const ::choreo::Float32& MultiEchoLaserScan::angle_increment() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.angle_increment)
  return angle_increment_ != NULL ? *angle_increment_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* MultiEchoLaserScan::mutable_angle_increment() {
  
  if (angle_increment_ == NULL) {
    angle_increment_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.angle_increment)
  return angle_increment_;
}
::choreo::Float32* MultiEchoLaserScan::release_angle_increment() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.angle_increment)
  
  ::choreo::Float32* temp = angle_increment_;
  angle_increment_ = NULL;
  return temp;
}
void MultiEchoLaserScan::set_allocated_angle_increment(::choreo::Float32* angle_increment) {
  delete angle_increment_;
  angle_increment_ = angle_increment;
  if (angle_increment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.angle_increment)
}

// .choreo.Float32 time_increment = 5;
bool MultiEchoLaserScan::has_time_increment() const {
  return this != internal_default_instance() && time_increment_ != NULL;
}
void MultiEchoLaserScan::clear_time_increment() {
  if (GetArenaNoVirtual() == NULL && time_increment_ != NULL) delete time_increment_;
  time_increment_ = NULL;
}
const ::choreo::Float32& MultiEchoLaserScan::time_increment() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.time_increment)
  return time_increment_ != NULL ? *time_increment_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* MultiEchoLaserScan::mutable_time_increment() {
  
  if (time_increment_ == NULL) {
    time_increment_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.time_increment)
  return time_increment_;
}
::choreo::Float32* MultiEchoLaserScan::release_time_increment() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.time_increment)
  
  ::choreo::Float32* temp = time_increment_;
  time_increment_ = NULL;
  return temp;
}
void MultiEchoLaserScan::set_allocated_time_increment(::choreo::Float32* time_increment) {
  delete time_increment_;
  time_increment_ = time_increment;
  if (time_increment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.time_increment)
}

// .choreo.Float32 scan_time = 6;
bool MultiEchoLaserScan::has_scan_time() const {
  return this != internal_default_instance() && scan_time_ != NULL;
}
void MultiEchoLaserScan::clear_scan_time() {
  if (GetArenaNoVirtual() == NULL && scan_time_ != NULL) delete scan_time_;
  scan_time_ = NULL;
}
const ::choreo::Float32& MultiEchoLaserScan::scan_time() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.scan_time)
  return scan_time_ != NULL ? *scan_time_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* MultiEchoLaserScan::mutable_scan_time() {
  
  if (scan_time_ == NULL) {
    scan_time_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.scan_time)
  return scan_time_;
}
::choreo::Float32* MultiEchoLaserScan::release_scan_time() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.scan_time)
  
  ::choreo::Float32* temp = scan_time_;
  scan_time_ = NULL;
  return temp;
}
void MultiEchoLaserScan::set_allocated_scan_time(::choreo::Float32* scan_time) {
  delete scan_time_;
  scan_time_ = scan_time;
  if (scan_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.scan_time)
}

// .choreo.Float32 range_min = 7;
bool MultiEchoLaserScan::has_range_min() const {
  return this != internal_default_instance() && range_min_ != NULL;
}
void MultiEchoLaserScan::clear_range_min() {
  if (GetArenaNoVirtual() == NULL && range_min_ != NULL) delete range_min_;
  range_min_ = NULL;
}
const ::choreo::Float32& MultiEchoLaserScan::range_min() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.range_min)
  return range_min_ != NULL ? *range_min_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* MultiEchoLaserScan::mutable_range_min() {
  
  if (range_min_ == NULL) {
    range_min_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.range_min)
  return range_min_;
}
::choreo::Float32* MultiEchoLaserScan::release_range_min() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.range_min)
  
  ::choreo::Float32* temp = range_min_;
  range_min_ = NULL;
  return temp;
}
void MultiEchoLaserScan::set_allocated_range_min(::choreo::Float32* range_min) {
  delete range_min_;
  range_min_ = range_min;
  if (range_min) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.range_min)
}

// .choreo.Float32 range_max = 8;
bool MultiEchoLaserScan::has_range_max() const {
  return this != internal_default_instance() && range_max_ != NULL;
}
void MultiEchoLaserScan::clear_range_max() {
  if (GetArenaNoVirtual() == NULL && range_max_ != NULL) delete range_max_;
  range_max_ = NULL;
}
const ::choreo::Float32& MultiEchoLaserScan::range_max() const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.range_max)
  return range_max_ != NULL ? *range_max_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* MultiEchoLaserScan::mutable_range_max() {
  
  if (range_max_ == NULL) {
    range_max_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.range_max)
  return range_max_;
}
::choreo::Float32* MultiEchoLaserScan::release_range_max() {
  // @@protoc_insertion_point(field_release:choreo.MultiEchoLaserScan.range_max)
  
  ::choreo::Float32* temp = range_max_;
  range_max_ = NULL;
  return temp;
}
void MultiEchoLaserScan::set_allocated_range_max(::choreo::Float32* range_max) {
  delete range_max_;
  range_max_ = range_max;
  if (range_max) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MultiEchoLaserScan.range_max)
}

// repeated .choreo.LaserEcho ranges = 9;
int MultiEchoLaserScan::ranges_size() const {
  return ranges_.size();
}
void MultiEchoLaserScan::clear_ranges() {
  ranges_.Clear();
}
const ::choreo::LaserEcho& MultiEchoLaserScan::ranges(int index) const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.ranges)
  return ranges_.Get(index);
}
::choreo::LaserEcho* MultiEchoLaserScan::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.ranges)
  return ranges_.Mutable(index);
}
::choreo::LaserEcho* MultiEchoLaserScan::add_ranges() {
  // @@protoc_insertion_point(field_add:choreo.MultiEchoLaserScan.ranges)
  return ranges_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho >*
MultiEchoLaserScan::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:choreo.MultiEchoLaserScan.ranges)
  return &ranges_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho >&
MultiEchoLaserScan::ranges() const {
  // @@protoc_insertion_point(field_list:choreo.MultiEchoLaserScan.ranges)
  return ranges_;
}

// repeated .choreo.LaserEcho intensities = 10;
int MultiEchoLaserScan::intensities_size() const {
  return intensities_.size();
}
void MultiEchoLaserScan::clear_intensities() {
  intensities_.Clear();
}
const ::choreo::LaserEcho& MultiEchoLaserScan::intensities(int index) const {
  // @@protoc_insertion_point(field_get:choreo.MultiEchoLaserScan.intensities)
  return intensities_.Get(index);
}
::choreo::LaserEcho* MultiEchoLaserScan::mutable_intensities(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.MultiEchoLaserScan.intensities)
  return intensities_.Mutable(index);
}
::choreo::LaserEcho* MultiEchoLaserScan::add_intensities() {
  // @@protoc_insertion_point(field_add:choreo.MultiEchoLaserScan.intensities)
  return intensities_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho >*
MultiEchoLaserScan::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:choreo.MultiEchoLaserScan.intensities)
  return &intensities_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::LaserEcho >&
MultiEchoLaserScan::intensities() const {
  // @@protoc_insertion_point(field_list:choreo.MultiEchoLaserScan.intensities)
  return intensities_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PointField::kNameFieldNumber;
const int PointField::kOffsetFieldNumber;
const int PointField::kDatatypeFieldNumber;
const int PointField::kCountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PointField::PointField()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_sensor_2fdepth_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.PointField)
}
PointField::PointField(const PointField& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_name()) {
    name_ = new ::choreo::String(*from.name_);
  } else {
    name_ = NULL;
  }
  if (from.has_offset()) {
    offset_ = new ::choreo::UInt32(*from.offset_);
  } else {
    offset_ = NULL;
  }
  if (from.has_count()) {
    count_ = new ::choreo::UInt32(*from.count_);
  } else {
    count_ = NULL;
  }
  datatype_ = from.datatype_;
  // @@protoc_insertion_point(copy_constructor:choreo.PointField)
}

void PointField::SharedCtor() {
  ::memset(&name_, 0, reinterpret_cast<char*>(&datatype_) -
    reinterpret_cast<char*>(&name_) + sizeof(datatype_));
  _cached_size_ = 0;
}

PointField::~PointField() {
  // @@protoc_insertion_point(destructor:choreo.PointField)
  SharedDtor();
}

void PointField::SharedDtor() {
  if (this != internal_default_instance()) {
    delete name_;
  }
  if (this != internal_default_instance()) {
    delete offset_;
  }
  if (this != internal_default_instance()) {
    delete count_;
  }
}

void PointField::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PointField::descriptor() {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PointField& PointField::default_instance() {
  protobuf_sensor_2fdepth_2eproto::InitDefaults();
  return *internal_default_instance();
}

PointField* PointField::New(::google::protobuf::Arena* arena) const {
  PointField* n = new PointField;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PointField::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.PointField)
  if (GetArenaNoVirtual() == NULL && name_ != NULL) {
    delete name_;
  }
  name_ = NULL;
  if (GetArenaNoVirtual() == NULL && offset_ != NULL) {
    delete offset_;
  }
  offset_ = NULL;
  if (GetArenaNoVirtual() == NULL && count_ != NULL) {
    delete count_;
  }
  count_ = NULL;
  datatype_ = 0;
}

bool PointField::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.PointField)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.String name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 offset = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_offset()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.PointField.Datatype datatype = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_datatype(static_cast< ::choreo::PointField_Datatype >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 count = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_count()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.PointField)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.PointField)
  return false;
#undef DO_
}

void PointField::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.PointField)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.String name = 1;
  if (this->has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->name_, output);
  }

  // .choreo.UInt32 offset = 2;
  if (this->has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->offset_, output);
  }

  // .choreo.PointField.Datatype datatype = 3;
  if (this->datatype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->datatype(), output);
  }

  // .choreo.UInt32 count = 4;
  if (this->has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->count_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.PointField)
}

::google::protobuf::uint8* PointField::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.PointField)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.String name = 1;
  if (this->has_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->name_, deterministic, target);
  }

  // .choreo.UInt32 offset = 2;
  if (this->has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->offset_, deterministic, target);
  }

  // .choreo.PointField.Datatype datatype = 3;
  if (this->datatype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->datatype(), target);
  }

  // .choreo.UInt32 count = 4;
  if (this->has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->count_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.PointField)
  return target;
}

size_t PointField::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.PointField)
  size_t total_size = 0;

  // .choreo.String name = 1;
  if (this->has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->name_);
  }

  // .choreo.UInt32 offset = 2;
  if (this->has_offset()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->offset_);
  }

  // .choreo.UInt32 count = 4;
  if (this->has_count()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->count_);
  }

  // .choreo.PointField.Datatype datatype = 3;
  if (this->datatype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->datatype());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PointField::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.PointField)
  GOOGLE_DCHECK_NE(&from, this);
  const PointField* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PointField>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.PointField)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.PointField)
    MergeFrom(*source);
  }
}

void PointField::MergeFrom(const PointField& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.PointField)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_name()) {
    mutable_name()->::choreo::String::MergeFrom(from.name());
  }
  if (from.has_offset()) {
    mutable_offset()->::choreo::UInt32::MergeFrom(from.offset());
  }
  if (from.has_count()) {
    mutable_count()->::choreo::UInt32::MergeFrom(from.count());
  }
  if (from.datatype() != 0) {
    set_datatype(from.datatype());
  }
}

void PointField::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.PointField)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PointField::CopyFrom(const PointField& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.PointField)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointField::IsInitialized() const {
  return true;
}

void PointField::Swap(PointField* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PointField::InternalSwap(PointField* other) {
  std::swap(name_, other->name_);
  std::swap(offset_, other->offset_);
  std::swap(count_, other->count_);
  std::swap(datatype_, other->datatype_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PointField::GetMetadata() const {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PointField

// .choreo.String name = 1;
bool PointField::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
void PointField::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) delete name_;
  name_ = NULL;
}
const ::choreo::String& PointField::name() const {
  // @@protoc_insertion_point(field_get:choreo.PointField.name)
  return name_ != NULL ? *name_
                         : *::choreo::String::internal_default_instance();
}
::choreo::String* PointField::mutable_name() {
  
  if (name_ == NULL) {
    name_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointField.name)
  return name_;
}
::choreo::String* PointField::release_name() {
  // @@protoc_insertion_point(field_release:choreo.PointField.name)
  
  ::choreo::String* temp = name_;
  name_ = NULL;
  return temp;
}
void PointField::set_allocated_name(::choreo::String* name) {
  delete name_;
  name_ = name;
  if (name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointField.name)
}

// .choreo.UInt32 offset = 2;
bool PointField::has_offset() const {
  return this != internal_default_instance() && offset_ != NULL;
}
void PointField::clear_offset() {
  if (GetArenaNoVirtual() == NULL && offset_ != NULL) delete offset_;
  offset_ = NULL;
}
const ::choreo::UInt32& PointField::offset() const {
  // @@protoc_insertion_point(field_get:choreo.PointField.offset)
  return offset_ != NULL ? *offset_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* PointField::mutable_offset() {
  
  if (offset_ == NULL) {
    offset_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointField.offset)
  return offset_;
}
::choreo::UInt32* PointField::release_offset() {
  // @@protoc_insertion_point(field_release:choreo.PointField.offset)
  
  ::choreo::UInt32* temp = offset_;
  offset_ = NULL;
  return temp;
}
void PointField::set_allocated_offset(::choreo::UInt32* offset) {
  delete offset_;
  offset_ = offset;
  if (offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointField.offset)
}

// .choreo.PointField.Datatype datatype = 3;
void PointField::clear_datatype() {
  datatype_ = 0;
}
::choreo::PointField_Datatype PointField::datatype() const {
  // @@protoc_insertion_point(field_get:choreo.PointField.datatype)
  return static_cast< ::choreo::PointField_Datatype >(datatype_);
}
void PointField::set_datatype(::choreo::PointField_Datatype value) {
  
  datatype_ = value;
  // @@protoc_insertion_point(field_set:choreo.PointField.datatype)
}

// .choreo.UInt32 count = 4;
bool PointField::has_count() const {
  return this != internal_default_instance() && count_ != NULL;
}
void PointField::clear_count() {
  if (GetArenaNoVirtual() == NULL && count_ != NULL) delete count_;
  count_ = NULL;
}
const ::choreo::UInt32& PointField::count() const {
  // @@protoc_insertion_point(field_get:choreo.PointField.count)
  return count_ != NULL ? *count_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* PointField::mutable_count() {
  
  if (count_ == NULL) {
    count_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointField.count)
  return count_;
}
::choreo::UInt32* PointField::release_count() {
  // @@protoc_insertion_point(field_release:choreo.PointField.count)
  
  ::choreo::UInt32* temp = count_;
  count_ = NULL;
  return temp;
}
void PointField::set_allocated_count(::choreo::UInt32* count) {
  delete count_;
  count_ = count;
  if (count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointField.count)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PointCloud::kHeaderFieldNumber;
const int PointCloud::kPointsFieldNumber;
const int PointCloud::kChannelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PointCloud::PointCloud()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_sensor_2fdepth_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.PointCloud)
}
PointCloud::PointCloud(const PointCloud& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      points_(from.points_),
      channels_(from.channels_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.PointCloud)
}

void PointCloud::SharedCtor() {
  header_ = NULL;
  _cached_size_ = 0;
}

PointCloud::~PointCloud() {
  // @@protoc_insertion_point(destructor:choreo.PointCloud)
  SharedDtor();
}

void PointCloud::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
}

void PointCloud::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PointCloud::descriptor() {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PointCloud& PointCloud::default_instance() {
  protobuf_sensor_2fdepth_2eproto::InitDefaults();
  return *internal_default_instance();
}

PointCloud* PointCloud::New(::google::protobuf::Arena* arena) const {
  PointCloud* n = new PointCloud;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PointCloud::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.PointCloud)
  points_.Clear();
  channels_.Clear();
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}

bool PointCloud::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.PointCloud)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.Point32 points = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_points()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.ChannelFloat32 channels = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_channels()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.PointCloud)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.PointCloud)
  return false;
#undef DO_
}

void PointCloud::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.PointCloud)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .choreo.Point32 points = 2;
  for (unsigned int i = 0, n = this->points_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->points(i), output);
  }

  // repeated .choreo.ChannelFloat32 channels = 3;
  for (unsigned int i = 0, n = this->channels_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->channels(i), output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.PointCloud)
}

::google::protobuf::uint8* PointCloud::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.PointCloud)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // repeated .choreo.Point32 points = 2;
  for (unsigned int i = 0, n = this->points_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->points(i), deterministic, target);
  }

  // repeated .choreo.ChannelFloat32 channels = 3;
  for (unsigned int i = 0, n = this->channels_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->channels(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.PointCloud)
  return target;
}

size_t PointCloud::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.PointCloud)
  size_t total_size = 0;

  // repeated .choreo.Point32 points = 2;
  {
    unsigned int count = this->points_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->points(i));
    }
  }

  // repeated .choreo.ChannelFloat32 channels = 3;
  {
    unsigned int count = this->channels_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->channels(i));
    }
  }

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PointCloud::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.PointCloud)
  GOOGLE_DCHECK_NE(&from, this);
  const PointCloud* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PointCloud>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.PointCloud)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.PointCloud)
    MergeFrom(*source);
  }
}

void PointCloud::MergeFrom(const PointCloud& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.PointCloud)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  points_.MergeFrom(from.points_);
  channels_.MergeFrom(from.channels_);
  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
}

void PointCloud::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.PointCloud)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PointCloud::CopyFrom(const PointCloud& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.PointCloud)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointCloud::IsInitialized() const {
  return true;
}

void PointCloud::Swap(PointCloud* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PointCloud::InternalSwap(PointCloud* other) {
  points_.InternalSwap(&other->points_);
  channels_.InternalSwap(&other->channels_);
  std::swap(header_, other->header_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PointCloud::GetMetadata() const {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PointCloud

// .choreo.Header header = 1;
bool PointCloud::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void PointCloud::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& PointCloud::header() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* PointCloud::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud.header)
  return header_;
}
::choreo::Header* PointCloud::release_header() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void PointCloud::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud.header)
}

// repeated .choreo.Point32 points = 2;
int PointCloud::points_size() const {
  return points_.size();
}
void PointCloud::clear_points() {
  points_.Clear();
}
const ::choreo::Point32& PointCloud::points(int index) const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud.points)
  return points_.Get(index);
}
::choreo::Point32* PointCloud::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud.points)
  return points_.Mutable(index);
}
::choreo::Point32* PointCloud::add_points() {
  // @@protoc_insertion_point(field_add:choreo.PointCloud.points)
  return points_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::Point32 >*
PointCloud::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:choreo.PointCloud.points)
  return &points_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::Point32 >&
PointCloud::points() const {
  // @@protoc_insertion_point(field_list:choreo.PointCloud.points)
  return points_;
}

// repeated .choreo.ChannelFloat32 channels = 3;
int PointCloud::channels_size() const {
  return channels_.size();
}
void PointCloud::clear_channels() {
  channels_.Clear();
}
const ::choreo::ChannelFloat32& PointCloud::channels(int index) const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud.channels)
  return channels_.Get(index);
}
::choreo::ChannelFloat32* PointCloud::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud.channels)
  return channels_.Mutable(index);
}
::choreo::ChannelFloat32* PointCloud::add_channels() {
  // @@protoc_insertion_point(field_add:choreo.PointCloud.channels)
  return channels_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::ChannelFloat32 >*
PointCloud::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:choreo.PointCloud.channels)
  return &channels_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::ChannelFloat32 >&
PointCloud::channels() const {
  // @@protoc_insertion_point(field_list:choreo.PointCloud.channels)
  return channels_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PointCloud2::kHeaderFieldNumber;
const int PointCloud2::kHeightFieldNumber;
const int PointCloud2::kWidthFieldNumber;
const int PointCloud2::kFieldsFieldNumber;
const int PointCloud2::kIsBigendianFieldNumber;
const int PointCloud2::kPointStepFieldNumber;
const int PointCloud2::kRowStepFieldNumber;
const int PointCloud2::kDataFieldNumber;
const int PointCloud2::kIsDenseFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PointCloud2::PointCloud2()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_sensor_2fdepth_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.PointCloud2)
}
PointCloud2::PointCloud2(const PointCloud2& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      fields_(from.fields_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_height()) {
    height_ = new ::choreo::UInt32(*from.height_);
  } else {
    height_ = NULL;
  }
  if (from.has_width()) {
    width_ = new ::choreo::UInt32(*from.width_);
  } else {
    width_ = NULL;
  }
  if (from.has_is_bigendian()) {
    is_bigendian_ = new ::choreo::Bool(*from.is_bigendian_);
  } else {
    is_bigendian_ = NULL;
  }
  if (from.has_point_step()) {
    point_step_ = new ::choreo::UInt32(*from.point_step_);
  } else {
    point_step_ = NULL;
  }
  if (from.has_row_step()) {
    row_step_ = new ::choreo::UInt32(*from.row_step_);
  } else {
    row_step_ = NULL;
  }
  if (from.has_data()) {
    data_ = new ::choreo::Bytes(*from.data_);
  } else {
    data_ = NULL;
  }
  if (from.has_is_dense()) {
    is_dense_ = new ::choreo::Bool(*from.is_dense_);
  } else {
    is_dense_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.PointCloud2)
}

void PointCloud2::SharedCtor() {
  ::memset(&header_, 0, reinterpret_cast<char*>(&is_dense_) -
    reinterpret_cast<char*>(&header_) + sizeof(is_dense_));
  _cached_size_ = 0;
}

PointCloud2::~PointCloud2() {
  // @@protoc_insertion_point(destructor:choreo.PointCloud2)
  SharedDtor();
}

void PointCloud2::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete height_;
  }
  if (this != internal_default_instance()) {
    delete width_;
  }
  if (this != internal_default_instance()) {
    delete is_bigendian_;
  }
  if (this != internal_default_instance()) {
    delete point_step_;
  }
  if (this != internal_default_instance()) {
    delete row_step_;
  }
  if (this != internal_default_instance()) {
    delete data_;
  }
  if (this != internal_default_instance()) {
    delete is_dense_;
  }
}

void PointCloud2::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PointCloud2::descriptor() {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PointCloud2& PointCloud2::default_instance() {
  protobuf_sensor_2fdepth_2eproto::InitDefaults();
  return *internal_default_instance();
}

PointCloud2* PointCloud2::New(::google::protobuf::Arena* arena) const {
  PointCloud2* n = new PointCloud2;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PointCloud2::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.PointCloud2)
  fields_.Clear();
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && height_ != NULL) {
    delete height_;
  }
  height_ = NULL;
  if (GetArenaNoVirtual() == NULL && width_ != NULL) {
    delete width_;
  }
  width_ = NULL;
  if (GetArenaNoVirtual() == NULL && is_bigendian_ != NULL) {
    delete is_bigendian_;
  }
  is_bigendian_ = NULL;
  if (GetArenaNoVirtual() == NULL && point_step_ != NULL) {
    delete point_step_;
  }
  point_step_ = NULL;
  if (GetArenaNoVirtual() == NULL && row_step_ != NULL) {
    delete row_step_;
  }
  row_step_ = NULL;
  if (GetArenaNoVirtual() == NULL && data_ != NULL) {
    delete data_;
  }
  data_ = NULL;
  if (GetArenaNoVirtual() == NULL && is_dense_ != NULL) {
    delete is_dense_;
  }
  is_dense_ = NULL;
}

bool PointCloud2::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.PointCloud2)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 height = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_height()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 width = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_width()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.PointField fields = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_fields()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Bool is_bigendian = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_is_bigendian()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 point_step = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_point_step()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 row_step = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_row_step()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Bytes data = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Bool is_dense = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_is_dense()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.PointCloud2)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.PointCloud2)
  return false;
#undef DO_
}

void PointCloud2::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.PointCloud2)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .choreo.UInt32 height = 2;
  if (this->has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->height_, output);
  }

  // .choreo.UInt32 width = 3;
  if (this->has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->width_, output);
  }

  // repeated .choreo.PointField fields = 4;
  for (unsigned int i = 0, n = this->fields_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->fields(i), output);
  }

  // .choreo.Bool is_bigendian = 5;
  if (this->has_is_bigendian()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->is_bigendian_, output);
  }

  // .choreo.UInt32 point_step = 6;
  if (this->has_point_step()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->point_step_, output);
  }

  // .choreo.UInt32 row_step = 7;
  if (this->has_row_step()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->row_step_, output);
  }

  // .choreo.Bytes data = 8;
  if (this->has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->data_, output);
  }

  // .choreo.Bool is_dense = 9;
  if (this->has_is_dense()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->is_dense_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.PointCloud2)
}

::google::protobuf::uint8* PointCloud2::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.PointCloud2)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // .choreo.UInt32 height = 2;
  if (this->has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->height_, deterministic, target);
  }

  // .choreo.UInt32 width = 3;
  if (this->has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->width_, deterministic, target);
  }

  // repeated .choreo.PointField fields = 4;
  for (unsigned int i = 0, n = this->fields_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, this->fields(i), deterministic, target);
  }

  // .choreo.Bool is_bigendian = 5;
  if (this->has_is_bigendian()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->is_bigendian_, deterministic, target);
  }

  // .choreo.UInt32 point_step = 6;
  if (this->has_point_step()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->point_step_, deterministic, target);
  }

  // .choreo.UInt32 row_step = 7;
  if (this->has_row_step()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->row_step_, deterministic, target);
  }

  // .choreo.Bytes data = 8;
  if (this->has_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->data_, deterministic, target);
  }

  // .choreo.Bool is_dense = 9;
  if (this->has_is_dense()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *this->is_dense_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.PointCloud2)
  return target;
}

size_t PointCloud2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.PointCloud2)
  size_t total_size = 0;

  // repeated .choreo.PointField fields = 4;
  {
    unsigned int count = this->fields_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fields(i));
    }
  }

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // .choreo.UInt32 height = 2;
  if (this->has_height()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->height_);
  }

  // .choreo.UInt32 width = 3;
  if (this->has_width()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->width_);
  }

  // .choreo.Bool is_bigendian = 5;
  if (this->has_is_bigendian()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->is_bigendian_);
  }

  // .choreo.UInt32 point_step = 6;
  if (this->has_point_step()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->point_step_);
  }

  // .choreo.UInt32 row_step = 7;
  if (this->has_row_step()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->row_step_);
  }

  // .choreo.Bytes data = 8;
  if (this->has_data()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->data_);
  }

  // .choreo.Bool is_dense = 9;
  if (this->has_is_dense()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->is_dense_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PointCloud2::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.PointCloud2)
  GOOGLE_DCHECK_NE(&from, this);
  const PointCloud2* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PointCloud2>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.PointCloud2)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.PointCloud2)
    MergeFrom(*source);
  }
}

void PointCloud2::MergeFrom(const PointCloud2& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.PointCloud2)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  fields_.MergeFrom(from.fields_);
  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
  if (from.has_height()) {
    mutable_height()->::choreo::UInt32::MergeFrom(from.height());
  }
  if (from.has_width()) {
    mutable_width()->::choreo::UInt32::MergeFrom(from.width());
  }
  if (from.has_is_bigendian()) {
    mutable_is_bigendian()->::choreo::Bool::MergeFrom(from.is_bigendian());
  }
  if (from.has_point_step()) {
    mutable_point_step()->::choreo::UInt32::MergeFrom(from.point_step());
  }
  if (from.has_row_step()) {
    mutable_row_step()->::choreo::UInt32::MergeFrom(from.row_step());
  }
  if (from.has_data()) {
    mutable_data()->::choreo::Bytes::MergeFrom(from.data());
  }
  if (from.has_is_dense()) {
    mutable_is_dense()->::choreo::Bool::MergeFrom(from.is_dense());
  }
}

void PointCloud2::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.PointCloud2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PointCloud2::CopyFrom(const PointCloud2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.PointCloud2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointCloud2::IsInitialized() const {
  return true;
}

void PointCloud2::Swap(PointCloud2* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PointCloud2::InternalSwap(PointCloud2* other) {
  fields_.InternalSwap(&other->fields_);
  std::swap(header_, other->header_);
  std::swap(height_, other->height_);
  std::swap(width_, other->width_);
  std::swap(is_bigendian_, other->is_bigendian_);
  std::swap(point_step_, other->point_step_);
  std::swap(row_step_, other->row_step_);
  std::swap(data_, other->data_);
  std::swap(is_dense_, other->is_dense_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PointCloud2::GetMetadata() const {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PointCloud2

// .choreo.Header header = 1;
bool PointCloud2::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void PointCloud2::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& PointCloud2::header() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* PointCloud2::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.header)
  return header_;
}
::choreo::Header* PointCloud2::release_header() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void PointCloud2::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.header)
}

// .choreo.UInt32 height = 2;
bool PointCloud2::has_height() const {
  return this != internal_default_instance() && height_ != NULL;
}
void PointCloud2::clear_height() {
  if (GetArenaNoVirtual() == NULL && height_ != NULL) delete height_;
  height_ = NULL;
}
const ::choreo::UInt32& PointCloud2::height() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.height)
  return height_ != NULL ? *height_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* PointCloud2::mutable_height() {
  
  if (height_ == NULL) {
    height_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.height)
  return height_;
}
::choreo::UInt32* PointCloud2::release_height() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.height)
  
  ::choreo::UInt32* temp = height_;
  height_ = NULL;
  return temp;
}
void PointCloud2::set_allocated_height(::choreo::UInt32* height) {
  delete height_;
  height_ = height;
  if (height) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.height)
}

// .choreo.UInt32 width = 3;
bool PointCloud2::has_width() const {
  return this != internal_default_instance() && width_ != NULL;
}
void PointCloud2::clear_width() {
  if (GetArenaNoVirtual() == NULL && width_ != NULL) delete width_;
  width_ = NULL;
}
const ::choreo::UInt32& PointCloud2::width() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.width)
  return width_ != NULL ? *width_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* PointCloud2::mutable_width() {
  
  if (width_ == NULL) {
    width_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.width)
  return width_;
}
::choreo::UInt32* PointCloud2::release_width() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.width)
  
  ::choreo::UInt32* temp = width_;
  width_ = NULL;
  return temp;
}
void PointCloud2::set_allocated_width(::choreo::UInt32* width) {
  delete width_;
  width_ = width;
  if (width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.width)
}

// repeated .choreo.PointField fields = 4;
int PointCloud2::fields_size() const {
  return fields_.size();
}
void PointCloud2::clear_fields() {
  fields_.Clear();
}
const ::choreo::PointField& PointCloud2::fields(int index) const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.fields)
  return fields_.Get(index);
}
::choreo::PointField* PointCloud2::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.fields)
  return fields_.Mutable(index);
}
::choreo::PointField* PointCloud2::add_fields() {
  // @@protoc_insertion_point(field_add:choreo.PointCloud2.fields)
  return fields_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::PointField >*
PointCloud2::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:choreo.PointCloud2.fields)
  return &fields_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::PointField >&
PointCloud2::fields() const {
  // @@protoc_insertion_point(field_list:choreo.PointCloud2.fields)
  return fields_;
}

// .choreo.Bool is_bigendian = 5;
bool PointCloud2::has_is_bigendian() const {
  return this != internal_default_instance() && is_bigendian_ != NULL;
}
void PointCloud2::clear_is_bigendian() {
  if (GetArenaNoVirtual() == NULL && is_bigendian_ != NULL) delete is_bigendian_;
  is_bigendian_ = NULL;
}
const ::choreo::Bool& PointCloud2::is_bigendian() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.is_bigendian)
  return is_bigendian_ != NULL ? *is_bigendian_
                         : *::choreo::Bool::internal_default_instance();
}
::choreo::Bool* PointCloud2::mutable_is_bigendian() {
  
  if (is_bigendian_ == NULL) {
    is_bigendian_ = new ::choreo::Bool;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.is_bigendian)
  return is_bigendian_;
}
::choreo::Bool* PointCloud2::release_is_bigendian() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.is_bigendian)
  
  ::choreo::Bool* temp = is_bigendian_;
  is_bigendian_ = NULL;
  return temp;
}
void PointCloud2::set_allocated_is_bigendian(::choreo::Bool* is_bigendian) {
  delete is_bigendian_;
  is_bigendian_ = is_bigendian;
  if (is_bigendian) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.is_bigendian)
}

// .choreo.UInt32 point_step = 6;
bool PointCloud2::has_point_step() const {
  return this != internal_default_instance() && point_step_ != NULL;
}
void PointCloud2::clear_point_step() {
  if (GetArenaNoVirtual() == NULL && point_step_ != NULL) delete point_step_;
  point_step_ = NULL;
}
const ::choreo::UInt32& PointCloud2::point_step() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.point_step)
  return point_step_ != NULL ? *point_step_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* PointCloud2::mutable_point_step() {
  
  if (point_step_ == NULL) {
    point_step_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.point_step)
  return point_step_;
}
::choreo::UInt32* PointCloud2::release_point_step() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.point_step)
  
  ::choreo::UInt32* temp = point_step_;
  point_step_ = NULL;
  return temp;
}
void PointCloud2::set_allocated_point_step(::choreo::UInt32* point_step) {
  delete point_step_;
  point_step_ = point_step;
  if (point_step) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.point_step)
}

// .choreo.UInt32 row_step = 7;
bool PointCloud2::has_row_step() const {
  return this != internal_default_instance() && row_step_ != NULL;
}
void PointCloud2::clear_row_step() {
  if (GetArenaNoVirtual() == NULL && row_step_ != NULL) delete row_step_;
  row_step_ = NULL;
}
const ::choreo::UInt32& PointCloud2::row_step() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.row_step)
  return row_step_ != NULL ? *row_step_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* PointCloud2::mutable_row_step() {
  
  if (row_step_ == NULL) {
    row_step_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.row_step)
  return row_step_;
}
::choreo::UInt32* PointCloud2::release_row_step() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.row_step)
  
  ::choreo::UInt32* temp = row_step_;
  row_step_ = NULL;
  return temp;
}
void PointCloud2::set_allocated_row_step(::choreo::UInt32* row_step) {
  delete row_step_;
  row_step_ = row_step;
  if (row_step) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.row_step)
}

// .choreo.Bytes data = 8;
bool PointCloud2::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
void PointCloud2::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
const ::choreo::Bytes& PointCloud2::data() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.data)
  return data_ != NULL ? *data_
                         : *::choreo::Bytes::internal_default_instance();
}
::choreo::Bytes* PointCloud2::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::choreo::Bytes;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.data)
  return data_;
}
::choreo::Bytes* PointCloud2::release_data() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.data)
  
  ::choreo::Bytes* temp = data_;
  data_ = NULL;
  return temp;
}
void PointCloud2::set_allocated_data(::choreo::Bytes* data) {
  delete data_;
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.data)
}

// .choreo.Bool is_dense = 9;
bool PointCloud2::has_is_dense() const {
  return this != internal_default_instance() && is_dense_ != NULL;
}
void PointCloud2::clear_is_dense() {
  if (GetArenaNoVirtual() == NULL && is_dense_ != NULL) delete is_dense_;
  is_dense_ = NULL;
}
const ::choreo::Bool& PointCloud2::is_dense() const {
  // @@protoc_insertion_point(field_get:choreo.PointCloud2.is_dense)
  return is_dense_ != NULL ? *is_dense_
                         : *::choreo::Bool::internal_default_instance();
}
::choreo::Bool* PointCloud2::mutable_is_dense() {
  
  if (is_dense_ == NULL) {
    is_dense_ = new ::choreo::Bool;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PointCloud2.is_dense)
  return is_dense_;
}
::choreo::Bool* PointCloud2::release_is_dense() {
  // @@protoc_insertion_point(field_release:choreo.PointCloud2.is_dense)
  
  ::choreo::Bool* temp = is_dense_;
  is_dense_ = NULL;
  return temp;
}
void PointCloud2::set_allocated_is_dense(::choreo::Bool* is_dense) {
  delete is_dense_;
  is_dense_ = is_dense;
  if (is_dense) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PointCloud2.is_dense)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Range::kHeaderFieldNumber;
const int Range::kRadiationTypeFieldNumber;
const int Range::kFieldOfViewFieldNumber;
const int Range::kMinRangeFieldNumber;
const int Range::kMaxRangeFieldNumber;
const int Range::kRangeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Range::Range()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_sensor_2fdepth_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.Range)
}
Range::Range(const Range& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_field_of_view()) {
    field_of_view_ = new ::choreo::Float32(*from.field_of_view_);
  } else {
    field_of_view_ = NULL;
  }
  if (from.has_min_range()) {
    min_range_ = new ::choreo::Float32(*from.min_range_);
  } else {
    min_range_ = NULL;
  }
  if (from.has_max_range()) {
    max_range_ = new ::choreo::Float32(*from.max_range_);
  } else {
    max_range_ = NULL;
  }
  if (from.has_range()) {
    range_ = new ::choreo::Float32(*from.range_);
  } else {
    range_ = NULL;
  }
  radiation_type_ = from.radiation_type_;
  // @@protoc_insertion_point(copy_constructor:choreo.Range)
}

void Range::SharedCtor() {
  ::memset(&header_, 0, reinterpret_cast<char*>(&radiation_type_) -
    reinterpret_cast<char*>(&header_) + sizeof(radiation_type_));
  _cached_size_ = 0;
}

Range::~Range() {
  // @@protoc_insertion_point(destructor:choreo.Range)
  SharedDtor();
}

void Range::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete field_of_view_;
  }
  if (this != internal_default_instance()) {
    delete min_range_;
  }
  if (this != internal_default_instance()) {
    delete max_range_;
  }
  if (this != internal_default_instance()) {
    delete range_;
  }
}

void Range::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Range::descriptor() {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Range& Range::default_instance() {
  protobuf_sensor_2fdepth_2eproto::InitDefaults();
  return *internal_default_instance();
}

Range* Range::New(::google::protobuf::Arena* arena) const {
  Range* n = new Range;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Range::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.Range)
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && field_of_view_ != NULL) {
    delete field_of_view_;
  }
  field_of_view_ = NULL;
  if (GetArenaNoVirtual() == NULL && min_range_ != NULL) {
    delete min_range_;
  }
  min_range_ = NULL;
  if (GetArenaNoVirtual() == NULL && max_range_ != NULL) {
    delete max_range_;
  }
  max_range_ = NULL;
  if (GetArenaNoVirtual() == NULL && range_ != NULL) {
    delete range_;
  }
  range_ = NULL;
  radiation_type_ = 0;
}

bool Range::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.Range)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Range.RadiationType radiation_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_radiation_type(static_cast< ::choreo::Range_RadiationType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 field_of_view = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_field_of_view()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 min_range = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_min_range()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 max_range = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max_range()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 range = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.Range)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.Range)
  return false;
#undef DO_
}

void Range::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.Range)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .choreo.Range.RadiationType radiation_type = 2;
  if (this->radiation_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->radiation_type(), output);
  }

  // .choreo.Float32 field_of_view = 3;
  if (this->has_field_of_view()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->field_of_view_, output);
  }

  // .choreo.Float32 min_range = 4;
  if (this->has_min_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->min_range_, output);
  }

  // .choreo.Float32 max_range = 5;
  if (this->has_max_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->max_range_, output);
  }

  // .choreo.Float32 range = 6;
  if (this->has_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->range_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.Range)
}

::google::protobuf::uint8* Range::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.Range)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // .choreo.Range.RadiationType radiation_type = 2;
  if (this->radiation_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->radiation_type(), target);
  }

  // .choreo.Float32 field_of_view = 3;
  if (this->has_field_of_view()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->field_of_view_, deterministic, target);
  }

  // .choreo.Float32 min_range = 4;
  if (this->has_min_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->min_range_, deterministic, target);
  }

  // .choreo.Float32 max_range = 5;
  if (this->has_max_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->max_range_, deterministic, target);
  }

  // .choreo.Float32 range = 6;
  if (this->has_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->range_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.Range)
  return target;
}

size_t Range::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.Range)
  size_t total_size = 0;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // .choreo.Float32 field_of_view = 3;
  if (this->has_field_of_view()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->field_of_view_);
  }

  // .choreo.Float32 min_range = 4;
  if (this->has_min_range()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->min_range_);
  }

  // .choreo.Float32 max_range = 5;
  if (this->has_max_range()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->max_range_);
  }

  // .choreo.Float32 range = 6;
  if (this->has_range()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->range_);
  }

  // .choreo.Range.RadiationType radiation_type = 2;
  if (this->radiation_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->radiation_type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Range::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.Range)
  GOOGLE_DCHECK_NE(&from, this);
  const Range* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Range>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.Range)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.Range)
    MergeFrom(*source);
  }
}

void Range::MergeFrom(const Range& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.Range)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
  if (from.has_field_of_view()) {
    mutable_field_of_view()->::choreo::Float32::MergeFrom(from.field_of_view());
  }
  if (from.has_min_range()) {
    mutable_min_range()->::choreo::Float32::MergeFrom(from.min_range());
  }
  if (from.has_max_range()) {
    mutable_max_range()->::choreo::Float32::MergeFrom(from.max_range());
  }
  if (from.has_range()) {
    mutable_range()->::choreo::Float32::MergeFrom(from.range());
  }
  if (from.radiation_type() != 0) {
    set_radiation_type(from.radiation_type());
  }
}

void Range::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.Range)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Range::CopyFrom(const Range& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.Range)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Range::IsInitialized() const {
  return true;
}

void Range::Swap(Range* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Range::InternalSwap(Range* other) {
  std::swap(header_, other->header_);
  std::swap(field_of_view_, other->field_of_view_);
  std::swap(min_range_, other->min_range_);
  std::swap(max_range_, other->max_range_);
  std::swap(range_, other->range_);
  std::swap(radiation_type_, other->radiation_type_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Range::GetMetadata() const {
  protobuf_sensor_2fdepth_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensor_2fdepth_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Range

// .choreo.Header header = 1;
bool Range::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void Range::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& Range::header() const {
  // @@protoc_insertion_point(field_get:choreo.Range.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* Range::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Range.header)
  return header_;
}
::choreo::Header* Range::release_header() {
  // @@protoc_insertion_point(field_release:choreo.Range.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void Range::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Range.header)
}

// .choreo.Range.RadiationType radiation_type = 2;
void Range::clear_radiation_type() {
  radiation_type_ = 0;
}
::choreo::Range_RadiationType Range::radiation_type() const {
  // @@protoc_insertion_point(field_get:choreo.Range.radiation_type)
  return static_cast< ::choreo::Range_RadiationType >(radiation_type_);
}
void Range::set_radiation_type(::choreo::Range_RadiationType value) {
  
  radiation_type_ = value;
  // @@protoc_insertion_point(field_set:choreo.Range.radiation_type)
}

// .choreo.Float32 field_of_view = 3;
bool Range::has_field_of_view() const {
  return this != internal_default_instance() && field_of_view_ != NULL;
}
void Range::clear_field_of_view() {
  if (GetArenaNoVirtual() == NULL && field_of_view_ != NULL) delete field_of_view_;
  field_of_view_ = NULL;
}
const ::choreo::Float32& Range::field_of_view() const {
  // @@protoc_insertion_point(field_get:choreo.Range.field_of_view)
  return field_of_view_ != NULL ? *field_of_view_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* Range::mutable_field_of_view() {
  
  if (field_of_view_ == NULL) {
    field_of_view_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Range.field_of_view)
  return field_of_view_;
}
::choreo::Float32* Range::release_field_of_view() {
  // @@protoc_insertion_point(field_release:choreo.Range.field_of_view)
  
  ::choreo::Float32* temp = field_of_view_;
  field_of_view_ = NULL;
  return temp;
}
void Range::set_allocated_field_of_view(::choreo::Float32* field_of_view) {
  delete field_of_view_;
  field_of_view_ = field_of_view;
  if (field_of_view) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Range.field_of_view)
}

// .choreo.Float32 min_range = 4;
bool Range::has_min_range() const {
  return this != internal_default_instance() && min_range_ != NULL;
}
void Range::clear_min_range() {
  if (GetArenaNoVirtual() == NULL && min_range_ != NULL) delete min_range_;
  min_range_ = NULL;
}
const ::choreo::Float32& Range::min_range() const {
  // @@protoc_insertion_point(field_get:choreo.Range.min_range)
  return min_range_ != NULL ? *min_range_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* Range::mutable_min_range() {
  
  if (min_range_ == NULL) {
    min_range_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Range.min_range)
  return min_range_;
}
::choreo::Float32* Range::release_min_range() {
  // @@protoc_insertion_point(field_release:choreo.Range.min_range)
  
  ::choreo::Float32* temp = min_range_;
  min_range_ = NULL;
  return temp;
}
void Range::set_allocated_min_range(::choreo::Float32* min_range) {
  delete min_range_;
  min_range_ = min_range;
  if (min_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Range.min_range)
}

// .choreo.Float32 max_range = 5;
bool Range::has_max_range() const {
  return this != internal_default_instance() && max_range_ != NULL;
}
void Range::clear_max_range() {
  if (GetArenaNoVirtual() == NULL && max_range_ != NULL) delete max_range_;
  max_range_ = NULL;
}
const ::choreo::Float32& Range::max_range() const {
  // @@protoc_insertion_point(field_get:choreo.Range.max_range)
  return max_range_ != NULL ? *max_range_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* Range::mutable_max_range() {
  
  if (max_range_ == NULL) {
    max_range_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Range.max_range)
  return max_range_;
}
::choreo::Float32* Range::release_max_range() {
  // @@protoc_insertion_point(field_release:choreo.Range.max_range)
  
  ::choreo::Float32* temp = max_range_;
  max_range_ = NULL;
  return temp;
}
void Range::set_allocated_max_range(::choreo::Float32* max_range) {
  delete max_range_;
  max_range_ = max_range;
  if (max_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Range.max_range)
}

// .choreo.Float32 range = 6;
bool Range::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
void Range::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
const ::choreo::Float32& Range::range() const {
  // @@protoc_insertion_point(field_get:choreo.Range.range)
  return range_ != NULL ? *range_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* Range::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Range.range)
  return range_;
}
::choreo::Float32* Range::release_range() {
  // @@protoc_insertion_point(field_release:choreo.Range.range)
  
  ::choreo::Float32* temp = range_;
  range_ = NULL;
  return temp;
}
void Range::set_allocated_range(::choreo::Float32* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Range.range)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace choreo

// @@protoc_insertion_point(global_scope)
