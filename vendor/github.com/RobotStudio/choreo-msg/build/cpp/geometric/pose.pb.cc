// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: geometric/pose.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "geometric/pose.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace choreo {
class PoseStampedDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PoseStamped> {
} _PoseStamped_default_instance_;
class PoseWithCovarianceStampedDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PoseWithCovarianceStamped> {
} _PoseWithCovarianceStamped_default_instance_;
class Pose2DStampedDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Pose2DStamped> {
} _Pose2DStamped_default_instance_;
class PoseDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Pose> {
} _Pose_default_instance_;
class PoseArrayDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PoseArray> {
} _PoseArray_default_instance_;
class Pose2DDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Pose2D> {
} _Pose2D_default_instance_;
class PoseWithCovarianceDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PoseWithCovariance> {
} _PoseWithCovariance_default_instance_;

namespace protobuf_geometric_2fpose_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[7];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoseStamped, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoseStamped, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoseStamped, pose_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoseWithCovarianceStamped, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoseWithCovarianceStamped, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoseWithCovarianceStamped, pose_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose2DStamped, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose2DStamped, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose2DStamped, pose_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, orientation_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoseArray, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoseArray, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoseArray, poses_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose2D, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose2D, x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose2D, y_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose2D, theta_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoseWithCovariance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoseWithCovariance, pose_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoseWithCovariance, covariance_),
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, -1, sizeof(PoseStamped)},
  { 7, -1, sizeof(PoseWithCovarianceStamped)},
  { 14, -1, sizeof(Pose2DStamped)},
  { 21, -1, sizeof(Pose)},
  { 28, -1, sizeof(PoseArray)},
  { 35, -1, sizeof(Pose2D)},
  { 43, -1, sizeof(PoseWithCovariance)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_PoseStamped_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PoseWithCovarianceStamped_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Pose2DStamped_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Pose_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PoseArray_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Pose2D_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PoseWithCovariance_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "geometric/pose.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, NULL, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 7);
}

}  // namespace

void TableStruct::Shutdown() {
  _PoseStamped_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _PoseWithCovarianceStamped_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _Pose2DStamped_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _Pose_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _PoseArray_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _Pose2D_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
  _PoseWithCovariance_default_instance_.Shutdown();
  delete file_level_metadata[6].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::choreo::protobuf_primitive_2fheader_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2ffloat_2eproto::InitDefaults();
  ::choreo::protobuf_geometric_2fpoint_2eproto::InitDefaults();
  ::choreo::protobuf_geometric_2fquaternion_2eproto::InitDefaults();
  _PoseStamped_default_instance_.DefaultConstruct();
  _PoseWithCovarianceStamped_default_instance_.DefaultConstruct();
  _Pose2DStamped_default_instance_.DefaultConstruct();
  _Pose_default_instance_.DefaultConstruct();
  _PoseArray_default_instance_.DefaultConstruct();
  _Pose2D_default_instance_.DefaultConstruct();
  _PoseWithCovariance_default_instance_.DefaultConstruct();
  _PoseStamped_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _PoseStamped_default_instance_.get_mutable()->pose_ = const_cast< ::choreo::Pose*>(
      ::choreo::Pose::internal_default_instance());
  _PoseWithCovarianceStamped_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _PoseWithCovarianceStamped_default_instance_.get_mutable()->pose_ = const_cast< ::choreo::PoseWithCovariance*>(
      ::choreo::PoseWithCovariance::internal_default_instance());
  _Pose2DStamped_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _Pose2DStamped_default_instance_.get_mutable()->pose_ = const_cast< ::choreo::Pose2D*>(
      ::choreo::Pose2D::internal_default_instance());
  _Pose_default_instance_.get_mutable()->position_ = const_cast< ::choreo::Point*>(
      ::choreo::Point::internal_default_instance());
  _Pose_default_instance_.get_mutable()->orientation_ = const_cast< ::choreo::Quaternion*>(
      ::choreo::Quaternion::internal_default_instance());
  _PoseArray_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _Pose2D_default_instance_.get_mutable()->x_ = const_cast< ::choreo::Float64*>(
      ::choreo::Float64::internal_default_instance());
  _Pose2D_default_instance_.get_mutable()->y_ = const_cast< ::choreo::Float64*>(
      ::choreo::Float64::internal_default_instance());
  _Pose2D_default_instance_.get_mutable()->theta_ = const_cast< ::choreo::Float64*>(
      ::choreo::Float64::internal_default_instance());
  _PoseWithCovariance_default_instance_.get_mutable()->pose_ = const_cast< ::choreo::Pose*>(
      ::choreo::Pose::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\024geometric/pose.proto\022\006choreo\032\026primitiv"
      "e/header.proto\032\025primitive/float.proto\032\025g"
      "eometric/point.proto\032\032geometric/quaterni"
      "on.proto\"I\n\013PoseStamped\022\036\n\006header\030\001 \001(\0132"
      "\016.choreo.Header\022\032\n\004pose\030\002 \001(\0132\014.choreo.P"
      "ose\"e\n\031PoseWithCovarianceStamped\022\036\n\006head"
      "er\030\001 \001(\0132\016.choreo.Header\022(\n\004pose\030\002 \001(\0132\032"
      ".choreo.PoseWithCovariance\"M\n\rPose2DStam"
      "ped\022\036\n\006header\030\001 \001(\0132\016.choreo.Header\022\034\n\004p"
      "ose\030\002 \001(\0132\016.choreo.Pose2D\"P\n\004Pose\022\037\n\010pos"
      "ition\030\001 \001(\0132\r.choreo.Point\022\'\n\013orientatio"
      "n\030\002 \001(\0132\022.choreo.Quaternion\"H\n\tPoseArray"
      "\022\036\n\006header\030\001 \001(\0132\016.choreo.Header\022\033\n\005pose"
      "s\030\002 \003(\0132\014.choreo.Pose\"`\n\006Pose2D\022\032\n\001x\030\001 \001"
      "(\0132\017.choreo.Float64\022\032\n\001y\030\002 \001(\0132\017.choreo."
      "Float64\022\036\n\005theta\030\003 \001(\0132\017.choreo.Float64\""
      "U\n\022PoseWithCovariance\022\032\n\004pose\030\001 \001(\0132\014.ch"
      "oreo.Pose\022#\n\ncovariance\030\002 \003(\0132\017.choreo.F"
      "loat64B+Z)github.com/RobotStudio/choreo-"
      "msg/msg;msgb\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 779);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "geometric/pose.proto", &protobuf_RegisterTypes);
  ::choreo::protobuf_primitive_2fheader_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2ffloat_2eproto::AddDescriptors();
  ::choreo::protobuf_geometric_2fpoint_2eproto::AddDescriptors();
  ::choreo::protobuf_geometric_2fquaternion_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_geometric_2fpose_2eproto


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PoseStamped::kHeaderFieldNumber;
const int PoseStamped::kPoseFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PoseStamped::PoseStamped()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_geometric_2fpose_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.PoseStamped)
}
PoseStamped::PoseStamped(const PoseStamped& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_pose()) {
    pose_ = new ::choreo::Pose(*from.pose_);
  } else {
    pose_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.PoseStamped)
}

void PoseStamped::SharedCtor() {
  ::memset(&header_, 0, reinterpret_cast<char*>(&pose_) -
    reinterpret_cast<char*>(&header_) + sizeof(pose_));
  _cached_size_ = 0;
}

PoseStamped::~PoseStamped() {
  // @@protoc_insertion_point(destructor:choreo.PoseStamped)
  SharedDtor();
}

void PoseStamped::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete pose_;
  }
}

void PoseStamped::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PoseStamped::descriptor() {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PoseStamped& PoseStamped::default_instance() {
  protobuf_geometric_2fpose_2eproto::InitDefaults();
  return *internal_default_instance();
}

PoseStamped* PoseStamped::New(::google::protobuf::Arena* arena) const {
  PoseStamped* n = new PoseStamped;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PoseStamped::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.PoseStamped)
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) {
    delete pose_;
  }
  pose_ = NULL;
}

bool PoseStamped::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.PoseStamped)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Pose pose = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.PoseStamped)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.PoseStamped)
  return false;
#undef DO_
}

void PoseStamped::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.PoseStamped)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .choreo.Pose pose = 2;
  if (this->has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pose_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.PoseStamped)
}

::google::protobuf::uint8* PoseStamped::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.PoseStamped)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // .choreo.Pose pose = 2;
  if (this->has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->pose_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.PoseStamped)
  return target;
}

size_t PoseStamped::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.PoseStamped)
  size_t total_size = 0;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // .choreo.Pose pose = 2;
  if (this->has_pose()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pose_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PoseStamped::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.PoseStamped)
  GOOGLE_DCHECK_NE(&from, this);
  const PoseStamped* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PoseStamped>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.PoseStamped)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.PoseStamped)
    MergeFrom(*source);
  }
}

void PoseStamped::MergeFrom(const PoseStamped& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.PoseStamped)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
  if (from.has_pose()) {
    mutable_pose()->::choreo::Pose::MergeFrom(from.pose());
  }
}

void PoseStamped::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.PoseStamped)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PoseStamped::CopyFrom(const PoseStamped& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.PoseStamped)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PoseStamped::IsInitialized() const {
  return true;
}

void PoseStamped::Swap(PoseStamped* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PoseStamped::InternalSwap(PoseStamped* other) {
  std::swap(header_, other->header_);
  std::swap(pose_, other->pose_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PoseStamped::GetMetadata() const {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PoseStamped

// .choreo.Header header = 1;
bool PoseStamped::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void PoseStamped::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& PoseStamped::header() const {
  // @@protoc_insertion_point(field_get:choreo.PoseStamped.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* PoseStamped::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PoseStamped.header)
  return header_;
}
::choreo::Header* PoseStamped::release_header() {
  // @@protoc_insertion_point(field_release:choreo.PoseStamped.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void PoseStamped::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PoseStamped.header)
}

// .choreo.Pose pose = 2;
bool PoseStamped::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
void PoseStamped::clear_pose() {
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) delete pose_;
  pose_ = NULL;
}
const ::choreo::Pose& PoseStamped::pose() const {
  // @@protoc_insertion_point(field_get:choreo.PoseStamped.pose)
  return pose_ != NULL ? *pose_
                         : *::choreo::Pose::internal_default_instance();
}
::choreo::Pose* PoseStamped::mutable_pose() {
  
  if (pose_ == NULL) {
    pose_ = new ::choreo::Pose;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PoseStamped.pose)
  return pose_;
}
::choreo::Pose* PoseStamped::release_pose() {
  // @@protoc_insertion_point(field_release:choreo.PoseStamped.pose)
  
  ::choreo::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
void PoseStamped::set_allocated_pose(::choreo::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PoseStamped.pose)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PoseWithCovarianceStamped::kHeaderFieldNumber;
const int PoseWithCovarianceStamped::kPoseFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PoseWithCovarianceStamped::PoseWithCovarianceStamped()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_geometric_2fpose_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.PoseWithCovarianceStamped)
}
PoseWithCovarianceStamped::PoseWithCovarianceStamped(const PoseWithCovarianceStamped& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_pose()) {
    pose_ = new ::choreo::PoseWithCovariance(*from.pose_);
  } else {
    pose_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.PoseWithCovarianceStamped)
}

void PoseWithCovarianceStamped::SharedCtor() {
  ::memset(&header_, 0, reinterpret_cast<char*>(&pose_) -
    reinterpret_cast<char*>(&header_) + sizeof(pose_));
  _cached_size_ = 0;
}

PoseWithCovarianceStamped::~PoseWithCovarianceStamped() {
  // @@protoc_insertion_point(destructor:choreo.PoseWithCovarianceStamped)
  SharedDtor();
}

void PoseWithCovarianceStamped::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete pose_;
  }
}

void PoseWithCovarianceStamped::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PoseWithCovarianceStamped::descriptor() {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PoseWithCovarianceStamped& PoseWithCovarianceStamped::default_instance() {
  protobuf_geometric_2fpose_2eproto::InitDefaults();
  return *internal_default_instance();
}

PoseWithCovarianceStamped* PoseWithCovarianceStamped::New(::google::protobuf::Arena* arena) const {
  PoseWithCovarianceStamped* n = new PoseWithCovarianceStamped;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PoseWithCovarianceStamped::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.PoseWithCovarianceStamped)
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) {
    delete pose_;
  }
  pose_ = NULL;
}

bool PoseWithCovarianceStamped::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.PoseWithCovarianceStamped)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.PoseWithCovariance pose = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.PoseWithCovarianceStamped)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.PoseWithCovarianceStamped)
  return false;
#undef DO_
}

void PoseWithCovarianceStamped::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.PoseWithCovarianceStamped)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .choreo.PoseWithCovariance pose = 2;
  if (this->has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pose_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.PoseWithCovarianceStamped)
}

::google::protobuf::uint8* PoseWithCovarianceStamped::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.PoseWithCovarianceStamped)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // .choreo.PoseWithCovariance pose = 2;
  if (this->has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->pose_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.PoseWithCovarianceStamped)
  return target;
}

size_t PoseWithCovarianceStamped::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.PoseWithCovarianceStamped)
  size_t total_size = 0;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // .choreo.PoseWithCovariance pose = 2;
  if (this->has_pose()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pose_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PoseWithCovarianceStamped::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.PoseWithCovarianceStamped)
  GOOGLE_DCHECK_NE(&from, this);
  const PoseWithCovarianceStamped* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PoseWithCovarianceStamped>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.PoseWithCovarianceStamped)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.PoseWithCovarianceStamped)
    MergeFrom(*source);
  }
}

void PoseWithCovarianceStamped::MergeFrom(const PoseWithCovarianceStamped& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.PoseWithCovarianceStamped)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
  if (from.has_pose()) {
    mutable_pose()->::choreo::PoseWithCovariance::MergeFrom(from.pose());
  }
}

void PoseWithCovarianceStamped::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.PoseWithCovarianceStamped)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PoseWithCovarianceStamped::CopyFrom(const PoseWithCovarianceStamped& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.PoseWithCovarianceStamped)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PoseWithCovarianceStamped::IsInitialized() const {
  return true;
}

void PoseWithCovarianceStamped::Swap(PoseWithCovarianceStamped* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PoseWithCovarianceStamped::InternalSwap(PoseWithCovarianceStamped* other) {
  std::swap(header_, other->header_);
  std::swap(pose_, other->pose_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PoseWithCovarianceStamped::GetMetadata() const {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PoseWithCovarianceStamped

// .choreo.Header header = 1;
bool PoseWithCovarianceStamped::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void PoseWithCovarianceStamped::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& PoseWithCovarianceStamped::header() const {
  // @@protoc_insertion_point(field_get:choreo.PoseWithCovarianceStamped.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* PoseWithCovarianceStamped::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PoseWithCovarianceStamped.header)
  return header_;
}
::choreo::Header* PoseWithCovarianceStamped::release_header() {
  // @@protoc_insertion_point(field_release:choreo.PoseWithCovarianceStamped.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void PoseWithCovarianceStamped::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PoseWithCovarianceStamped.header)
}

// .choreo.PoseWithCovariance pose = 2;
bool PoseWithCovarianceStamped::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
void PoseWithCovarianceStamped::clear_pose() {
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) delete pose_;
  pose_ = NULL;
}
const ::choreo::PoseWithCovariance& PoseWithCovarianceStamped::pose() const {
  // @@protoc_insertion_point(field_get:choreo.PoseWithCovarianceStamped.pose)
  return pose_ != NULL ? *pose_
                         : *::choreo::PoseWithCovariance::internal_default_instance();
}
::choreo::PoseWithCovariance* PoseWithCovarianceStamped::mutable_pose() {
  
  if (pose_ == NULL) {
    pose_ = new ::choreo::PoseWithCovariance;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PoseWithCovarianceStamped.pose)
  return pose_;
}
::choreo::PoseWithCovariance* PoseWithCovarianceStamped::release_pose() {
  // @@protoc_insertion_point(field_release:choreo.PoseWithCovarianceStamped.pose)
  
  ::choreo::PoseWithCovariance* temp = pose_;
  pose_ = NULL;
  return temp;
}
void PoseWithCovarianceStamped::set_allocated_pose(::choreo::PoseWithCovariance* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PoseWithCovarianceStamped.pose)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pose2DStamped::kHeaderFieldNumber;
const int Pose2DStamped::kPoseFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pose2DStamped::Pose2DStamped()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_geometric_2fpose_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.Pose2DStamped)
}
Pose2DStamped::Pose2DStamped(const Pose2DStamped& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_pose()) {
    pose_ = new ::choreo::Pose2D(*from.pose_);
  } else {
    pose_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.Pose2DStamped)
}

void Pose2DStamped::SharedCtor() {
  ::memset(&header_, 0, reinterpret_cast<char*>(&pose_) -
    reinterpret_cast<char*>(&header_) + sizeof(pose_));
  _cached_size_ = 0;
}

Pose2DStamped::~Pose2DStamped() {
  // @@protoc_insertion_point(destructor:choreo.Pose2DStamped)
  SharedDtor();
}

void Pose2DStamped::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete pose_;
  }
}

void Pose2DStamped::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Pose2DStamped::descriptor() {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Pose2DStamped& Pose2DStamped::default_instance() {
  protobuf_geometric_2fpose_2eproto::InitDefaults();
  return *internal_default_instance();
}

Pose2DStamped* Pose2DStamped::New(::google::protobuf::Arena* arena) const {
  Pose2DStamped* n = new Pose2DStamped;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Pose2DStamped::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.Pose2DStamped)
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) {
    delete pose_;
  }
  pose_ = NULL;
}

bool Pose2DStamped::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.Pose2DStamped)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Pose2D pose = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.Pose2DStamped)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.Pose2DStamped)
  return false;
#undef DO_
}

void Pose2DStamped::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.Pose2DStamped)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .choreo.Pose2D pose = 2;
  if (this->has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pose_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.Pose2DStamped)
}

::google::protobuf::uint8* Pose2DStamped::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.Pose2DStamped)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // .choreo.Pose2D pose = 2;
  if (this->has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->pose_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.Pose2DStamped)
  return target;
}

size_t Pose2DStamped::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.Pose2DStamped)
  size_t total_size = 0;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // .choreo.Pose2D pose = 2;
  if (this->has_pose()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pose_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pose2DStamped::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.Pose2DStamped)
  GOOGLE_DCHECK_NE(&from, this);
  const Pose2DStamped* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Pose2DStamped>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.Pose2DStamped)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.Pose2DStamped)
    MergeFrom(*source);
  }
}

void Pose2DStamped::MergeFrom(const Pose2DStamped& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.Pose2DStamped)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
  if (from.has_pose()) {
    mutable_pose()->::choreo::Pose2D::MergeFrom(from.pose());
  }
}

void Pose2DStamped::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.Pose2DStamped)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pose2DStamped::CopyFrom(const Pose2DStamped& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.Pose2DStamped)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pose2DStamped::IsInitialized() const {
  return true;
}

void Pose2DStamped::Swap(Pose2DStamped* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pose2DStamped::InternalSwap(Pose2DStamped* other) {
  std::swap(header_, other->header_);
  std::swap(pose_, other->pose_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Pose2DStamped::GetMetadata() const {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Pose2DStamped

// .choreo.Header header = 1;
bool Pose2DStamped::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void Pose2DStamped::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& Pose2DStamped::header() const {
  // @@protoc_insertion_point(field_get:choreo.Pose2DStamped.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* Pose2DStamped::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Pose2DStamped.header)
  return header_;
}
::choreo::Header* Pose2DStamped::release_header() {
  // @@protoc_insertion_point(field_release:choreo.Pose2DStamped.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void Pose2DStamped::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Pose2DStamped.header)
}

// .choreo.Pose2D pose = 2;
bool Pose2DStamped::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
void Pose2DStamped::clear_pose() {
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) delete pose_;
  pose_ = NULL;
}
const ::choreo::Pose2D& Pose2DStamped::pose() const {
  // @@protoc_insertion_point(field_get:choreo.Pose2DStamped.pose)
  return pose_ != NULL ? *pose_
                         : *::choreo::Pose2D::internal_default_instance();
}
::choreo::Pose2D* Pose2DStamped::mutable_pose() {
  
  if (pose_ == NULL) {
    pose_ = new ::choreo::Pose2D;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Pose2DStamped.pose)
  return pose_;
}
::choreo::Pose2D* Pose2DStamped::release_pose() {
  // @@protoc_insertion_point(field_release:choreo.Pose2DStamped.pose)
  
  ::choreo::Pose2D* temp = pose_;
  pose_ = NULL;
  return temp;
}
void Pose2DStamped::set_allocated_pose(::choreo::Pose2D* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Pose2DStamped.pose)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pose::kPositionFieldNumber;
const int Pose::kOrientationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pose::Pose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_geometric_2fpose_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.Pose)
}
Pose::Pose(const Pose& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::choreo::Point(*from.position_);
  } else {
    position_ = NULL;
  }
  if (from.has_orientation()) {
    orientation_ = new ::choreo::Quaternion(*from.orientation_);
  } else {
    orientation_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.Pose)
}

void Pose::SharedCtor() {
  ::memset(&position_, 0, reinterpret_cast<char*>(&orientation_) -
    reinterpret_cast<char*>(&position_) + sizeof(orientation_));
  _cached_size_ = 0;
}

Pose::~Pose() {
  // @@protoc_insertion_point(destructor:choreo.Pose)
  SharedDtor();
}

void Pose::SharedDtor() {
  if (this != internal_default_instance()) {
    delete position_;
  }
  if (this != internal_default_instance()) {
    delete orientation_;
  }
}

void Pose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Pose::descriptor() {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Pose& Pose::default_instance() {
  protobuf_geometric_2fpose_2eproto::InitDefaults();
  return *internal_default_instance();
}

Pose* Pose::New(::google::protobuf::Arena* arena) const {
  Pose* n = new Pose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Pose::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.Pose)
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
  if (GetArenaNoVirtual() == NULL && orientation_ != NULL) {
    delete orientation_;
  }
  orientation_ = NULL;
}

bool Pose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.Pose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Point position = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Quaternion orientation = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_orientation()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.Pose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.Pose)
  return false;
#undef DO_
}

void Pose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.Pose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Point position = 1;
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->position_, output);
  }

  // .choreo.Quaternion orientation = 2;
  if (this->has_orientation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->orientation_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.Pose)
}

::google::protobuf::uint8* Pose::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.Pose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Point position = 1;
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->position_, deterministic, target);
  }

  // .choreo.Quaternion orientation = 2;
  if (this->has_orientation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->orientation_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.Pose)
  return target;
}

size_t Pose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.Pose)
  size_t total_size = 0;

  // .choreo.Point position = 1;
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);
  }

  // .choreo.Quaternion orientation = 2;
  if (this->has_orientation()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->orientation_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pose::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.Pose)
  GOOGLE_DCHECK_NE(&from, this);
  const Pose* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Pose>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.Pose)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.Pose)
    MergeFrom(*source);
  }
}

void Pose::MergeFrom(const Pose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.Pose)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_position()) {
    mutable_position()->::choreo::Point::MergeFrom(from.position());
  }
  if (from.has_orientation()) {
    mutable_orientation()->::choreo::Quaternion::MergeFrom(from.orientation());
  }
}

void Pose::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pose::CopyFrom(const Pose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pose::IsInitialized() const {
  return true;
}

void Pose::Swap(Pose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pose::InternalSwap(Pose* other) {
  std::swap(position_, other->position_);
  std::swap(orientation_, other->orientation_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Pose::GetMetadata() const {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Pose

// .choreo.Point position = 1;
bool Pose::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
void Pose::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) delete position_;
  position_ = NULL;
}
const ::choreo::Point& Pose::position() const {
  // @@protoc_insertion_point(field_get:choreo.Pose.position)
  return position_ != NULL ? *position_
                         : *::choreo::Point::internal_default_instance();
}
::choreo::Point* Pose::mutable_position() {
  
  if (position_ == NULL) {
    position_ = new ::choreo::Point;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Pose.position)
  return position_;
}
::choreo::Point* Pose::release_position() {
  // @@protoc_insertion_point(field_release:choreo.Pose.position)
  
  ::choreo::Point* temp = position_;
  position_ = NULL;
  return temp;
}
void Pose::set_allocated_position(::choreo::Point* position) {
  delete position_;
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Pose.position)
}

// .choreo.Quaternion orientation = 2;
bool Pose::has_orientation() const {
  return this != internal_default_instance() && orientation_ != NULL;
}
void Pose::clear_orientation() {
  if (GetArenaNoVirtual() == NULL && orientation_ != NULL) delete orientation_;
  orientation_ = NULL;
}
const ::choreo::Quaternion& Pose::orientation() const {
  // @@protoc_insertion_point(field_get:choreo.Pose.orientation)
  return orientation_ != NULL ? *orientation_
                         : *::choreo::Quaternion::internal_default_instance();
}
::choreo::Quaternion* Pose::mutable_orientation() {
  
  if (orientation_ == NULL) {
    orientation_ = new ::choreo::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Pose.orientation)
  return orientation_;
}
::choreo::Quaternion* Pose::release_orientation() {
  // @@protoc_insertion_point(field_release:choreo.Pose.orientation)
  
  ::choreo::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
void Pose::set_allocated_orientation(::choreo::Quaternion* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Pose.orientation)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PoseArray::kHeaderFieldNumber;
const int PoseArray::kPosesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PoseArray::PoseArray()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_geometric_2fpose_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.PoseArray)
}
PoseArray::PoseArray(const PoseArray& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      poses_(from.poses_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.PoseArray)
}

void PoseArray::SharedCtor() {
  header_ = NULL;
  _cached_size_ = 0;
}

PoseArray::~PoseArray() {
  // @@protoc_insertion_point(destructor:choreo.PoseArray)
  SharedDtor();
}

void PoseArray::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
}

void PoseArray::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PoseArray::descriptor() {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PoseArray& PoseArray::default_instance() {
  protobuf_geometric_2fpose_2eproto::InitDefaults();
  return *internal_default_instance();
}

PoseArray* PoseArray::New(::google::protobuf::Arena* arena) const {
  PoseArray* n = new PoseArray;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PoseArray::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.PoseArray)
  poses_.Clear();
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}

bool PoseArray::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.PoseArray)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.Pose poses = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_poses()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.PoseArray)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.PoseArray)
  return false;
#undef DO_
}

void PoseArray::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.PoseArray)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .choreo.Pose poses = 2;
  for (unsigned int i = 0, n = this->poses_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->poses(i), output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.PoseArray)
}

::google::protobuf::uint8* PoseArray::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.PoseArray)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // repeated .choreo.Pose poses = 2;
  for (unsigned int i = 0, n = this->poses_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->poses(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.PoseArray)
  return target;
}

size_t PoseArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.PoseArray)
  size_t total_size = 0;

  // repeated .choreo.Pose poses = 2;
  {
    unsigned int count = this->poses_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->poses(i));
    }
  }

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PoseArray::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.PoseArray)
  GOOGLE_DCHECK_NE(&from, this);
  const PoseArray* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PoseArray>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.PoseArray)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.PoseArray)
    MergeFrom(*source);
  }
}

void PoseArray::MergeFrom(const PoseArray& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.PoseArray)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  poses_.MergeFrom(from.poses_);
  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
}

void PoseArray::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.PoseArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PoseArray::CopyFrom(const PoseArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.PoseArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PoseArray::IsInitialized() const {
  return true;
}

void PoseArray::Swap(PoseArray* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PoseArray::InternalSwap(PoseArray* other) {
  poses_.InternalSwap(&other->poses_);
  std::swap(header_, other->header_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PoseArray::GetMetadata() const {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PoseArray

// .choreo.Header header = 1;
bool PoseArray::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void PoseArray::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& PoseArray::header() const {
  // @@protoc_insertion_point(field_get:choreo.PoseArray.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* PoseArray::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PoseArray.header)
  return header_;
}
::choreo::Header* PoseArray::release_header() {
  // @@protoc_insertion_point(field_release:choreo.PoseArray.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void PoseArray::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PoseArray.header)
}

// repeated .choreo.Pose poses = 2;
int PoseArray::poses_size() const {
  return poses_.size();
}
void PoseArray::clear_poses() {
  poses_.Clear();
}
const ::choreo::Pose& PoseArray::poses(int index) const {
  // @@protoc_insertion_point(field_get:choreo.PoseArray.poses)
  return poses_.Get(index);
}
::choreo::Pose* PoseArray::mutable_poses(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.PoseArray.poses)
  return poses_.Mutable(index);
}
::choreo::Pose* PoseArray::add_poses() {
  // @@protoc_insertion_point(field_add:choreo.PoseArray.poses)
  return poses_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::Pose >*
PoseArray::mutable_poses() {
  // @@protoc_insertion_point(field_mutable_list:choreo.PoseArray.poses)
  return &poses_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::Pose >&
PoseArray::poses() const {
  // @@protoc_insertion_point(field_list:choreo.PoseArray.poses)
  return poses_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pose2D::kXFieldNumber;
const int Pose2D::kYFieldNumber;
const int Pose2D::kThetaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pose2D::Pose2D()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_geometric_2fpose_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.Pose2D)
}
Pose2D::Pose2D(const Pose2D& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_x()) {
    x_ = new ::choreo::Float64(*from.x_);
  } else {
    x_ = NULL;
  }
  if (from.has_y()) {
    y_ = new ::choreo::Float64(*from.y_);
  } else {
    y_ = NULL;
  }
  if (from.has_theta()) {
    theta_ = new ::choreo::Float64(*from.theta_);
  } else {
    theta_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.Pose2D)
}

void Pose2D::SharedCtor() {
  ::memset(&x_, 0, reinterpret_cast<char*>(&theta_) -
    reinterpret_cast<char*>(&x_) + sizeof(theta_));
  _cached_size_ = 0;
}

Pose2D::~Pose2D() {
  // @@protoc_insertion_point(destructor:choreo.Pose2D)
  SharedDtor();
}

void Pose2D::SharedDtor() {
  if (this != internal_default_instance()) {
    delete x_;
  }
  if (this != internal_default_instance()) {
    delete y_;
  }
  if (this != internal_default_instance()) {
    delete theta_;
  }
}

void Pose2D::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Pose2D::descriptor() {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Pose2D& Pose2D::default_instance() {
  protobuf_geometric_2fpose_2eproto::InitDefaults();
  return *internal_default_instance();
}

Pose2D* Pose2D::New(::google::protobuf::Arena* arena) const {
  Pose2D* n = new Pose2D;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Pose2D::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.Pose2D)
  if (GetArenaNoVirtual() == NULL && x_ != NULL) {
    delete x_;
  }
  x_ = NULL;
  if (GetArenaNoVirtual() == NULL && y_ != NULL) {
    delete y_;
  }
  y_ = NULL;
  if (GetArenaNoVirtual() == NULL && theta_ != NULL) {
    delete theta_;
  }
  theta_ = NULL;
}

bool Pose2D::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.Pose2D)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Float64 x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_x()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float64 y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_y()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float64 theta = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_theta()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.Pose2D)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.Pose2D)
  return false;
#undef DO_
}

void Pose2D::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.Pose2D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Float64 x = 1;
  if (this->has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->x_, output);
  }

  // .choreo.Float64 y = 2;
  if (this->has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->y_, output);
  }

  // .choreo.Float64 theta = 3;
  if (this->has_theta()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->theta_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.Pose2D)
}

::google::protobuf::uint8* Pose2D::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.Pose2D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Float64 x = 1;
  if (this->has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->x_, deterministic, target);
  }

  // .choreo.Float64 y = 2;
  if (this->has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->y_, deterministic, target);
  }

  // .choreo.Float64 theta = 3;
  if (this->has_theta()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->theta_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.Pose2D)
  return target;
}

size_t Pose2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.Pose2D)
  size_t total_size = 0;

  // .choreo.Float64 x = 1;
  if (this->has_x()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->x_);
  }

  // .choreo.Float64 y = 2;
  if (this->has_y()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->y_);
  }

  // .choreo.Float64 theta = 3;
  if (this->has_theta()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->theta_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pose2D::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.Pose2D)
  GOOGLE_DCHECK_NE(&from, this);
  const Pose2D* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Pose2D>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.Pose2D)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.Pose2D)
    MergeFrom(*source);
  }
}

void Pose2D::MergeFrom(const Pose2D& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.Pose2D)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_x()) {
    mutable_x()->::choreo::Float64::MergeFrom(from.x());
  }
  if (from.has_y()) {
    mutable_y()->::choreo::Float64::MergeFrom(from.y());
  }
  if (from.has_theta()) {
    mutable_theta()->::choreo::Float64::MergeFrom(from.theta());
  }
}

void Pose2D::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.Pose2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pose2D::CopyFrom(const Pose2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.Pose2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pose2D::IsInitialized() const {
  return true;
}

void Pose2D::Swap(Pose2D* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pose2D::InternalSwap(Pose2D* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(theta_, other->theta_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Pose2D::GetMetadata() const {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Pose2D

// .choreo.Float64 x = 1;
bool Pose2D::has_x() const {
  return this != internal_default_instance() && x_ != NULL;
}
void Pose2D::clear_x() {
  if (GetArenaNoVirtual() == NULL && x_ != NULL) delete x_;
  x_ = NULL;
}
const ::choreo::Float64& Pose2D::x() const {
  // @@protoc_insertion_point(field_get:choreo.Pose2D.x)
  return x_ != NULL ? *x_
                         : *::choreo::Float64::internal_default_instance();
}
::choreo::Float64* Pose2D::mutable_x() {
  
  if (x_ == NULL) {
    x_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Pose2D.x)
  return x_;
}
::choreo::Float64* Pose2D::release_x() {
  // @@protoc_insertion_point(field_release:choreo.Pose2D.x)
  
  ::choreo::Float64* temp = x_;
  x_ = NULL;
  return temp;
}
void Pose2D::set_allocated_x(::choreo::Float64* x) {
  delete x_;
  x_ = x;
  if (x) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Pose2D.x)
}

// .choreo.Float64 y = 2;
bool Pose2D::has_y() const {
  return this != internal_default_instance() && y_ != NULL;
}
void Pose2D::clear_y() {
  if (GetArenaNoVirtual() == NULL && y_ != NULL) delete y_;
  y_ = NULL;
}
const ::choreo::Float64& Pose2D::y() const {
  // @@protoc_insertion_point(field_get:choreo.Pose2D.y)
  return y_ != NULL ? *y_
                         : *::choreo::Float64::internal_default_instance();
}
::choreo::Float64* Pose2D::mutable_y() {
  
  if (y_ == NULL) {
    y_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Pose2D.y)
  return y_;
}
::choreo::Float64* Pose2D::release_y() {
  // @@protoc_insertion_point(field_release:choreo.Pose2D.y)
  
  ::choreo::Float64* temp = y_;
  y_ = NULL;
  return temp;
}
void Pose2D::set_allocated_y(::choreo::Float64* y) {
  delete y_;
  y_ = y;
  if (y) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Pose2D.y)
}

// .choreo.Float64 theta = 3;
bool Pose2D::has_theta() const {
  return this != internal_default_instance() && theta_ != NULL;
}
void Pose2D::clear_theta() {
  if (GetArenaNoVirtual() == NULL && theta_ != NULL) delete theta_;
  theta_ = NULL;
}
const ::choreo::Float64& Pose2D::theta() const {
  // @@protoc_insertion_point(field_get:choreo.Pose2D.theta)
  return theta_ != NULL ? *theta_
                         : *::choreo::Float64::internal_default_instance();
}
::choreo::Float64* Pose2D::mutable_theta() {
  
  if (theta_ == NULL) {
    theta_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Pose2D.theta)
  return theta_;
}
::choreo::Float64* Pose2D::release_theta() {
  // @@protoc_insertion_point(field_release:choreo.Pose2D.theta)
  
  ::choreo::Float64* temp = theta_;
  theta_ = NULL;
  return temp;
}
void Pose2D::set_allocated_theta(::choreo::Float64* theta) {
  delete theta_;
  theta_ = theta;
  if (theta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Pose2D.theta)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PoseWithCovariance::kPoseFieldNumber;
const int PoseWithCovariance::kCovarianceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PoseWithCovariance::PoseWithCovariance()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_geometric_2fpose_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.PoseWithCovariance)
}
PoseWithCovariance::PoseWithCovariance(const PoseWithCovariance& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      covariance_(from.covariance_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_pose()) {
    pose_ = new ::choreo::Pose(*from.pose_);
  } else {
    pose_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.PoseWithCovariance)
}

void PoseWithCovariance::SharedCtor() {
  pose_ = NULL;
  _cached_size_ = 0;
}

PoseWithCovariance::~PoseWithCovariance() {
  // @@protoc_insertion_point(destructor:choreo.PoseWithCovariance)
  SharedDtor();
}

void PoseWithCovariance::SharedDtor() {
  if (this != internal_default_instance()) {
    delete pose_;
  }
}

void PoseWithCovariance::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PoseWithCovariance::descriptor() {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PoseWithCovariance& PoseWithCovariance::default_instance() {
  protobuf_geometric_2fpose_2eproto::InitDefaults();
  return *internal_default_instance();
}

PoseWithCovariance* PoseWithCovariance::New(::google::protobuf::Arena* arena) const {
  PoseWithCovariance* n = new PoseWithCovariance;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PoseWithCovariance::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.PoseWithCovariance)
  covariance_.Clear();
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) {
    delete pose_;
  }
  pose_ = NULL;
}

bool PoseWithCovariance::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.PoseWithCovariance)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Pose pose = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.Float64 covariance = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_covariance()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.PoseWithCovariance)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.PoseWithCovariance)
  return false;
#undef DO_
}

void PoseWithCovariance::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.PoseWithCovariance)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Pose pose = 1;
  if (this->has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->pose_, output);
  }

  // repeated .choreo.Float64 covariance = 2;
  for (unsigned int i = 0, n = this->covariance_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->covariance(i), output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.PoseWithCovariance)
}

::google::protobuf::uint8* PoseWithCovariance::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.PoseWithCovariance)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Pose pose = 1;
  if (this->has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->pose_, deterministic, target);
  }

  // repeated .choreo.Float64 covariance = 2;
  for (unsigned int i = 0, n = this->covariance_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->covariance(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.PoseWithCovariance)
  return target;
}

size_t PoseWithCovariance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.PoseWithCovariance)
  size_t total_size = 0;

  // repeated .choreo.Float64 covariance = 2;
  {
    unsigned int count = this->covariance_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->covariance(i));
    }
  }

  // .choreo.Pose pose = 1;
  if (this->has_pose()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pose_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PoseWithCovariance::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.PoseWithCovariance)
  GOOGLE_DCHECK_NE(&from, this);
  const PoseWithCovariance* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PoseWithCovariance>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.PoseWithCovariance)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.PoseWithCovariance)
    MergeFrom(*source);
  }
}

void PoseWithCovariance::MergeFrom(const PoseWithCovariance& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.PoseWithCovariance)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  covariance_.MergeFrom(from.covariance_);
  if (from.has_pose()) {
    mutable_pose()->::choreo::Pose::MergeFrom(from.pose());
  }
}

void PoseWithCovariance::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.PoseWithCovariance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PoseWithCovariance::CopyFrom(const PoseWithCovariance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.PoseWithCovariance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PoseWithCovariance::IsInitialized() const {
  return true;
}

void PoseWithCovariance::Swap(PoseWithCovariance* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PoseWithCovariance::InternalSwap(PoseWithCovariance* other) {
  covariance_.InternalSwap(&other->covariance_);
  std::swap(pose_, other->pose_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PoseWithCovariance::GetMetadata() const {
  protobuf_geometric_2fpose_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_geometric_2fpose_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PoseWithCovariance

// .choreo.Pose pose = 1;
bool PoseWithCovariance::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
void PoseWithCovariance::clear_pose() {
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) delete pose_;
  pose_ = NULL;
}
const ::choreo::Pose& PoseWithCovariance::pose() const {
  // @@protoc_insertion_point(field_get:choreo.PoseWithCovariance.pose)
  return pose_ != NULL ? *pose_
                         : *::choreo::Pose::internal_default_instance();
}
::choreo::Pose* PoseWithCovariance::mutable_pose() {
  
  if (pose_ == NULL) {
    pose_ = new ::choreo::Pose;
  }
  // @@protoc_insertion_point(field_mutable:choreo.PoseWithCovariance.pose)
  return pose_;
}
::choreo::Pose* PoseWithCovariance::release_pose() {
  // @@protoc_insertion_point(field_release:choreo.PoseWithCovariance.pose)
  
  ::choreo::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
void PoseWithCovariance::set_allocated_pose(::choreo::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.PoseWithCovariance.pose)
}

// repeated .choreo.Float64 covariance = 2;
int PoseWithCovariance::covariance_size() const {
  return covariance_.size();
}
void PoseWithCovariance::clear_covariance() {
  covariance_.Clear();
}
const ::choreo::Float64& PoseWithCovariance::covariance(int index) const {
  // @@protoc_insertion_point(field_get:choreo.PoseWithCovariance.covariance)
  return covariance_.Get(index);
}
::choreo::Float64* PoseWithCovariance::mutable_covariance(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.PoseWithCovariance.covariance)
  return covariance_.Mutable(index);
}
::choreo::Float64* PoseWithCovariance::add_covariance() {
  // @@protoc_insertion_point(field_add:choreo.PoseWithCovariance.covariance)
  return covariance_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::Float64 >*
PoseWithCovariance::mutable_covariance() {
  // @@protoc_insertion_point(field_mutable_list:choreo.PoseWithCovariance.covariance)
  return &covariance_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::Float64 >&
PoseWithCovariance::covariance() const {
  // @@protoc_insertion_point(field_list:choreo.PoseWithCovariance.covariance)
  return covariance_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace choreo

// @@protoc_insertion_point(global_scope)
