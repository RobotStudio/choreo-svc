// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: diagnostic.proto

#ifndef PROTOBUF_diagnostic_2eproto__INCLUDED
#define PROTOBUF_diagnostic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "primitive/bool.pb.h"
#include "primitive/header.pb.h"
#include "primitive/string.pb.h"
// @@protoc_insertion_point(includes)
namespace choreo {
class Bool;
class BoolDefaultTypeInternal;
extern BoolDefaultTypeInternal _Bool_default_instance_;
class BoolArray;
class BoolArrayDefaultTypeInternal;
extern BoolArrayDefaultTypeInternal _BoolArray_default_instance_;
class DiagnosticArray;
class DiagnosticArrayDefaultTypeInternal;
extern DiagnosticArrayDefaultTypeInternal _DiagnosticArray_default_instance_;
class DiagnosticStatus;
class DiagnosticStatusDefaultTypeInternal;
extern DiagnosticStatusDefaultTypeInternal _DiagnosticStatus_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class KeyValue;
class KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class ServiceResponse;
class ServiceResponseDefaultTypeInternal;
extern ServiceResponseDefaultTypeInternal _ServiceResponse_default_instance_;
class ServiceSelfTest;
class ServiceSelfTestDefaultTypeInternal;
extern ServiceSelfTestDefaultTypeInternal _ServiceSelfTest_default_instance_;
class String;
class StringDefaultTypeInternal;
extern StringDefaultTypeInternal _String_default_instance_;
}  // namespace choreo

namespace choreo {

namespace protobuf_diagnostic_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_diagnostic_2eproto

enum DiagnosticStatus_Level {
  DiagnosticStatus_Level_OK = 0,
  DiagnosticStatus_Level_WARN = 1,
  DiagnosticStatus_Level_ERROR = 2,
  DiagnosticStatus_Level_STALE = 3,
  DiagnosticStatus_Level_DiagnosticStatus_Level_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DiagnosticStatus_Level_DiagnosticStatus_Level_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DiagnosticStatus_Level_IsValid(int value);
const DiagnosticStatus_Level DiagnosticStatus_Level_Level_MIN = DiagnosticStatus_Level_OK;
const DiagnosticStatus_Level DiagnosticStatus_Level_Level_MAX = DiagnosticStatus_Level_STALE;
const int DiagnosticStatus_Level_Level_ARRAYSIZE = DiagnosticStatus_Level_Level_MAX + 1;

const ::google::protobuf::EnumDescriptor* DiagnosticStatus_Level_descriptor();
inline const ::std::string& DiagnosticStatus_Level_Name(DiagnosticStatus_Level value) {
  return ::google::protobuf::internal::NameOfEnum(
    DiagnosticStatus_Level_descriptor(), value);
}
inline bool DiagnosticStatus_Level_Parse(
    const ::std::string& name, DiagnosticStatus_Level* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DiagnosticStatus_Level>(
    DiagnosticStatus_Level_descriptor(), name, value);
}
// ===================================================================

class KeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.KeyValue) */ {
 public:
  KeyValue();
  virtual ~KeyValue();

  KeyValue(const KeyValue& from);

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValue& default_instance();

  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
               &_KeyValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(KeyValue* other);

  // implements Message ----------------------------------------------

  inline KeyValue* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .choreo.String key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::choreo::String& key() const;
  ::choreo::String* mutable_key();
  ::choreo::String* release_key();
  void set_allocated_key(::choreo::String* key);

  // .choreo.String value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::choreo::String& value() const;
  ::choreo::String* mutable_value();
  ::choreo::String* release_value();
  void set_allocated_value(::choreo::String* value);

  // @@protoc_insertion_point(class_scope:choreo.KeyValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::String* key_;
  ::choreo::String* value_;
  mutable int _cached_size_;
  friend struct protobuf_diagnostic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DiagnosticStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.DiagnosticStatus) */ {
 public:
  DiagnosticStatus();
  virtual ~DiagnosticStatus();

  DiagnosticStatus(const DiagnosticStatus& from);

  inline DiagnosticStatus& operator=(const DiagnosticStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiagnosticStatus& default_instance();

  static inline const DiagnosticStatus* internal_default_instance() {
    return reinterpret_cast<const DiagnosticStatus*>(
               &_DiagnosticStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(DiagnosticStatus* other);

  // implements Message ----------------------------------------------

  inline DiagnosticStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  DiagnosticStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DiagnosticStatus& from);
  void MergeFrom(const DiagnosticStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DiagnosticStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DiagnosticStatus_Level Level;
  static const Level OK =
    DiagnosticStatus_Level_OK;
  static const Level WARN =
    DiagnosticStatus_Level_WARN;
  static const Level ERROR =
    DiagnosticStatus_Level_ERROR;
  static const Level STALE =
    DiagnosticStatus_Level_STALE;
  static inline bool Level_IsValid(int value) {
    return DiagnosticStatus_Level_IsValid(value);
  }
  static const Level Level_MIN =
    DiagnosticStatus_Level_Level_MIN;
  static const Level Level_MAX =
    DiagnosticStatus_Level_Level_MAX;
  static const int Level_ARRAYSIZE =
    DiagnosticStatus_Level_Level_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Level_descriptor() {
    return DiagnosticStatus_Level_descriptor();
  }
  static inline const ::std::string& Level_Name(Level value) {
    return DiagnosticStatus_Level_Name(value);
  }
  static inline bool Level_Parse(const ::std::string& name,
      Level* value) {
    return DiagnosticStatus_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .choreo.KeyValue values = 5;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 5;
  const ::choreo::KeyValue& values(int index) const;
  ::choreo::KeyValue* mutable_values(int index);
  ::choreo::KeyValue* add_values();
  ::google::protobuf::RepeatedPtrField< ::choreo::KeyValue >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::choreo::KeyValue >&
      values() const;

  // .choreo.String name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::choreo::String& name() const;
  ::choreo::String* mutable_name();
  ::choreo::String* release_name();
  void set_allocated_name(::choreo::String* name);

  // .choreo.String message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::choreo::String& message() const;
  ::choreo::String* mutable_message();
  ::choreo::String* release_message();
  void set_allocated_message(::choreo::String* message);

  // .choreo.String hardware_id = 4;
  bool has_hardware_id() const;
  void clear_hardware_id();
  static const int kHardwareIdFieldNumber = 4;
  const ::choreo::String& hardware_id() const;
  ::choreo::String* mutable_hardware_id();
  ::choreo::String* release_hardware_id();
  void set_allocated_hardware_id(::choreo::String* hardware_id);

  // .choreo.DiagnosticStatus.Level level = 1;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::choreo::DiagnosticStatus_Level level() const;
  void set_level(::choreo::DiagnosticStatus_Level value);

  // @@protoc_insertion_point(class_scope:choreo.DiagnosticStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::KeyValue > values_;
  ::choreo::String* name_;
  ::choreo::String* message_;
  ::choreo::String* hardware_id_;
  int level_;
  mutable int _cached_size_;
  friend struct protobuf_diagnostic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DiagnosticArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.DiagnosticArray) */ {
 public:
  DiagnosticArray();
  virtual ~DiagnosticArray();

  DiagnosticArray(const DiagnosticArray& from);

  inline DiagnosticArray& operator=(const DiagnosticArray& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiagnosticArray& default_instance();

  static inline const DiagnosticArray* internal_default_instance() {
    return reinterpret_cast<const DiagnosticArray*>(
               &_DiagnosticArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DiagnosticArray* other);

  // implements Message ----------------------------------------------

  inline DiagnosticArray* New() const PROTOBUF_FINAL { return New(NULL); }

  DiagnosticArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DiagnosticArray& from);
  void MergeFrom(const DiagnosticArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DiagnosticArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.DiagnosticStatus status = 2;
  int status_size() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::choreo::DiagnosticStatus& status(int index) const;
  ::choreo::DiagnosticStatus* mutable_status(int index);
  ::choreo::DiagnosticStatus* add_status();
  ::google::protobuf::RepeatedPtrField< ::choreo::DiagnosticStatus >*
      mutable_status();
  const ::google::protobuf::RepeatedPtrField< ::choreo::DiagnosticStatus >&
      status() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // @@protoc_insertion_point(class_scope:choreo.DiagnosticArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::DiagnosticStatus > status_;
  ::choreo::Header* header_;
  mutable int _cached_size_;
  friend struct protobuf_diagnostic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServiceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.ServiceResponse) */ {
 public:
  ServiceResponse();
  virtual ~ServiceResponse();

  ServiceResponse(const ServiceResponse& from);

  inline ServiceResponse& operator=(const ServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceResponse& default_instance();

  static inline const ServiceResponse* internal_default_instance() {
    return reinterpret_cast<const ServiceResponse*>(
               &_ServiceResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ServiceResponse* other);

  // implements Message ----------------------------------------------

  inline ServiceResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ServiceResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServiceResponse& from);
  void MergeFrom(const ServiceResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServiceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.Bool success = 2;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 2;
  const ::choreo::Bool& success() const;
  ::choreo::Bool* mutable_success();
  ::choreo::Bool* release_success();
  void set_allocated_success(::choreo::Bool* success);

  // .choreo.String message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::choreo::String& message() const;
  ::choreo::String* mutable_message();
  ::choreo::String* release_message();
  void set_allocated_message(::choreo::String* message);

  // @@protoc_insertion_point(class_scope:choreo.ServiceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::Header* header_;
  ::choreo::Bool* success_;
  ::choreo::String* message_;
  mutable int _cached_size_;
  friend struct protobuf_diagnostic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServiceSelfTest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.ServiceSelfTest) */ {
 public:
  ServiceSelfTest();
  virtual ~ServiceSelfTest();

  ServiceSelfTest(const ServiceSelfTest& from);

  inline ServiceSelfTest& operator=(const ServiceSelfTest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceSelfTest& default_instance();

  static inline const ServiceSelfTest* internal_default_instance() {
    return reinterpret_cast<const ServiceSelfTest*>(
               &_ServiceSelfTest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ServiceSelfTest* other);

  // implements Message ----------------------------------------------

  inline ServiceSelfTest* New() const PROTOBUF_FINAL { return New(NULL); }

  ServiceSelfTest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServiceSelfTest& from);
  void MergeFrom(const ServiceSelfTest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServiceSelfTest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.DiagnosticStatus status = 3;
  int status_size() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  const ::choreo::DiagnosticStatus& status(int index) const;
  ::choreo::DiagnosticStatus* mutable_status(int index);
  ::choreo::DiagnosticStatus* add_status();
  ::google::protobuf::RepeatedPtrField< ::choreo::DiagnosticStatus >*
      mutable_status();
  const ::google::protobuf::RepeatedPtrField< ::choreo::DiagnosticStatus >&
      status() const;

  // .choreo.String id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::choreo::String& id() const;
  ::choreo::String* mutable_id();
  ::choreo::String* release_id();
  void set_allocated_id(::choreo::String* id);

  // .choreo.Bool passed = 2;
  bool has_passed() const;
  void clear_passed();
  static const int kPassedFieldNumber = 2;
  const ::choreo::Bool& passed() const;
  ::choreo::Bool* mutable_passed();
  ::choreo::Bool* release_passed();
  void set_allocated_passed(::choreo::Bool* passed);

  // @@protoc_insertion_point(class_scope:choreo.ServiceSelfTest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::DiagnosticStatus > status_;
  ::choreo::String* id_;
  ::choreo::Bool* passed_;
  mutable int _cached_size_;
  friend struct protobuf_diagnostic_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// KeyValue

// .choreo.String key = 1;
inline bool KeyValue::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline void KeyValue::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::choreo::String& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:choreo.KeyValue.key)
  return key_ != NULL ? *key_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* KeyValue::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.KeyValue.key)
  return key_;
}
inline ::choreo::String* KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:choreo.KeyValue.key)
  
  ::choreo::String* temp = key_;
  key_ = NULL;
  return temp;
}
inline void KeyValue::set_allocated_key(::choreo::String* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.KeyValue.key)
}

// .choreo.String value = 2;
inline bool KeyValue::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void KeyValue::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::choreo::String& KeyValue::value() const {
  // @@protoc_insertion_point(field_get:choreo.KeyValue.value)
  return value_ != NULL ? *value_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* KeyValue::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.KeyValue.value)
  return value_;
}
inline ::choreo::String* KeyValue::release_value() {
  // @@protoc_insertion_point(field_release:choreo.KeyValue.value)
  
  ::choreo::String* temp = value_;
  value_ = NULL;
  return temp;
}
inline void KeyValue::set_allocated_value(::choreo::String* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.KeyValue.value)
}

// -------------------------------------------------------------------

// DiagnosticStatus

// .choreo.DiagnosticStatus.Level level = 1;
inline void DiagnosticStatus::clear_level() {
  level_ = 0;
}
inline ::choreo::DiagnosticStatus_Level DiagnosticStatus::level() const {
  // @@protoc_insertion_point(field_get:choreo.DiagnosticStatus.level)
  return static_cast< ::choreo::DiagnosticStatus_Level >(level_);
}
inline void DiagnosticStatus::set_level(::choreo::DiagnosticStatus_Level value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:choreo.DiagnosticStatus.level)
}

// .choreo.String name = 2;
inline bool DiagnosticStatus::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline void DiagnosticStatus::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) delete name_;
  name_ = NULL;
}
inline const ::choreo::String& DiagnosticStatus::name() const {
  // @@protoc_insertion_point(field_get:choreo.DiagnosticStatus.name)
  return name_ != NULL ? *name_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* DiagnosticStatus::mutable_name() {
  
  if (name_ == NULL) {
    name_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.DiagnosticStatus.name)
  return name_;
}
inline ::choreo::String* DiagnosticStatus::release_name() {
  // @@protoc_insertion_point(field_release:choreo.DiagnosticStatus.name)
  
  ::choreo::String* temp = name_;
  name_ = NULL;
  return temp;
}
inline void DiagnosticStatus::set_allocated_name(::choreo::String* name) {
  delete name_;
  name_ = name;
  if (name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.DiagnosticStatus.name)
}

// .choreo.String message = 3;
inline bool DiagnosticStatus::has_message() const {
  return this != internal_default_instance() && message_ != NULL;
}
inline void DiagnosticStatus::clear_message() {
  if (GetArenaNoVirtual() == NULL && message_ != NULL) delete message_;
  message_ = NULL;
}
inline const ::choreo::String& DiagnosticStatus::message() const {
  // @@protoc_insertion_point(field_get:choreo.DiagnosticStatus.message)
  return message_ != NULL ? *message_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* DiagnosticStatus::mutable_message() {
  
  if (message_ == NULL) {
    message_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.DiagnosticStatus.message)
  return message_;
}
inline ::choreo::String* DiagnosticStatus::release_message() {
  // @@protoc_insertion_point(field_release:choreo.DiagnosticStatus.message)
  
  ::choreo::String* temp = message_;
  message_ = NULL;
  return temp;
}
inline void DiagnosticStatus::set_allocated_message(::choreo::String* message) {
  delete message_;
  message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.DiagnosticStatus.message)
}

// .choreo.String hardware_id = 4;
inline bool DiagnosticStatus::has_hardware_id() const {
  return this != internal_default_instance() && hardware_id_ != NULL;
}
inline void DiagnosticStatus::clear_hardware_id() {
  if (GetArenaNoVirtual() == NULL && hardware_id_ != NULL) delete hardware_id_;
  hardware_id_ = NULL;
}
inline const ::choreo::String& DiagnosticStatus::hardware_id() const {
  // @@protoc_insertion_point(field_get:choreo.DiagnosticStatus.hardware_id)
  return hardware_id_ != NULL ? *hardware_id_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* DiagnosticStatus::mutable_hardware_id() {
  
  if (hardware_id_ == NULL) {
    hardware_id_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.DiagnosticStatus.hardware_id)
  return hardware_id_;
}
inline ::choreo::String* DiagnosticStatus::release_hardware_id() {
  // @@protoc_insertion_point(field_release:choreo.DiagnosticStatus.hardware_id)
  
  ::choreo::String* temp = hardware_id_;
  hardware_id_ = NULL;
  return temp;
}
inline void DiagnosticStatus::set_allocated_hardware_id(::choreo::String* hardware_id) {
  delete hardware_id_;
  hardware_id_ = hardware_id;
  if (hardware_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.DiagnosticStatus.hardware_id)
}

// repeated .choreo.KeyValue values = 5;
inline int DiagnosticStatus::values_size() const {
  return values_.size();
}
inline void DiagnosticStatus::clear_values() {
  values_.Clear();
}
inline const ::choreo::KeyValue& DiagnosticStatus::values(int index) const {
  // @@protoc_insertion_point(field_get:choreo.DiagnosticStatus.values)
  return values_.Get(index);
}
inline ::choreo::KeyValue* DiagnosticStatus::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.DiagnosticStatus.values)
  return values_.Mutable(index);
}
inline ::choreo::KeyValue* DiagnosticStatus::add_values() {
  // @@protoc_insertion_point(field_add:choreo.DiagnosticStatus.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::KeyValue >*
DiagnosticStatus::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:choreo.DiagnosticStatus.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::KeyValue >&
DiagnosticStatus::values() const {
  // @@protoc_insertion_point(field_list:choreo.DiagnosticStatus.values)
  return values_;
}

// -------------------------------------------------------------------

// DiagnosticArray

// .choreo.Header header = 1;
inline bool DiagnosticArray::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DiagnosticArray::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& DiagnosticArray::header() const {
  // @@protoc_insertion_point(field_get:choreo.DiagnosticArray.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* DiagnosticArray::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.DiagnosticArray.header)
  return header_;
}
inline ::choreo::Header* DiagnosticArray::release_header() {
  // @@protoc_insertion_point(field_release:choreo.DiagnosticArray.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DiagnosticArray::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.DiagnosticArray.header)
}

// repeated .choreo.DiagnosticStatus status = 2;
inline int DiagnosticArray::status_size() const {
  return status_.size();
}
inline void DiagnosticArray::clear_status() {
  status_.Clear();
}
inline const ::choreo::DiagnosticStatus& DiagnosticArray::status(int index) const {
  // @@protoc_insertion_point(field_get:choreo.DiagnosticArray.status)
  return status_.Get(index);
}
inline ::choreo::DiagnosticStatus* DiagnosticArray::mutable_status(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.DiagnosticArray.status)
  return status_.Mutable(index);
}
inline ::choreo::DiagnosticStatus* DiagnosticArray::add_status() {
  // @@protoc_insertion_point(field_add:choreo.DiagnosticArray.status)
  return status_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::DiagnosticStatus >*
DiagnosticArray::mutable_status() {
  // @@protoc_insertion_point(field_mutable_list:choreo.DiagnosticArray.status)
  return &status_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::DiagnosticStatus >&
DiagnosticArray::status() const {
  // @@protoc_insertion_point(field_list:choreo.DiagnosticArray.status)
  return status_;
}

// -------------------------------------------------------------------

// ServiceResponse

// .choreo.Header header = 1;
inline bool ServiceResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ServiceResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& ServiceResponse::header() const {
  // @@protoc_insertion_point(field_get:choreo.ServiceResponse.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* ServiceResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ServiceResponse.header)
  return header_;
}
inline ::choreo::Header* ServiceResponse::release_header() {
  // @@protoc_insertion_point(field_release:choreo.ServiceResponse.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ServiceResponse::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ServiceResponse.header)
}

// .choreo.Bool success = 2;
inline bool ServiceResponse::has_success() const {
  return this != internal_default_instance() && success_ != NULL;
}
inline void ServiceResponse::clear_success() {
  if (GetArenaNoVirtual() == NULL && success_ != NULL) delete success_;
  success_ = NULL;
}
inline const ::choreo::Bool& ServiceResponse::success() const {
  // @@protoc_insertion_point(field_get:choreo.ServiceResponse.success)
  return success_ != NULL ? *success_
                         : *::choreo::Bool::internal_default_instance();
}
inline ::choreo::Bool* ServiceResponse::mutable_success() {
  
  if (success_ == NULL) {
    success_ = new ::choreo::Bool;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ServiceResponse.success)
  return success_;
}
inline ::choreo::Bool* ServiceResponse::release_success() {
  // @@protoc_insertion_point(field_release:choreo.ServiceResponse.success)
  
  ::choreo::Bool* temp = success_;
  success_ = NULL;
  return temp;
}
inline void ServiceResponse::set_allocated_success(::choreo::Bool* success) {
  delete success_;
  success_ = success;
  if (success) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ServiceResponse.success)
}

// .choreo.String message = 3;
inline bool ServiceResponse::has_message() const {
  return this != internal_default_instance() && message_ != NULL;
}
inline void ServiceResponse::clear_message() {
  if (GetArenaNoVirtual() == NULL && message_ != NULL) delete message_;
  message_ = NULL;
}
inline const ::choreo::String& ServiceResponse::message() const {
  // @@protoc_insertion_point(field_get:choreo.ServiceResponse.message)
  return message_ != NULL ? *message_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* ServiceResponse::mutable_message() {
  
  if (message_ == NULL) {
    message_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ServiceResponse.message)
  return message_;
}
inline ::choreo::String* ServiceResponse::release_message() {
  // @@protoc_insertion_point(field_release:choreo.ServiceResponse.message)
  
  ::choreo::String* temp = message_;
  message_ = NULL;
  return temp;
}
inline void ServiceResponse::set_allocated_message(::choreo::String* message) {
  delete message_;
  message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ServiceResponse.message)
}

// -------------------------------------------------------------------

// ServiceSelfTest

// .choreo.String id = 1;
inline bool ServiceSelfTest::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline void ServiceSelfTest::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) delete id_;
  id_ = NULL;
}
inline const ::choreo::String& ServiceSelfTest::id() const {
  // @@protoc_insertion_point(field_get:choreo.ServiceSelfTest.id)
  return id_ != NULL ? *id_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* ServiceSelfTest::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ServiceSelfTest.id)
  return id_;
}
inline ::choreo::String* ServiceSelfTest::release_id() {
  // @@protoc_insertion_point(field_release:choreo.ServiceSelfTest.id)
  
  ::choreo::String* temp = id_;
  id_ = NULL;
  return temp;
}
inline void ServiceSelfTest::set_allocated_id(::choreo::String* id) {
  delete id_;
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ServiceSelfTest.id)
}

// .choreo.Bool passed = 2;
inline bool ServiceSelfTest::has_passed() const {
  return this != internal_default_instance() && passed_ != NULL;
}
inline void ServiceSelfTest::clear_passed() {
  if (GetArenaNoVirtual() == NULL && passed_ != NULL) delete passed_;
  passed_ = NULL;
}
inline const ::choreo::Bool& ServiceSelfTest::passed() const {
  // @@protoc_insertion_point(field_get:choreo.ServiceSelfTest.passed)
  return passed_ != NULL ? *passed_
                         : *::choreo::Bool::internal_default_instance();
}
inline ::choreo::Bool* ServiceSelfTest::mutable_passed() {
  
  if (passed_ == NULL) {
    passed_ = new ::choreo::Bool;
  }
  // @@protoc_insertion_point(field_mutable:choreo.ServiceSelfTest.passed)
  return passed_;
}
inline ::choreo::Bool* ServiceSelfTest::release_passed() {
  // @@protoc_insertion_point(field_release:choreo.ServiceSelfTest.passed)
  
  ::choreo::Bool* temp = passed_;
  passed_ = NULL;
  return temp;
}
inline void ServiceSelfTest::set_allocated_passed(::choreo::Bool* passed) {
  delete passed_;
  passed_ = passed;
  if (passed) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.ServiceSelfTest.passed)
}

// repeated .choreo.DiagnosticStatus status = 3;
inline int ServiceSelfTest::status_size() const {
  return status_.size();
}
inline void ServiceSelfTest::clear_status() {
  status_.Clear();
}
inline const ::choreo::DiagnosticStatus& ServiceSelfTest::status(int index) const {
  // @@protoc_insertion_point(field_get:choreo.ServiceSelfTest.status)
  return status_.Get(index);
}
inline ::choreo::DiagnosticStatus* ServiceSelfTest::mutable_status(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.ServiceSelfTest.status)
  return status_.Mutable(index);
}
inline ::choreo::DiagnosticStatus* ServiceSelfTest::add_status() {
  // @@protoc_insertion_point(field_add:choreo.ServiceSelfTest.status)
  return status_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::DiagnosticStatus >*
ServiceSelfTest::mutable_status() {
  // @@protoc_insertion_point(field_mutable_list:choreo.ServiceSelfTest.status)
  return &status_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::DiagnosticStatus >&
ServiceSelfTest::status() const {
  // @@protoc_insertion_point(field_list:choreo.ServiceSelfTest.status)
  return status_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace choreo

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::choreo::DiagnosticStatus_Level> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::choreo::DiagnosticStatus_Level>() {
  return ::choreo::DiagnosticStatus_Level_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_diagnostic_2eproto__INCLUDED
