// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nav.proto

#ifndef PROTOBUF_nav_2eproto__INCLUDED
#define PROTOBUF_nav_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "primitive/bytes.pb.h"
#include "primitive/float.pb.h"
#include "primitive/header.pb.h"
#include "primitive/int.pb.h"
#include "primitive/string.pb.h"
#include "geometric/point.pb.h"
#include "geometric/pose.pb.h"
#include "geometric/twist.pb.h"
// @@protoc_insertion_point(includes)
namespace choreo {
class Bytes;
class BytesDefaultTypeInternal;
extern BytesDefaultTypeInternal _Bytes_default_instance_;
class Float;
class FloatDefaultTypeInternal;
extern FloatDefaultTypeInternal _Float_default_instance_;
class Float32;
class Float32DefaultTypeInternal;
extern Float32DefaultTypeInternal _Float32_default_instance_;
class Float32Array;
class Float32ArrayDefaultTypeInternal;
extern Float32ArrayDefaultTypeInternal _Float32Array_default_instance_;
class Float64;
class Float64DefaultTypeInternal;
extern Float64DefaultTypeInternal _Float64_default_instance_;
class Float64Array;
class Float64ArrayDefaultTypeInternal;
extern Float64ArrayDefaultTypeInternal _Float64Array_default_instance_;
class FloatArray;
class FloatArrayDefaultTypeInternal;
extern FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
class GetPlanRequest;
class GetPlanRequestDefaultTypeInternal;
extern GetPlanRequestDefaultTypeInternal _GetPlanRequest_default_instance_;
class GridCells;
class GridCellsDefaultTypeInternal;
extern GridCellsDefaultTypeInternal _GridCells_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Int32;
class Int32DefaultTypeInternal;
extern Int32DefaultTypeInternal _Int32_default_instance_;
class Int32Array;
class Int32ArrayDefaultTypeInternal;
extern Int32ArrayDefaultTypeInternal _Int32Array_default_instance_;
class Int64;
class Int64DefaultTypeInternal;
extern Int64DefaultTypeInternal _Int64_default_instance_;
class Int64Array;
class Int64ArrayDefaultTypeInternal;
extern Int64ArrayDefaultTypeInternal _Int64Array_default_instance_;
class MapMetaData;
class MapMetaDataDefaultTypeInternal;
extern MapMetaDataDefaultTypeInternal _MapMetaData_default_instance_;
class OccupancyGrid;
class OccupancyGridDefaultTypeInternal;
extern OccupancyGridDefaultTypeInternal _OccupancyGrid_default_instance_;
class Odometry;
class OdometryDefaultTypeInternal;
extern OdometryDefaultTypeInternal _Odometry_default_instance_;
class Path;
class PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Point32;
class Point32DefaultTypeInternal;
extern Point32DefaultTypeInternal _Point32_default_instance_;
class Point32Stamped;
class Point32StampedDefaultTypeInternal;
extern Point32StampedDefaultTypeInternal _Point32Stamped_default_instance_;
class PointStamped;
class PointStampedDefaultTypeInternal;
extern PointStampedDefaultTypeInternal _PointStamped_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Pose2D;
class Pose2DDefaultTypeInternal;
extern Pose2DDefaultTypeInternal _Pose2D_default_instance_;
class Pose2DStamped;
class Pose2DStampedDefaultTypeInternal;
extern Pose2DStampedDefaultTypeInternal _Pose2DStamped_default_instance_;
class PoseArray;
class PoseArrayDefaultTypeInternal;
extern PoseArrayDefaultTypeInternal _PoseArray_default_instance_;
class PoseStamped;
class PoseStampedDefaultTypeInternal;
extern PoseStampedDefaultTypeInternal _PoseStamped_default_instance_;
class PoseWithCovariance;
class PoseWithCovarianceDefaultTypeInternal;
extern PoseWithCovarianceDefaultTypeInternal _PoseWithCovariance_default_instance_;
class PoseWithCovarianceStamped;
class PoseWithCovarianceStampedDefaultTypeInternal;
extern PoseWithCovarianceStampedDefaultTypeInternal _PoseWithCovarianceStamped_default_instance_;
class SInt32;
class SInt32DefaultTypeInternal;
extern SInt32DefaultTypeInternal _SInt32_default_instance_;
class SInt32Array;
class SInt32ArrayDefaultTypeInternal;
extern SInt32ArrayDefaultTypeInternal _SInt32Array_default_instance_;
class SInt64;
class SInt64DefaultTypeInternal;
extern SInt64DefaultTypeInternal _SInt64_default_instance_;
class SInt64Array;
class SInt64ArrayDefaultTypeInternal;
extern SInt64ArrayDefaultTypeInternal _SInt64Array_default_instance_;
class SetMapRequest;
class SetMapRequestDefaultTypeInternal;
extern SetMapRequestDefaultTypeInternal _SetMapRequest_default_instance_;
class String;
class StringDefaultTypeInternal;
extern StringDefaultTypeInternal _String_default_instance_;
class Twist;
class TwistDefaultTypeInternal;
extern TwistDefaultTypeInternal _Twist_default_instance_;
class TwistStamped;
class TwistStampedDefaultTypeInternal;
extern TwistStampedDefaultTypeInternal _TwistStamped_default_instance_;
class TwistWithCovariance;
class TwistWithCovarianceDefaultTypeInternal;
extern TwistWithCovarianceDefaultTypeInternal _TwistWithCovariance_default_instance_;
class TwistWithCovarianceStamped;
class TwistWithCovarianceStampedDefaultTypeInternal;
extern TwistWithCovarianceStampedDefaultTypeInternal _TwistWithCovarianceStamped_default_instance_;
class UInt32;
class UInt32DefaultTypeInternal;
extern UInt32DefaultTypeInternal _UInt32_default_instance_;
class UInt32Array;
class UInt32ArrayDefaultTypeInternal;
extern UInt32ArrayDefaultTypeInternal _UInt32Array_default_instance_;
class UInt64;
class UInt64DefaultTypeInternal;
extern UInt64DefaultTypeInternal _UInt64_default_instance_;
class UInt64Array;
class UInt64ArrayDefaultTypeInternal;
extern UInt64ArrayDefaultTypeInternal _UInt64Array_default_instance_;
}  // namespace choreo
namespace google {
namespace protobuf {
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
}  // namespace protobuf
}  // namespace google

namespace choreo {

namespace protobuf_nav_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_nav_2eproto

// ===================================================================

class GridCells : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.GridCells) */ {
 public:
  GridCells();
  virtual ~GridCells();

  GridCells(const GridCells& from);

  inline GridCells& operator=(const GridCells& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GridCells& default_instance();

  static inline const GridCells* internal_default_instance() {
    return reinterpret_cast<const GridCells*>(
               &_GridCells_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(GridCells* other);

  // implements Message ----------------------------------------------

  inline GridCells* New() const PROTOBUF_FINAL { return New(NULL); }

  GridCells* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GridCells& from);
  void MergeFrom(const GridCells& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GridCells* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.Point cells = 4;
  int cells_size() const;
  void clear_cells();
  static const int kCellsFieldNumber = 4;
  const ::choreo::Point& cells(int index) const;
  ::choreo::Point* mutable_cells(int index);
  ::choreo::Point* add_cells();
  ::google::protobuf::RepeatedPtrField< ::choreo::Point >*
      mutable_cells();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Point >&
      cells() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.Float64 cell_width = 2;
  bool has_cell_width() const;
  void clear_cell_width();
  static const int kCellWidthFieldNumber = 2;
  const ::choreo::Float64& cell_width() const;
  ::choreo::Float64* mutable_cell_width();
  ::choreo::Float64* release_cell_width();
  void set_allocated_cell_width(::choreo::Float64* cell_width);

  // .choreo.Float64 cell_height = 3;
  bool has_cell_height() const;
  void clear_cell_height();
  static const int kCellHeightFieldNumber = 3;
  const ::choreo::Float64& cell_height() const;
  ::choreo::Float64* mutable_cell_height();
  ::choreo::Float64* release_cell_height();
  void set_allocated_cell_height(::choreo::Float64* cell_height);

  // @@protoc_insertion_point(class_scope:choreo.GridCells)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Point > cells_;
  ::choreo::Header* header_;
  ::choreo::Float64* cell_width_;
  ::choreo::Float64* cell_height_;
  mutable int _cached_size_;
  friend struct protobuf_nav_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapMetaData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.MapMetaData) */ {
 public:
  MapMetaData();
  virtual ~MapMetaData();

  MapMetaData(const MapMetaData& from);

  inline MapMetaData& operator=(const MapMetaData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapMetaData& default_instance();

  static inline const MapMetaData* internal_default_instance() {
    return reinterpret_cast<const MapMetaData*>(
               &_MapMetaData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MapMetaData* other);

  // implements Message ----------------------------------------------

  inline MapMetaData* New() const PROTOBUF_FINAL { return New(NULL); }

  MapMetaData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapMetaData& from);
  void MergeFrom(const MapMetaData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapMetaData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Timestamp map_load_time = 1;
  bool has_map_load_time() const;
  void clear_map_load_time();
  static const int kMapLoadTimeFieldNumber = 1;
  const ::google::protobuf::Timestamp& map_load_time() const;
  ::google::protobuf::Timestamp* mutable_map_load_time();
  ::google::protobuf::Timestamp* release_map_load_time();
  void set_allocated_map_load_time(::google::protobuf::Timestamp* map_load_time);

  // .choreo.Float32 resolution = 2;
  bool has_resolution() const;
  void clear_resolution();
  static const int kResolutionFieldNumber = 2;
  const ::choreo::Float32& resolution() const;
  ::choreo::Float32* mutable_resolution();
  ::choreo::Float32* release_resolution();
  void set_allocated_resolution(::choreo::Float32* resolution);

  // .choreo.UInt32 width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  const ::choreo::UInt32& width() const;
  ::choreo::UInt32* mutable_width();
  ::choreo::UInt32* release_width();
  void set_allocated_width(::choreo::UInt32* width);

  // .choreo.UInt32 height = 4;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  const ::choreo::UInt32& height() const;
  ::choreo::UInt32* mutable_height();
  ::choreo::UInt32* release_height();
  void set_allocated_height(::choreo::UInt32* height);

  // .choreo.Pose origin = 5;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 5;
  const ::choreo::Pose& origin() const;
  ::choreo::Pose* mutable_origin();
  ::choreo::Pose* release_origin();
  void set_allocated_origin(::choreo::Pose* origin);

  // @@protoc_insertion_point(class_scope:choreo.MapMetaData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Timestamp* map_load_time_;
  ::choreo::Float32* resolution_;
  ::choreo::UInt32* width_;
  ::choreo::UInt32* height_;
  ::choreo::Pose* origin_;
  mutable int _cached_size_;
  friend struct protobuf_nav_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OccupancyGrid : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.OccupancyGrid) */ {
 public:
  OccupancyGrid();
  virtual ~OccupancyGrid();

  OccupancyGrid(const OccupancyGrid& from);

  inline OccupancyGrid& operator=(const OccupancyGrid& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OccupancyGrid& default_instance();

  static inline const OccupancyGrid* internal_default_instance() {
    return reinterpret_cast<const OccupancyGrid*>(
               &_OccupancyGrid_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(OccupancyGrid* other);

  // implements Message ----------------------------------------------

  inline OccupancyGrid* New() const PROTOBUF_FINAL { return New(NULL); }

  OccupancyGrid* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OccupancyGrid& from);
  void MergeFrom(const OccupancyGrid& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OccupancyGrid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.MapMetaData info = 2;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::choreo::MapMetaData& info() const;
  ::choreo::MapMetaData* mutable_info();
  ::choreo::MapMetaData* release_info();
  void set_allocated_info(::choreo::MapMetaData* info);

  // .choreo.Bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::choreo::Bytes& data() const;
  ::choreo::Bytes* mutable_data();
  ::choreo::Bytes* release_data();
  void set_allocated_data(::choreo::Bytes* data);

  // @@protoc_insertion_point(class_scope:choreo.OccupancyGrid)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::Header* header_;
  ::choreo::MapMetaData* info_;
  ::choreo::Bytes* data_;
  mutable int _cached_size_;
  friend struct protobuf_nav_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Odometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.Odometry) */ {
 public:
  Odometry();
  virtual ~Odometry();

  Odometry(const Odometry& from);

  inline Odometry& operator=(const Odometry& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Odometry& default_instance();

  static inline const Odometry* internal_default_instance() {
    return reinterpret_cast<const Odometry*>(
               &_Odometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Odometry* other);

  // implements Message ----------------------------------------------

  inline Odometry* New() const PROTOBUF_FINAL { return New(NULL); }

  Odometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Odometry& from);
  void MergeFrom(const Odometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Odometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // .choreo.String child_frame_id = 2;
  bool has_child_frame_id() const;
  void clear_child_frame_id();
  static const int kChildFrameIdFieldNumber = 2;
  const ::choreo::String& child_frame_id() const;
  ::choreo::String* mutable_child_frame_id();
  ::choreo::String* release_child_frame_id();
  void set_allocated_child_frame_id(::choreo::String* child_frame_id);

  // .choreo.PoseWithCovariance pose = 3;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 3;
  const ::choreo::PoseWithCovariance& pose() const;
  ::choreo::PoseWithCovariance* mutable_pose();
  ::choreo::PoseWithCovariance* release_pose();
  void set_allocated_pose(::choreo::PoseWithCovariance* pose);

  // .choreo.TwistWithCovariance twist = 4;
  bool has_twist() const;
  void clear_twist();
  static const int kTwistFieldNumber = 4;
  const ::choreo::TwistWithCovariance& twist() const;
  ::choreo::TwistWithCovariance* mutable_twist();
  ::choreo::TwistWithCovariance* release_twist();
  void set_allocated_twist(::choreo::TwistWithCovariance* twist);

  // @@protoc_insertion_point(class_scope:choreo.Odometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::Header* header_;
  ::choreo::String* child_frame_id_;
  ::choreo::PoseWithCovariance* pose_;
  ::choreo::TwistWithCovariance* twist_;
  mutable int _cached_size_;
  friend struct protobuf_nav_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Path : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.Path) */ {
 public:
  Path();
  virtual ~Path();

  Path(const Path& from);

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Path& default_instance();

  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Path* other);

  // implements Message ----------------------------------------------

  inline Path* New() const PROTOBUF_FINAL { return New(NULL); }

  Path* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Path& from);
  void MergeFrom(const Path& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Path* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .choreo.Pose poses = 2;
  int poses_size() const;
  void clear_poses();
  static const int kPosesFieldNumber = 2;
  const ::choreo::Pose& poses(int index) const;
  ::choreo::Pose* mutable_poses(int index);
  ::choreo::Pose* add_poses();
  ::google::protobuf::RepeatedPtrField< ::choreo::Pose >*
      mutable_poses();
  const ::google::protobuf::RepeatedPtrField< ::choreo::Pose >&
      poses() const;

  // .choreo.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::choreo::Header& header() const;
  ::choreo::Header* mutable_header();
  ::choreo::Header* release_header();
  void set_allocated_header(::choreo::Header* header);

  // @@protoc_insertion_point(class_scope:choreo.Path)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::choreo::Pose > poses_;
  ::choreo::Header* header_;
  mutable int _cached_size_;
  friend struct protobuf_nav_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetPlanRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.GetPlanRequest) */ {
 public:
  GetPlanRequest();
  virtual ~GetPlanRequest();

  GetPlanRequest(const GetPlanRequest& from);

  inline GetPlanRequest& operator=(const GetPlanRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPlanRequest& default_instance();

  static inline const GetPlanRequest* internal_default_instance() {
    return reinterpret_cast<const GetPlanRequest*>(
               &_GetPlanRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(GetPlanRequest* other);

  // implements Message ----------------------------------------------

  inline GetPlanRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetPlanRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetPlanRequest& from);
  void MergeFrom(const GetPlanRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetPlanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .choreo.PoseStamped start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  const ::choreo::PoseStamped& start() const;
  ::choreo::PoseStamped* mutable_start();
  ::choreo::PoseStamped* release_start();
  void set_allocated_start(::choreo::PoseStamped* start);

  // .choreo.PoseStamped goal = 2;
  bool has_goal() const;
  void clear_goal();
  static const int kGoalFieldNumber = 2;
  const ::choreo::PoseStamped& goal() const;
  ::choreo::PoseStamped* mutable_goal();
  ::choreo::PoseStamped* release_goal();
  void set_allocated_goal(::choreo::PoseStamped* goal);

  // .choreo.Float32 tolerance = 3;
  bool has_tolerance() const;
  void clear_tolerance();
  static const int kToleranceFieldNumber = 3;
  const ::choreo::Float32& tolerance() const;
  ::choreo::Float32* mutable_tolerance();
  ::choreo::Float32* release_tolerance();
  void set_allocated_tolerance(::choreo::Float32* tolerance);

  // @@protoc_insertion_point(class_scope:choreo.GetPlanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::PoseStamped* start_;
  ::choreo::PoseStamped* goal_;
  ::choreo::Float32* tolerance_;
  mutable int _cached_size_;
  friend struct protobuf_nav_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetMapRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:choreo.SetMapRequest) */ {
 public:
  SetMapRequest();
  virtual ~SetMapRequest();

  SetMapRequest(const SetMapRequest& from);

  inline SetMapRequest& operator=(const SetMapRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetMapRequest& default_instance();

  static inline const SetMapRequest* internal_default_instance() {
    return reinterpret_cast<const SetMapRequest*>(
               &_SetMapRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(SetMapRequest* other);

  // implements Message ----------------------------------------------

  inline SetMapRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SetMapRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetMapRequest& from);
  void MergeFrom(const SetMapRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetMapRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .choreo.OccupancyGrid map = 1;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 1;
  const ::choreo::OccupancyGrid& map() const;
  ::choreo::OccupancyGrid* mutable_map();
  ::choreo::OccupancyGrid* release_map();
  void set_allocated_map(::choreo::OccupancyGrid* map);

  // .choreo.PoseWithCovarianceStamped initial_pose = 2;
  bool has_initial_pose() const;
  void clear_initial_pose();
  static const int kInitialPoseFieldNumber = 2;
  const ::choreo::PoseWithCovarianceStamped& initial_pose() const;
  ::choreo::PoseWithCovarianceStamped* mutable_initial_pose();
  ::choreo::PoseWithCovarianceStamped* release_initial_pose();
  void set_allocated_initial_pose(::choreo::PoseWithCovarianceStamped* initial_pose);

  // @@protoc_insertion_point(class_scope:choreo.SetMapRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::choreo::OccupancyGrid* map_;
  ::choreo::PoseWithCovarianceStamped* initial_pose_;
  mutable int _cached_size_;
  friend struct protobuf_nav_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// GridCells

// .choreo.Header header = 1;
inline bool GridCells::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GridCells::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& GridCells::header() const {
  // @@protoc_insertion_point(field_get:choreo.GridCells.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* GridCells::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.GridCells.header)
  return header_;
}
inline ::choreo::Header* GridCells::release_header() {
  // @@protoc_insertion_point(field_release:choreo.GridCells.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GridCells::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.GridCells.header)
}

// .choreo.Float64 cell_width = 2;
inline bool GridCells::has_cell_width() const {
  return this != internal_default_instance() && cell_width_ != NULL;
}
inline void GridCells::clear_cell_width() {
  if (GetArenaNoVirtual() == NULL && cell_width_ != NULL) delete cell_width_;
  cell_width_ = NULL;
}
inline const ::choreo::Float64& GridCells::cell_width() const {
  // @@protoc_insertion_point(field_get:choreo.GridCells.cell_width)
  return cell_width_ != NULL ? *cell_width_
                         : *::choreo::Float64::internal_default_instance();
}
inline ::choreo::Float64* GridCells::mutable_cell_width() {
  
  if (cell_width_ == NULL) {
    cell_width_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.GridCells.cell_width)
  return cell_width_;
}
inline ::choreo::Float64* GridCells::release_cell_width() {
  // @@protoc_insertion_point(field_release:choreo.GridCells.cell_width)
  
  ::choreo::Float64* temp = cell_width_;
  cell_width_ = NULL;
  return temp;
}
inline void GridCells::set_allocated_cell_width(::choreo::Float64* cell_width) {
  delete cell_width_;
  cell_width_ = cell_width;
  if (cell_width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.GridCells.cell_width)
}

// .choreo.Float64 cell_height = 3;
inline bool GridCells::has_cell_height() const {
  return this != internal_default_instance() && cell_height_ != NULL;
}
inline void GridCells::clear_cell_height() {
  if (GetArenaNoVirtual() == NULL && cell_height_ != NULL) delete cell_height_;
  cell_height_ = NULL;
}
inline const ::choreo::Float64& GridCells::cell_height() const {
  // @@protoc_insertion_point(field_get:choreo.GridCells.cell_height)
  return cell_height_ != NULL ? *cell_height_
                         : *::choreo::Float64::internal_default_instance();
}
inline ::choreo::Float64* GridCells::mutable_cell_height() {
  
  if (cell_height_ == NULL) {
    cell_height_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.GridCells.cell_height)
  return cell_height_;
}
inline ::choreo::Float64* GridCells::release_cell_height() {
  // @@protoc_insertion_point(field_release:choreo.GridCells.cell_height)
  
  ::choreo::Float64* temp = cell_height_;
  cell_height_ = NULL;
  return temp;
}
inline void GridCells::set_allocated_cell_height(::choreo::Float64* cell_height) {
  delete cell_height_;
  cell_height_ = cell_height;
  if (cell_height) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.GridCells.cell_height)
}

// repeated .choreo.Point cells = 4;
inline int GridCells::cells_size() const {
  return cells_.size();
}
inline void GridCells::clear_cells() {
  cells_.Clear();
}
inline const ::choreo::Point& GridCells::cells(int index) const {
  // @@protoc_insertion_point(field_get:choreo.GridCells.cells)
  return cells_.Get(index);
}
inline ::choreo::Point* GridCells::mutable_cells(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.GridCells.cells)
  return cells_.Mutable(index);
}
inline ::choreo::Point* GridCells::add_cells() {
  // @@protoc_insertion_point(field_add:choreo.GridCells.cells)
  return cells_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Point >*
GridCells::mutable_cells() {
  // @@protoc_insertion_point(field_mutable_list:choreo.GridCells.cells)
  return &cells_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Point >&
GridCells::cells() const {
  // @@protoc_insertion_point(field_list:choreo.GridCells.cells)
  return cells_;
}

// -------------------------------------------------------------------

// MapMetaData

// .google.protobuf.Timestamp map_load_time = 1;
inline bool MapMetaData::has_map_load_time() const {
  return this != internal_default_instance() && map_load_time_ != NULL;
}
inline void MapMetaData::clear_map_load_time() {
  if (GetArenaNoVirtual() == NULL && map_load_time_ != NULL) delete map_load_time_;
  map_load_time_ = NULL;
}
inline const ::google::protobuf::Timestamp& MapMetaData::map_load_time() const {
  // @@protoc_insertion_point(field_get:choreo.MapMetaData.map_load_time)
  return map_load_time_ != NULL ? *map_load_time_
                         : *::google::protobuf::Timestamp::internal_default_instance();
}
inline ::google::protobuf::Timestamp* MapMetaData::mutable_map_load_time() {
  
  if (map_load_time_ == NULL) {
    map_load_time_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MapMetaData.map_load_time)
  return map_load_time_;
}
inline ::google::protobuf::Timestamp* MapMetaData::release_map_load_time() {
  // @@protoc_insertion_point(field_release:choreo.MapMetaData.map_load_time)
  
  ::google::protobuf::Timestamp* temp = map_load_time_;
  map_load_time_ = NULL;
  return temp;
}
inline void MapMetaData::set_allocated_map_load_time(::google::protobuf::Timestamp* map_load_time) {
  delete map_load_time_;
  if (map_load_time != NULL && map_load_time->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_map_load_time = new ::google::protobuf::Timestamp;
    new_map_load_time->CopyFrom(*map_load_time);
    map_load_time = new_map_load_time;
  }
  map_load_time_ = map_load_time;
  if (map_load_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MapMetaData.map_load_time)
}

// .choreo.Float32 resolution = 2;
inline bool MapMetaData::has_resolution() const {
  return this != internal_default_instance() && resolution_ != NULL;
}
inline void MapMetaData::clear_resolution() {
  if (GetArenaNoVirtual() == NULL && resolution_ != NULL) delete resolution_;
  resolution_ = NULL;
}
inline const ::choreo::Float32& MapMetaData::resolution() const {
  // @@protoc_insertion_point(field_get:choreo.MapMetaData.resolution)
  return resolution_ != NULL ? *resolution_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* MapMetaData::mutable_resolution() {
  
  if (resolution_ == NULL) {
    resolution_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MapMetaData.resolution)
  return resolution_;
}
inline ::choreo::Float32* MapMetaData::release_resolution() {
  // @@protoc_insertion_point(field_release:choreo.MapMetaData.resolution)
  
  ::choreo::Float32* temp = resolution_;
  resolution_ = NULL;
  return temp;
}
inline void MapMetaData::set_allocated_resolution(::choreo::Float32* resolution) {
  delete resolution_;
  resolution_ = resolution;
  if (resolution) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MapMetaData.resolution)
}

// .choreo.UInt32 width = 3;
inline bool MapMetaData::has_width() const {
  return this != internal_default_instance() && width_ != NULL;
}
inline void MapMetaData::clear_width() {
  if (GetArenaNoVirtual() == NULL && width_ != NULL) delete width_;
  width_ = NULL;
}
inline const ::choreo::UInt32& MapMetaData::width() const {
  // @@protoc_insertion_point(field_get:choreo.MapMetaData.width)
  return width_ != NULL ? *width_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* MapMetaData::mutable_width() {
  
  if (width_ == NULL) {
    width_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MapMetaData.width)
  return width_;
}
inline ::choreo::UInt32* MapMetaData::release_width() {
  // @@protoc_insertion_point(field_release:choreo.MapMetaData.width)
  
  ::choreo::UInt32* temp = width_;
  width_ = NULL;
  return temp;
}
inline void MapMetaData::set_allocated_width(::choreo::UInt32* width) {
  delete width_;
  width_ = width;
  if (width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MapMetaData.width)
}

// .choreo.UInt32 height = 4;
inline bool MapMetaData::has_height() const {
  return this != internal_default_instance() && height_ != NULL;
}
inline void MapMetaData::clear_height() {
  if (GetArenaNoVirtual() == NULL && height_ != NULL) delete height_;
  height_ = NULL;
}
inline const ::choreo::UInt32& MapMetaData::height() const {
  // @@protoc_insertion_point(field_get:choreo.MapMetaData.height)
  return height_ != NULL ? *height_
                         : *::choreo::UInt32::internal_default_instance();
}
inline ::choreo::UInt32* MapMetaData::mutable_height() {
  
  if (height_ == NULL) {
    height_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MapMetaData.height)
  return height_;
}
inline ::choreo::UInt32* MapMetaData::release_height() {
  // @@protoc_insertion_point(field_release:choreo.MapMetaData.height)
  
  ::choreo::UInt32* temp = height_;
  height_ = NULL;
  return temp;
}
inline void MapMetaData::set_allocated_height(::choreo::UInt32* height) {
  delete height_;
  height_ = height;
  if (height) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MapMetaData.height)
}

// .choreo.Pose origin = 5;
inline bool MapMetaData::has_origin() const {
  return this != internal_default_instance() && origin_ != NULL;
}
inline void MapMetaData::clear_origin() {
  if (GetArenaNoVirtual() == NULL && origin_ != NULL) delete origin_;
  origin_ = NULL;
}
inline const ::choreo::Pose& MapMetaData::origin() const {
  // @@protoc_insertion_point(field_get:choreo.MapMetaData.origin)
  return origin_ != NULL ? *origin_
                         : *::choreo::Pose::internal_default_instance();
}
inline ::choreo::Pose* MapMetaData::mutable_origin() {
  
  if (origin_ == NULL) {
    origin_ = new ::choreo::Pose;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MapMetaData.origin)
  return origin_;
}
inline ::choreo::Pose* MapMetaData::release_origin() {
  // @@protoc_insertion_point(field_release:choreo.MapMetaData.origin)
  
  ::choreo::Pose* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void MapMetaData::set_allocated_origin(::choreo::Pose* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MapMetaData.origin)
}

// -------------------------------------------------------------------

// OccupancyGrid

// .choreo.Header header = 1;
inline bool OccupancyGrid::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void OccupancyGrid::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& OccupancyGrid::header() const {
  // @@protoc_insertion_point(field_get:choreo.OccupancyGrid.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* OccupancyGrid::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.OccupancyGrid.header)
  return header_;
}
inline ::choreo::Header* OccupancyGrid::release_header() {
  // @@protoc_insertion_point(field_release:choreo.OccupancyGrid.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void OccupancyGrid::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.OccupancyGrid.header)
}

// .choreo.MapMetaData info = 2;
inline bool OccupancyGrid::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void OccupancyGrid::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) delete info_;
  info_ = NULL;
}
inline const ::choreo::MapMetaData& OccupancyGrid::info() const {
  // @@protoc_insertion_point(field_get:choreo.OccupancyGrid.info)
  return info_ != NULL ? *info_
                         : *::choreo::MapMetaData::internal_default_instance();
}
inline ::choreo::MapMetaData* OccupancyGrid::mutable_info() {
  
  if (info_ == NULL) {
    info_ = new ::choreo::MapMetaData;
  }
  // @@protoc_insertion_point(field_mutable:choreo.OccupancyGrid.info)
  return info_;
}
inline ::choreo::MapMetaData* OccupancyGrid::release_info() {
  // @@protoc_insertion_point(field_release:choreo.OccupancyGrid.info)
  
  ::choreo::MapMetaData* temp = info_;
  info_ = NULL;
  return temp;
}
inline void OccupancyGrid::set_allocated_info(::choreo::MapMetaData* info) {
  delete info_;
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.OccupancyGrid.info)
}

// .choreo.Bytes data = 3;
inline bool OccupancyGrid::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void OccupancyGrid::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
inline const ::choreo::Bytes& OccupancyGrid::data() const {
  // @@protoc_insertion_point(field_get:choreo.OccupancyGrid.data)
  return data_ != NULL ? *data_
                         : *::choreo::Bytes::internal_default_instance();
}
inline ::choreo::Bytes* OccupancyGrid::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::choreo::Bytes;
  }
  // @@protoc_insertion_point(field_mutable:choreo.OccupancyGrid.data)
  return data_;
}
inline ::choreo::Bytes* OccupancyGrid::release_data() {
  // @@protoc_insertion_point(field_release:choreo.OccupancyGrid.data)
  
  ::choreo::Bytes* temp = data_;
  data_ = NULL;
  return temp;
}
inline void OccupancyGrid::set_allocated_data(::choreo::Bytes* data) {
  delete data_;
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.OccupancyGrid.data)
}

// -------------------------------------------------------------------

// Odometry

// .choreo.Header header = 1;
inline bool Odometry::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Odometry::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& Odometry::header() const {
  // @@protoc_insertion_point(field_get:choreo.Odometry.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* Odometry::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Odometry.header)
  return header_;
}
inline ::choreo::Header* Odometry::release_header() {
  // @@protoc_insertion_point(field_release:choreo.Odometry.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Odometry::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Odometry.header)
}

// .choreo.String child_frame_id = 2;
inline bool Odometry::has_child_frame_id() const {
  return this != internal_default_instance() && child_frame_id_ != NULL;
}
inline void Odometry::clear_child_frame_id() {
  if (GetArenaNoVirtual() == NULL && child_frame_id_ != NULL) delete child_frame_id_;
  child_frame_id_ = NULL;
}
inline const ::choreo::String& Odometry::child_frame_id() const {
  // @@protoc_insertion_point(field_get:choreo.Odometry.child_frame_id)
  return child_frame_id_ != NULL ? *child_frame_id_
                         : *::choreo::String::internal_default_instance();
}
inline ::choreo::String* Odometry::mutable_child_frame_id() {
  
  if (child_frame_id_ == NULL) {
    child_frame_id_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Odometry.child_frame_id)
  return child_frame_id_;
}
inline ::choreo::String* Odometry::release_child_frame_id() {
  // @@protoc_insertion_point(field_release:choreo.Odometry.child_frame_id)
  
  ::choreo::String* temp = child_frame_id_;
  child_frame_id_ = NULL;
  return temp;
}
inline void Odometry::set_allocated_child_frame_id(::choreo::String* child_frame_id) {
  delete child_frame_id_;
  child_frame_id_ = child_frame_id;
  if (child_frame_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Odometry.child_frame_id)
}

// .choreo.PoseWithCovariance pose = 3;
inline bool Odometry::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
inline void Odometry::clear_pose() {
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) delete pose_;
  pose_ = NULL;
}
inline const ::choreo::PoseWithCovariance& Odometry::pose() const {
  // @@protoc_insertion_point(field_get:choreo.Odometry.pose)
  return pose_ != NULL ? *pose_
                         : *::choreo::PoseWithCovariance::internal_default_instance();
}
inline ::choreo::PoseWithCovariance* Odometry::mutable_pose() {
  
  if (pose_ == NULL) {
    pose_ = new ::choreo::PoseWithCovariance;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Odometry.pose)
  return pose_;
}
inline ::choreo::PoseWithCovariance* Odometry::release_pose() {
  // @@protoc_insertion_point(field_release:choreo.Odometry.pose)
  
  ::choreo::PoseWithCovariance* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void Odometry::set_allocated_pose(::choreo::PoseWithCovariance* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Odometry.pose)
}

// .choreo.TwistWithCovariance twist = 4;
inline bool Odometry::has_twist() const {
  return this != internal_default_instance() && twist_ != NULL;
}
inline void Odometry::clear_twist() {
  if (GetArenaNoVirtual() == NULL && twist_ != NULL) delete twist_;
  twist_ = NULL;
}
inline const ::choreo::TwistWithCovariance& Odometry::twist() const {
  // @@protoc_insertion_point(field_get:choreo.Odometry.twist)
  return twist_ != NULL ? *twist_
                         : *::choreo::TwistWithCovariance::internal_default_instance();
}
inline ::choreo::TwistWithCovariance* Odometry::mutable_twist() {
  
  if (twist_ == NULL) {
    twist_ = new ::choreo::TwistWithCovariance;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Odometry.twist)
  return twist_;
}
inline ::choreo::TwistWithCovariance* Odometry::release_twist() {
  // @@protoc_insertion_point(field_release:choreo.Odometry.twist)
  
  ::choreo::TwistWithCovariance* temp = twist_;
  twist_ = NULL;
  return temp;
}
inline void Odometry::set_allocated_twist(::choreo::TwistWithCovariance* twist) {
  delete twist_;
  twist_ = twist;
  if (twist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Odometry.twist)
}

// -------------------------------------------------------------------

// Path

// .choreo.Header header = 1;
inline bool Path::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Path::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::choreo::Header& Path::header() const {
  // @@protoc_insertion_point(field_get:choreo.Path.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
inline ::choreo::Header* Path::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Path.header)
  return header_;
}
inline ::choreo::Header* Path::release_header() {
  // @@protoc_insertion_point(field_release:choreo.Path.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Path::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Path.header)
}

// repeated .choreo.Pose poses = 2;
inline int Path::poses_size() const {
  return poses_.size();
}
inline void Path::clear_poses() {
  poses_.Clear();
}
inline const ::choreo::Pose& Path::poses(int index) const {
  // @@protoc_insertion_point(field_get:choreo.Path.poses)
  return poses_.Get(index);
}
inline ::choreo::Pose* Path::mutable_poses(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.Path.poses)
  return poses_.Mutable(index);
}
inline ::choreo::Pose* Path::add_poses() {
  // @@protoc_insertion_point(field_add:choreo.Path.poses)
  return poses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::choreo::Pose >*
Path::mutable_poses() {
  // @@protoc_insertion_point(field_mutable_list:choreo.Path.poses)
  return &poses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::choreo::Pose >&
Path::poses() const {
  // @@protoc_insertion_point(field_list:choreo.Path.poses)
  return poses_;
}

// -------------------------------------------------------------------

// GetPlanRequest

// .choreo.PoseStamped start = 1;
inline bool GetPlanRequest::has_start() const {
  return this != internal_default_instance() && start_ != NULL;
}
inline void GetPlanRequest::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) delete start_;
  start_ = NULL;
}
inline const ::choreo::PoseStamped& GetPlanRequest::start() const {
  // @@protoc_insertion_point(field_get:choreo.GetPlanRequest.start)
  return start_ != NULL ? *start_
                         : *::choreo::PoseStamped::internal_default_instance();
}
inline ::choreo::PoseStamped* GetPlanRequest::mutable_start() {
  
  if (start_ == NULL) {
    start_ = new ::choreo::PoseStamped;
  }
  // @@protoc_insertion_point(field_mutable:choreo.GetPlanRequest.start)
  return start_;
}
inline ::choreo::PoseStamped* GetPlanRequest::release_start() {
  // @@protoc_insertion_point(field_release:choreo.GetPlanRequest.start)
  
  ::choreo::PoseStamped* temp = start_;
  start_ = NULL;
  return temp;
}
inline void GetPlanRequest::set_allocated_start(::choreo::PoseStamped* start) {
  delete start_;
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.GetPlanRequest.start)
}

// .choreo.PoseStamped goal = 2;
inline bool GetPlanRequest::has_goal() const {
  return this != internal_default_instance() && goal_ != NULL;
}
inline void GetPlanRequest::clear_goal() {
  if (GetArenaNoVirtual() == NULL && goal_ != NULL) delete goal_;
  goal_ = NULL;
}
inline const ::choreo::PoseStamped& GetPlanRequest::goal() const {
  // @@protoc_insertion_point(field_get:choreo.GetPlanRequest.goal)
  return goal_ != NULL ? *goal_
                         : *::choreo::PoseStamped::internal_default_instance();
}
inline ::choreo::PoseStamped* GetPlanRequest::mutable_goal() {
  
  if (goal_ == NULL) {
    goal_ = new ::choreo::PoseStamped;
  }
  // @@protoc_insertion_point(field_mutable:choreo.GetPlanRequest.goal)
  return goal_;
}
inline ::choreo::PoseStamped* GetPlanRequest::release_goal() {
  // @@protoc_insertion_point(field_release:choreo.GetPlanRequest.goal)
  
  ::choreo::PoseStamped* temp = goal_;
  goal_ = NULL;
  return temp;
}
inline void GetPlanRequest::set_allocated_goal(::choreo::PoseStamped* goal) {
  delete goal_;
  goal_ = goal;
  if (goal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.GetPlanRequest.goal)
}

// .choreo.Float32 tolerance = 3;
inline bool GetPlanRequest::has_tolerance() const {
  return this != internal_default_instance() && tolerance_ != NULL;
}
inline void GetPlanRequest::clear_tolerance() {
  if (GetArenaNoVirtual() == NULL && tolerance_ != NULL) delete tolerance_;
  tolerance_ = NULL;
}
inline const ::choreo::Float32& GetPlanRequest::tolerance() const {
  // @@protoc_insertion_point(field_get:choreo.GetPlanRequest.tolerance)
  return tolerance_ != NULL ? *tolerance_
                         : *::choreo::Float32::internal_default_instance();
}
inline ::choreo::Float32* GetPlanRequest::mutable_tolerance() {
  
  if (tolerance_ == NULL) {
    tolerance_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.GetPlanRequest.tolerance)
  return tolerance_;
}
inline ::choreo::Float32* GetPlanRequest::release_tolerance() {
  // @@protoc_insertion_point(field_release:choreo.GetPlanRequest.tolerance)
  
  ::choreo::Float32* temp = tolerance_;
  tolerance_ = NULL;
  return temp;
}
inline void GetPlanRequest::set_allocated_tolerance(::choreo::Float32* tolerance) {
  delete tolerance_;
  tolerance_ = tolerance;
  if (tolerance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.GetPlanRequest.tolerance)
}

// -------------------------------------------------------------------

// SetMapRequest

// .choreo.OccupancyGrid map = 1;
inline bool SetMapRequest::has_map() const {
  return this != internal_default_instance() && map_ != NULL;
}
inline void SetMapRequest::clear_map() {
  if (GetArenaNoVirtual() == NULL && map_ != NULL) delete map_;
  map_ = NULL;
}
inline const ::choreo::OccupancyGrid& SetMapRequest::map() const {
  // @@protoc_insertion_point(field_get:choreo.SetMapRequest.map)
  return map_ != NULL ? *map_
                         : *::choreo::OccupancyGrid::internal_default_instance();
}
inline ::choreo::OccupancyGrid* SetMapRequest::mutable_map() {
  
  if (map_ == NULL) {
    map_ = new ::choreo::OccupancyGrid;
  }
  // @@protoc_insertion_point(field_mutable:choreo.SetMapRequest.map)
  return map_;
}
inline ::choreo::OccupancyGrid* SetMapRequest::release_map() {
  // @@protoc_insertion_point(field_release:choreo.SetMapRequest.map)
  
  ::choreo::OccupancyGrid* temp = map_;
  map_ = NULL;
  return temp;
}
inline void SetMapRequest::set_allocated_map(::choreo::OccupancyGrid* map) {
  delete map_;
  map_ = map;
  if (map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.SetMapRequest.map)
}

// .choreo.PoseWithCovarianceStamped initial_pose = 2;
inline bool SetMapRequest::has_initial_pose() const {
  return this != internal_default_instance() && initial_pose_ != NULL;
}
inline void SetMapRequest::clear_initial_pose() {
  if (GetArenaNoVirtual() == NULL && initial_pose_ != NULL) delete initial_pose_;
  initial_pose_ = NULL;
}
inline const ::choreo::PoseWithCovarianceStamped& SetMapRequest::initial_pose() const {
  // @@protoc_insertion_point(field_get:choreo.SetMapRequest.initial_pose)
  return initial_pose_ != NULL ? *initial_pose_
                         : *::choreo::PoseWithCovarianceStamped::internal_default_instance();
}
inline ::choreo::PoseWithCovarianceStamped* SetMapRequest::mutable_initial_pose() {
  
  if (initial_pose_ == NULL) {
    initial_pose_ = new ::choreo::PoseWithCovarianceStamped;
  }
  // @@protoc_insertion_point(field_mutable:choreo.SetMapRequest.initial_pose)
  return initial_pose_;
}
inline ::choreo::PoseWithCovarianceStamped* SetMapRequest::release_initial_pose() {
  // @@protoc_insertion_point(field_release:choreo.SetMapRequest.initial_pose)
  
  ::choreo::PoseWithCovarianceStamped* temp = initial_pose_;
  initial_pose_ = NULL;
  return temp;
}
inline void SetMapRequest::set_allocated_initial_pose(::choreo::PoseWithCovarianceStamped* initial_pose) {
  delete initial_pose_;
  initial_pose_ = initial_pose;
  if (initial_pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.SetMapRequest.initial_pose)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace choreo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_nav_2eproto__INCLUDED
