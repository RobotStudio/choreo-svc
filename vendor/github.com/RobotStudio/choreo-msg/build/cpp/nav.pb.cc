// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nav.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "nav.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace choreo {
class GridCellsDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<GridCells> {
} _GridCells_default_instance_;
class MapMetaDataDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<MapMetaData> {
} _MapMetaData_default_instance_;
class OccupancyGridDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<OccupancyGrid> {
} _OccupancyGrid_default_instance_;
class OdometryDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Odometry> {
} _Odometry_default_instance_;
class PathDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Path> {
} _Path_default_instance_;
class GetPlanRequestDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<GetPlanRequest> {
} _GetPlanRequest_default_instance_;
class SetMapRequestDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SetMapRequest> {
} _SetMapRequest_default_instance_;

namespace protobuf_nav_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[7];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GridCells, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GridCells, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GridCells, cell_width_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GridCells, cell_height_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GridCells, cells_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapMetaData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapMetaData, map_load_time_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapMetaData, resolution_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapMetaData, width_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapMetaData, height_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapMetaData, origin_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OccupancyGrid, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OccupancyGrid, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OccupancyGrid, info_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OccupancyGrid, data_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Odometry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Odometry, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Odometry, child_frame_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Odometry, pose_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Odometry, twist_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Path, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Path, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Path, poses_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPlanRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPlanRequest, start_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPlanRequest, goal_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPlanRequest, tolerance_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetMapRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetMapRequest, map_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetMapRequest, initial_pose_),
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, -1, sizeof(GridCells)},
  { 9, -1, sizeof(MapMetaData)},
  { 19, -1, sizeof(OccupancyGrid)},
  { 27, -1, sizeof(Odometry)},
  { 36, -1, sizeof(Path)},
  { 43, -1, sizeof(GetPlanRequest)},
  { 51, -1, sizeof(SetMapRequest)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_GridCells_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_MapMetaData_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_OccupancyGrid_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Odometry_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Path_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_GetPlanRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_SetMapRequest_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "nav.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, NULL, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 7);
}

}  // namespace

void TableStruct::Shutdown() {
  _GridCells_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _MapMetaData_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _OccupancyGrid_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _Odometry_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _Path_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _GetPlanRequest_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
  _SetMapRequest_default_instance_.Shutdown();
  delete file_level_metadata[6].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::google::protobuf::protobuf_google_2fprotobuf_2ftimestamp_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2fbytes_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2ffloat_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2fheader_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2fint_2eproto::InitDefaults();
  ::choreo::protobuf_primitive_2fstring_2eproto::InitDefaults();
  ::choreo::protobuf_geometric_2fpoint_2eproto::InitDefaults();
  ::choreo::protobuf_geometric_2fpose_2eproto::InitDefaults();
  ::choreo::protobuf_geometric_2ftwist_2eproto::InitDefaults();
  _GridCells_default_instance_.DefaultConstruct();
  _MapMetaData_default_instance_.DefaultConstruct();
  _OccupancyGrid_default_instance_.DefaultConstruct();
  _Odometry_default_instance_.DefaultConstruct();
  _Path_default_instance_.DefaultConstruct();
  _GetPlanRequest_default_instance_.DefaultConstruct();
  _SetMapRequest_default_instance_.DefaultConstruct();
  _GridCells_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _GridCells_default_instance_.get_mutable()->cell_width_ = const_cast< ::choreo::Float64*>(
      ::choreo::Float64::internal_default_instance());
  _GridCells_default_instance_.get_mutable()->cell_height_ = const_cast< ::choreo::Float64*>(
      ::choreo::Float64::internal_default_instance());
  _MapMetaData_default_instance_.get_mutable()->map_load_time_ = const_cast< ::google::protobuf::Timestamp*>(
      ::google::protobuf::Timestamp::internal_default_instance());
  _MapMetaData_default_instance_.get_mutable()->resolution_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _MapMetaData_default_instance_.get_mutable()->width_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _MapMetaData_default_instance_.get_mutable()->height_ = const_cast< ::choreo::UInt32*>(
      ::choreo::UInt32::internal_default_instance());
  _MapMetaData_default_instance_.get_mutable()->origin_ = const_cast< ::choreo::Pose*>(
      ::choreo::Pose::internal_default_instance());
  _OccupancyGrid_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _OccupancyGrid_default_instance_.get_mutable()->info_ = const_cast< ::choreo::MapMetaData*>(
      ::choreo::MapMetaData::internal_default_instance());
  _OccupancyGrid_default_instance_.get_mutable()->data_ = const_cast< ::choreo::Bytes*>(
      ::choreo::Bytes::internal_default_instance());
  _Odometry_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _Odometry_default_instance_.get_mutable()->child_frame_id_ = const_cast< ::choreo::String*>(
      ::choreo::String::internal_default_instance());
  _Odometry_default_instance_.get_mutable()->pose_ = const_cast< ::choreo::PoseWithCovariance*>(
      ::choreo::PoseWithCovariance::internal_default_instance());
  _Odometry_default_instance_.get_mutable()->twist_ = const_cast< ::choreo::TwistWithCovariance*>(
      ::choreo::TwistWithCovariance::internal_default_instance());
  _Path_default_instance_.get_mutable()->header_ = const_cast< ::choreo::Header*>(
      ::choreo::Header::internal_default_instance());
  _GetPlanRequest_default_instance_.get_mutable()->start_ = const_cast< ::choreo::PoseStamped*>(
      ::choreo::PoseStamped::internal_default_instance());
  _GetPlanRequest_default_instance_.get_mutable()->goal_ = const_cast< ::choreo::PoseStamped*>(
      ::choreo::PoseStamped::internal_default_instance());
  _GetPlanRequest_default_instance_.get_mutable()->tolerance_ = const_cast< ::choreo::Float32*>(
      ::choreo::Float32::internal_default_instance());
  _SetMapRequest_default_instance_.get_mutable()->map_ = const_cast< ::choreo::OccupancyGrid*>(
      ::choreo::OccupancyGrid::internal_default_instance());
  _SetMapRequest_default_instance_.get_mutable()->initial_pose_ = const_cast< ::choreo::PoseWithCovarianceStamped*>(
      ::choreo::PoseWithCovarianceStamped::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\tnav.proto\022\006choreo\032\037google/protobuf/tim"
      "estamp.proto\032\025primitive/bytes.proto\032\025pri"
      "mitive/float.proto\032\026primitive/header.pro"
      "to\032\023primitive/int.proto\032\026primitive/strin"
      "g.proto\032\025geometric/point.proto\032\024geometri"
      "c/pose.proto\032\025geometric/twist.proto\"\224\001\n\t"
      "GridCells\022\036\n\006header\030\001 \001(\0132\016.choreo.Heade"
      "r\022#\n\ncell_width\030\002 \001(\0132\017.choreo.Float64\022$"
      "\n\013cell_height\030\003 \001(\0132\017.choreo.Float64\022\034\n\005"
      "cells\030\004 \003(\0132\r.choreo.Point\"\302\001\n\013MapMetaDa"
      "ta\0221\n\rmap_load_time\030\001 \001(\0132\032.google.proto"
      "buf.Timestamp\022#\n\nresolution\030\002 \001(\0132\017.chor"
      "eo.Float32\022\035\n\005width\030\003 \001(\0132\016.choreo.UInt3"
      "2\022\036\n\006height\030\004 \001(\0132\016.choreo.UInt32\022\034\n\006ori"
      "gin\030\005 \001(\0132\014.choreo.Pose\"o\n\rOccupancyGrid"
      "\022\036\n\006header\030\001 \001(\0132\016.choreo.Header\022!\n\004info"
      "\030\002 \001(\0132\023.choreo.MapMetaData\022\033\n\004data\030\003 \001("
      "\0132\r.choreo.Bytes\"\250\001\n\010Odometry\022\036\n\006header\030"
      "\001 \001(\0132\016.choreo.Header\022&\n\016child_frame_id\030"
      "\002 \001(\0132\016.choreo.String\022(\n\004pose\030\003 \001(\0132\032.ch"
      "oreo.PoseWithCovariance\022*\n\005twist\030\004 \001(\0132\033"
      ".choreo.TwistWithCovariance\"C\n\004Path\022\036\n\006h"
      "eader\030\001 \001(\0132\016.choreo.Header\022\033\n\005poses\030\002 \003"
      "(\0132\014.choreo.Pose\"{\n\016GetPlanRequest\022\"\n\005st"
      "art\030\001 \001(\0132\023.choreo.PoseStamped\022!\n\004goal\030\002"
      " \001(\0132\023.choreo.PoseStamped\022\"\n\ttolerance\030\003"
      " \001(\0132\017.choreo.Float32\"l\n\rSetMapRequest\022\""
      "\n\003map\030\001 \001(\0132\025.choreo.OccupancyGrid\0227\n\014in"
      "itial_pose\030\002 \001(\0132!.choreo.PoseWithCovari"
      "anceStampedB+Z)github.com/RobotStudio/ch"
      "oreo-msg/msg;msgb\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 1224);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "nav.proto", &protobuf_RegisterTypes);
  ::google::protobuf::protobuf_google_2fprotobuf_2ftimestamp_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2fbytes_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2ffloat_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2fheader_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2fint_2eproto::AddDescriptors();
  ::choreo::protobuf_primitive_2fstring_2eproto::AddDescriptors();
  ::choreo::protobuf_geometric_2fpoint_2eproto::AddDescriptors();
  ::choreo::protobuf_geometric_2fpose_2eproto::AddDescriptors();
  ::choreo::protobuf_geometric_2ftwist_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_nav_2eproto


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GridCells::kHeaderFieldNumber;
const int GridCells::kCellWidthFieldNumber;
const int GridCells::kCellHeightFieldNumber;
const int GridCells::kCellsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GridCells::GridCells()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_nav_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.GridCells)
}
GridCells::GridCells(const GridCells& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      cells_(from.cells_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_cell_width()) {
    cell_width_ = new ::choreo::Float64(*from.cell_width_);
  } else {
    cell_width_ = NULL;
  }
  if (from.has_cell_height()) {
    cell_height_ = new ::choreo::Float64(*from.cell_height_);
  } else {
    cell_height_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.GridCells)
}

void GridCells::SharedCtor() {
  ::memset(&header_, 0, reinterpret_cast<char*>(&cell_height_) -
    reinterpret_cast<char*>(&header_) + sizeof(cell_height_));
  _cached_size_ = 0;
}

GridCells::~GridCells() {
  // @@protoc_insertion_point(destructor:choreo.GridCells)
  SharedDtor();
}

void GridCells::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete cell_width_;
  }
  if (this != internal_default_instance()) {
    delete cell_height_;
  }
}

void GridCells::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GridCells::descriptor() {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GridCells& GridCells::default_instance() {
  protobuf_nav_2eproto::InitDefaults();
  return *internal_default_instance();
}

GridCells* GridCells::New(::google::protobuf::Arena* arena) const {
  GridCells* n = new GridCells;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GridCells::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.GridCells)
  cells_.Clear();
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && cell_width_ != NULL) {
    delete cell_width_;
  }
  cell_width_ = NULL;
  if (GetArenaNoVirtual() == NULL && cell_height_ != NULL) {
    delete cell_height_;
  }
  cell_height_ = NULL;
}

bool GridCells::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.GridCells)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float64 cell_width = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cell_width()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float64 cell_height = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cell_height()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.Point cells = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_cells()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.GridCells)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.GridCells)
  return false;
#undef DO_
}

void GridCells::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.GridCells)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .choreo.Float64 cell_width = 2;
  if (this->has_cell_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->cell_width_, output);
  }

  // .choreo.Float64 cell_height = 3;
  if (this->has_cell_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->cell_height_, output);
  }

  // repeated .choreo.Point cells = 4;
  for (unsigned int i = 0, n = this->cells_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->cells(i), output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.GridCells)
}

::google::protobuf::uint8* GridCells::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.GridCells)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // .choreo.Float64 cell_width = 2;
  if (this->has_cell_width()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->cell_width_, deterministic, target);
  }

  // .choreo.Float64 cell_height = 3;
  if (this->has_cell_height()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->cell_height_, deterministic, target);
  }

  // repeated .choreo.Point cells = 4;
  for (unsigned int i = 0, n = this->cells_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, this->cells(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.GridCells)
  return target;
}

size_t GridCells::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.GridCells)
  size_t total_size = 0;

  // repeated .choreo.Point cells = 4;
  {
    unsigned int count = this->cells_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cells(i));
    }
  }

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // .choreo.Float64 cell_width = 2;
  if (this->has_cell_width()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->cell_width_);
  }

  // .choreo.Float64 cell_height = 3;
  if (this->has_cell_height()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->cell_height_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GridCells::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.GridCells)
  GOOGLE_DCHECK_NE(&from, this);
  const GridCells* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GridCells>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.GridCells)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.GridCells)
    MergeFrom(*source);
  }
}

void GridCells::MergeFrom(const GridCells& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.GridCells)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cells_.MergeFrom(from.cells_);
  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
  if (from.has_cell_width()) {
    mutable_cell_width()->::choreo::Float64::MergeFrom(from.cell_width());
  }
  if (from.has_cell_height()) {
    mutable_cell_height()->::choreo::Float64::MergeFrom(from.cell_height());
  }
}

void GridCells::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.GridCells)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GridCells::CopyFrom(const GridCells& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.GridCells)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GridCells::IsInitialized() const {
  return true;
}

void GridCells::Swap(GridCells* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GridCells::InternalSwap(GridCells* other) {
  cells_.InternalSwap(&other->cells_);
  std::swap(header_, other->header_);
  std::swap(cell_width_, other->cell_width_);
  std::swap(cell_height_, other->cell_height_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GridCells::GetMetadata() const {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GridCells

// .choreo.Header header = 1;
bool GridCells::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void GridCells::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& GridCells::header() const {
  // @@protoc_insertion_point(field_get:choreo.GridCells.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* GridCells::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.GridCells.header)
  return header_;
}
::choreo::Header* GridCells::release_header() {
  // @@protoc_insertion_point(field_release:choreo.GridCells.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void GridCells::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.GridCells.header)
}

// .choreo.Float64 cell_width = 2;
bool GridCells::has_cell_width() const {
  return this != internal_default_instance() && cell_width_ != NULL;
}
void GridCells::clear_cell_width() {
  if (GetArenaNoVirtual() == NULL && cell_width_ != NULL) delete cell_width_;
  cell_width_ = NULL;
}
const ::choreo::Float64& GridCells::cell_width() const {
  // @@protoc_insertion_point(field_get:choreo.GridCells.cell_width)
  return cell_width_ != NULL ? *cell_width_
                         : *::choreo::Float64::internal_default_instance();
}
::choreo::Float64* GridCells::mutable_cell_width() {
  
  if (cell_width_ == NULL) {
    cell_width_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.GridCells.cell_width)
  return cell_width_;
}
::choreo::Float64* GridCells::release_cell_width() {
  // @@protoc_insertion_point(field_release:choreo.GridCells.cell_width)
  
  ::choreo::Float64* temp = cell_width_;
  cell_width_ = NULL;
  return temp;
}
void GridCells::set_allocated_cell_width(::choreo::Float64* cell_width) {
  delete cell_width_;
  cell_width_ = cell_width;
  if (cell_width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.GridCells.cell_width)
}

// .choreo.Float64 cell_height = 3;
bool GridCells::has_cell_height() const {
  return this != internal_default_instance() && cell_height_ != NULL;
}
void GridCells::clear_cell_height() {
  if (GetArenaNoVirtual() == NULL && cell_height_ != NULL) delete cell_height_;
  cell_height_ = NULL;
}
const ::choreo::Float64& GridCells::cell_height() const {
  // @@protoc_insertion_point(field_get:choreo.GridCells.cell_height)
  return cell_height_ != NULL ? *cell_height_
                         : *::choreo::Float64::internal_default_instance();
}
::choreo::Float64* GridCells::mutable_cell_height() {
  
  if (cell_height_ == NULL) {
    cell_height_ = new ::choreo::Float64;
  }
  // @@protoc_insertion_point(field_mutable:choreo.GridCells.cell_height)
  return cell_height_;
}
::choreo::Float64* GridCells::release_cell_height() {
  // @@protoc_insertion_point(field_release:choreo.GridCells.cell_height)
  
  ::choreo::Float64* temp = cell_height_;
  cell_height_ = NULL;
  return temp;
}
void GridCells::set_allocated_cell_height(::choreo::Float64* cell_height) {
  delete cell_height_;
  cell_height_ = cell_height;
  if (cell_height) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.GridCells.cell_height)
}

// repeated .choreo.Point cells = 4;
int GridCells::cells_size() const {
  return cells_.size();
}
void GridCells::clear_cells() {
  cells_.Clear();
}
const ::choreo::Point& GridCells::cells(int index) const {
  // @@protoc_insertion_point(field_get:choreo.GridCells.cells)
  return cells_.Get(index);
}
::choreo::Point* GridCells::mutable_cells(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.GridCells.cells)
  return cells_.Mutable(index);
}
::choreo::Point* GridCells::add_cells() {
  // @@protoc_insertion_point(field_add:choreo.GridCells.cells)
  return cells_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::Point >*
GridCells::mutable_cells() {
  // @@protoc_insertion_point(field_mutable_list:choreo.GridCells.cells)
  return &cells_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::Point >&
GridCells::cells() const {
  // @@protoc_insertion_point(field_list:choreo.GridCells.cells)
  return cells_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MapMetaData::kMapLoadTimeFieldNumber;
const int MapMetaData::kResolutionFieldNumber;
const int MapMetaData::kWidthFieldNumber;
const int MapMetaData::kHeightFieldNumber;
const int MapMetaData::kOriginFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MapMetaData::MapMetaData()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_nav_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.MapMetaData)
}
MapMetaData::MapMetaData(const MapMetaData& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_map_load_time()) {
    map_load_time_ = new ::google::protobuf::Timestamp(*from.map_load_time_);
  } else {
    map_load_time_ = NULL;
  }
  if (from.has_resolution()) {
    resolution_ = new ::choreo::Float32(*from.resolution_);
  } else {
    resolution_ = NULL;
  }
  if (from.has_width()) {
    width_ = new ::choreo::UInt32(*from.width_);
  } else {
    width_ = NULL;
  }
  if (from.has_height()) {
    height_ = new ::choreo::UInt32(*from.height_);
  } else {
    height_ = NULL;
  }
  if (from.has_origin()) {
    origin_ = new ::choreo::Pose(*from.origin_);
  } else {
    origin_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.MapMetaData)
}

void MapMetaData::SharedCtor() {
  ::memset(&map_load_time_, 0, reinterpret_cast<char*>(&origin_) -
    reinterpret_cast<char*>(&map_load_time_) + sizeof(origin_));
  _cached_size_ = 0;
}

MapMetaData::~MapMetaData() {
  // @@protoc_insertion_point(destructor:choreo.MapMetaData)
  SharedDtor();
}

void MapMetaData::SharedDtor() {
  if (this != internal_default_instance()) {
    delete map_load_time_;
  }
  if (this != internal_default_instance()) {
    delete resolution_;
  }
  if (this != internal_default_instance()) {
    delete width_;
  }
  if (this != internal_default_instance()) {
    delete height_;
  }
  if (this != internal_default_instance()) {
    delete origin_;
  }
}

void MapMetaData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapMetaData::descriptor() {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const MapMetaData& MapMetaData::default_instance() {
  protobuf_nav_2eproto::InitDefaults();
  return *internal_default_instance();
}

MapMetaData* MapMetaData::New(::google::protobuf::Arena* arena) const {
  MapMetaData* n = new MapMetaData;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MapMetaData::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.MapMetaData)
  if (GetArenaNoVirtual() == NULL && map_load_time_ != NULL) {
    delete map_load_time_;
  }
  map_load_time_ = NULL;
  if (GetArenaNoVirtual() == NULL && resolution_ != NULL) {
    delete resolution_;
  }
  resolution_ = NULL;
  if (GetArenaNoVirtual() == NULL && width_ != NULL) {
    delete width_;
  }
  width_ = NULL;
  if (GetArenaNoVirtual() == NULL && height_ != NULL) {
    delete height_;
  }
  height_ = NULL;
  if (GetArenaNoVirtual() == NULL && origin_ != NULL) {
    delete origin_;
  }
  origin_ = NULL;
}

bool MapMetaData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.MapMetaData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .google.protobuf.Timestamp map_load_time = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_map_load_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 resolution = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resolution()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 width = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_width()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.UInt32 height = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_height()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Pose origin = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.MapMetaData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.MapMetaData)
  return false;
#undef DO_
}

void MapMetaData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.MapMetaData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.Timestamp map_load_time = 1;
  if (this->has_map_load_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->map_load_time_, output);
  }

  // .choreo.Float32 resolution = 2;
  if (this->has_resolution()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->resolution_, output);
  }

  // .choreo.UInt32 width = 3;
  if (this->has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->width_, output);
  }

  // .choreo.UInt32 height = 4;
  if (this->has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->height_, output);
  }

  // .choreo.Pose origin = 5;
  if (this->has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->origin_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.MapMetaData)
}

::google::protobuf::uint8* MapMetaData::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.MapMetaData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.Timestamp map_load_time = 1;
  if (this->has_map_load_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->map_load_time_, deterministic, target);
  }

  // .choreo.Float32 resolution = 2;
  if (this->has_resolution()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->resolution_, deterministic, target);
  }

  // .choreo.UInt32 width = 3;
  if (this->has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->width_, deterministic, target);
  }

  // .choreo.UInt32 height = 4;
  if (this->has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->height_, deterministic, target);
  }

  // .choreo.Pose origin = 5;
  if (this->has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->origin_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.MapMetaData)
  return target;
}

size_t MapMetaData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.MapMetaData)
  size_t total_size = 0;

  // .google.protobuf.Timestamp map_load_time = 1;
  if (this->has_map_load_time()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->map_load_time_);
  }

  // .choreo.Float32 resolution = 2;
  if (this->has_resolution()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->resolution_);
  }

  // .choreo.UInt32 width = 3;
  if (this->has_width()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->width_);
  }

  // .choreo.UInt32 height = 4;
  if (this->has_height()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->height_);
  }

  // .choreo.Pose origin = 5;
  if (this->has_origin()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->origin_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapMetaData::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.MapMetaData)
  GOOGLE_DCHECK_NE(&from, this);
  const MapMetaData* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const MapMetaData>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.MapMetaData)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.MapMetaData)
    MergeFrom(*source);
  }
}

void MapMetaData::MergeFrom(const MapMetaData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.MapMetaData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_map_load_time()) {
    mutable_map_load_time()->::google::protobuf::Timestamp::MergeFrom(from.map_load_time());
  }
  if (from.has_resolution()) {
    mutable_resolution()->::choreo::Float32::MergeFrom(from.resolution());
  }
  if (from.has_width()) {
    mutable_width()->::choreo::UInt32::MergeFrom(from.width());
  }
  if (from.has_height()) {
    mutable_height()->::choreo::UInt32::MergeFrom(from.height());
  }
  if (from.has_origin()) {
    mutable_origin()->::choreo::Pose::MergeFrom(from.origin());
  }
}

void MapMetaData::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.MapMetaData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapMetaData::CopyFrom(const MapMetaData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.MapMetaData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapMetaData::IsInitialized() const {
  return true;
}

void MapMetaData::Swap(MapMetaData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MapMetaData::InternalSwap(MapMetaData* other) {
  std::swap(map_load_time_, other->map_load_time_);
  std::swap(resolution_, other->resolution_);
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  std::swap(origin_, other->origin_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MapMetaData::GetMetadata() const {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MapMetaData

// .google.protobuf.Timestamp map_load_time = 1;
bool MapMetaData::has_map_load_time() const {
  return this != internal_default_instance() && map_load_time_ != NULL;
}
void MapMetaData::clear_map_load_time() {
  if (GetArenaNoVirtual() == NULL && map_load_time_ != NULL) delete map_load_time_;
  map_load_time_ = NULL;
}
const ::google::protobuf::Timestamp& MapMetaData::map_load_time() const {
  // @@protoc_insertion_point(field_get:choreo.MapMetaData.map_load_time)
  return map_load_time_ != NULL ? *map_load_time_
                         : *::google::protobuf::Timestamp::internal_default_instance();
}
::google::protobuf::Timestamp* MapMetaData::mutable_map_load_time() {
  
  if (map_load_time_ == NULL) {
    map_load_time_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MapMetaData.map_load_time)
  return map_load_time_;
}
::google::protobuf::Timestamp* MapMetaData::release_map_load_time() {
  // @@protoc_insertion_point(field_release:choreo.MapMetaData.map_load_time)
  
  ::google::protobuf::Timestamp* temp = map_load_time_;
  map_load_time_ = NULL;
  return temp;
}
void MapMetaData::set_allocated_map_load_time(::google::protobuf::Timestamp* map_load_time) {
  delete map_load_time_;
  if (map_load_time != NULL && map_load_time->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_map_load_time = new ::google::protobuf::Timestamp;
    new_map_load_time->CopyFrom(*map_load_time);
    map_load_time = new_map_load_time;
  }
  map_load_time_ = map_load_time;
  if (map_load_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MapMetaData.map_load_time)
}

// .choreo.Float32 resolution = 2;
bool MapMetaData::has_resolution() const {
  return this != internal_default_instance() && resolution_ != NULL;
}
void MapMetaData::clear_resolution() {
  if (GetArenaNoVirtual() == NULL && resolution_ != NULL) delete resolution_;
  resolution_ = NULL;
}
const ::choreo::Float32& MapMetaData::resolution() const {
  // @@protoc_insertion_point(field_get:choreo.MapMetaData.resolution)
  return resolution_ != NULL ? *resolution_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* MapMetaData::mutable_resolution() {
  
  if (resolution_ == NULL) {
    resolution_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MapMetaData.resolution)
  return resolution_;
}
::choreo::Float32* MapMetaData::release_resolution() {
  // @@protoc_insertion_point(field_release:choreo.MapMetaData.resolution)
  
  ::choreo::Float32* temp = resolution_;
  resolution_ = NULL;
  return temp;
}
void MapMetaData::set_allocated_resolution(::choreo::Float32* resolution) {
  delete resolution_;
  resolution_ = resolution;
  if (resolution) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MapMetaData.resolution)
}

// .choreo.UInt32 width = 3;
bool MapMetaData::has_width() const {
  return this != internal_default_instance() && width_ != NULL;
}
void MapMetaData::clear_width() {
  if (GetArenaNoVirtual() == NULL && width_ != NULL) delete width_;
  width_ = NULL;
}
const ::choreo::UInt32& MapMetaData::width() const {
  // @@protoc_insertion_point(field_get:choreo.MapMetaData.width)
  return width_ != NULL ? *width_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* MapMetaData::mutable_width() {
  
  if (width_ == NULL) {
    width_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MapMetaData.width)
  return width_;
}
::choreo::UInt32* MapMetaData::release_width() {
  // @@protoc_insertion_point(field_release:choreo.MapMetaData.width)
  
  ::choreo::UInt32* temp = width_;
  width_ = NULL;
  return temp;
}
void MapMetaData::set_allocated_width(::choreo::UInt32* width) {
  delete width_;
  width_ = width;
  if (width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MapMetaData.width)
}

// .choreo.UInt32 height = 4;
bool MapMetaData::has_height() const {
  return this != internal_default_instance() && height_ != NULL;
}
void MapMetaData::clear_height() {
  if (GetArenaNoVirtual() == NULL && height_ != NULL) delete height_;
  height_ = NULL;
}
const ::choreo::UInt32& MapMetaData::height() const {
  // @@protoc_insertion_point(field_get:choreo.MapMetaData.height)
  return height_ != NULL ? *height_
                         : *::choreo::UInt32::internal_default_instance();
}
::choreo::UInt32* MapMetaData::mutable_height() {
  
  if (height_ == NULL) {
    height_ = new ::choreo::UInt32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MapMetaData.height)
  return height_;
}
::choreo::UInt32* MapMetaData::release_height() {
  // @@protoc_insertion_point(field_release:choreo.MapMetaData.height)
  
  ::choreo::UInt32* temp = height_;
  height_ = NULL;
  return temp;
}
void MapMetaData::set_allocated_height(::choreo::UInt32* height) {
  delete height_;
  height_ = height;
  if (height) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MapMetaData.height)
}

// .choreo.Pose origin = 5;
bool MapMetaData::has_origin() const {
  return this != internal_default_instance() && origin_ != NULL;
}
void MapMetaData::clear_origin() {
  if (GetArenaNoVirtual() == NULL && origin_ != NULL) delete origin_;
  origin_ = NULL;
}
const ::choreo::Pose& MapMetaData::origin() const {
  // @@protoc_insertion_point(field_get:choreo.MapMetaData.origin)
  return origin_ != NULL ? *origin_
                         : *::choreo::Pose::internal_default_instance();
}
::choreo::Pose* MapMetaData::mutable_origin() {
  
  if (origin_ == NULL) {
    origin_ = new ::choreo::Pose;
  }
  // @@protoc_insertion_point(field_mutable:choreo.MapMetaData.origin)
  return origin_;
}
::choreo::Pose* MapMetaData::release_origin() {
  // @@protoc_insertion_point(field_release:choreo.MapMetaData.origin)
  
  ::choreo::Pose* temp = origin_;
  origin_ = NULL;
  return temp;
}
void MapMetaData::set_allocated_origin(::choreo::Pose* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.MapMetaData.origin)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OccupancyGrid::kHeaderFieldNumber;
const int OccupancyGrid::kInfoFieldNumber;
const int OccupancyGrid::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OccupancyGrid::OccupancyGrid()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_nav_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.OccupancyGrid)
}
OccupancyGrid::OccupancyGrid(const OccupancyGrid& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_info()) {
    info_ = new ::choreo::MapMetaData(*from.info_);
  } else {
    info_ = NULL;
  }
  if (from.has_data()) {
    data_ = new ::choreo::Bytes(*from.data_);
  } else {
    data_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.OccupancyGrid)
}

void OccupancyGrid::SharedCtor() {
  ::memset(&header_, 0, reinterpret_cast<char*>(&data_) -
    reinterpret_cast<char*>(&header_) + sizeof(data_));
  _cached_size_ = 0;
}

OccupancyGrid::~OccupancyGrid() {
  // @@protoc_insertion_point(destructor:choreo.OccupancyGrid)
  SharedDtor();
}

void OccupancyGrid::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete info_;
  }
  if (this != internal_default_instance()) {
    delete data_;
  }
}

void OccupancyGrid::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OccupancyGrid::descriptor() {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const OccupancyGrid& OccupancyGrid::default_instance() {
  protobuf_nav_2eproto::InitDefaults();
  return *internal_default_instance();
}

OccupancyGrid* OccupancyGrid::New(::google::protobuf::Arena* arena) const {
  OccupancyGrid* n = new OccupancyGrid;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OccupancyGrid::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.OccupancyGrid)
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && info_ != NULL) {
    delete info_;
  }
  info_ = NULL;
  if (GetArenaNoVirtual() == NULL && data_ != NULL) {
    delete data_;
  }
  data_ = NULL;
}

bool OccupancyGrid::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.OccupancyGrid)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.MapMetaData info = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Bytes data = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.OccupancyGrid)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.OccupancyGrid)
  return false;
#undef DO_
}

void OccupancyGrid::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.OccupancyGrid)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .choreo.MapMetaData info = 2;
  if (this->has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->info_, output);
  }

  // .choreo.Bytes data = 3;
  if (this->has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->data_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.OccupancyGrid)
}

::google::protobuf::uint8* OccupancyGrid::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.OccupancyGrid)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // .choreo.MapMetaData info = 2;
  if (this->has_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->info_, deterministic, target);
  }

  // .choreo.Bytes data = 3;
  if (this->has_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->data_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.OccupancyGrid)
  return target;
}

size_t OccupancyGrid::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.OccupancyGrid)
  size_t total_size = 0;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // .choreo.MapMetaData info = 2;
  if (this->has_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->info_);
  }

  // .choreo.Bytes data = 3;
  if (this->has_data()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->data_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OccupancyGrid::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.OccupancyGrid)
  GOOGLE_DCHECK_NE(&from, this);
  const OccupancyGrid* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const OccupancyGrid>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.OccupancyGrid)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.OccupancyGrid)
    MergeFrom(*source);
  }
}

void OccupancyGrid::MergeFrom(const OccupancyGrid& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.OccupancyGrid)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
  if (from.has_info()) {
    mutable_info()->::choreo::MapMetaData::MergeFrom(from.info());
  }
  if (from.has_data()) {
    mutable_data()->::choreo::Bytes::MergeFrom(from.data());
  }
}

void OccupancyGrid::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.OccupancyGrid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OccupancyGrid::CopyFrom(const OccupancyGrid& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.OccupancyGrid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OccupancyGrid::IsInitialized() const {
  return true;
}

void OccupancyGrid::Swap(OccupancyGrid* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OccupancyGrid::InternalSwap(OccupancyGrid* other) {
  std::swap(header_, other->header_);
  std::swap(info_, other->info_);
  std::swap(data_, other->data_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata OccupancyGrid::GetMetadata() const {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OccupancyGrid

// .choreo.Header header = 1;
bool OccupancyGrid::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void OccupancyGrid::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& OccupancyGrid::header() const {
  // @@protoc_insertion_point(field_get:choreo.OccupancyGrid.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* OccupancyGrid::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.OccupancyGrid.header)
  return header_;
}
::choreo::Header* OccupancyGrid::release_header() {
  // @@protoc_insertion_point(field_release:choreo.OccupancyGrid.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void OccupancyGrid::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.OccupancyGrid.header)
}

// .choreo.MapMetaData info = 2;
bool OccupancyGrid::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
void OccupancyGrid::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) delete info_;
  info_ = NULL;
}
const ::choreo::MapMetaData& OccupancyGrid::info() const {
  // @@protoc_insertion_point(field_get:choreo.OccupancyGrid.info)
  return info_ != NULL ? *info_
                         : *::choreo::MapMetaData::internal_default_instance();
}
::choreo::MapMetaData* OccupancyGrid::mutable_info() {
  
  if (info_ == NULL) {
    info_ = new ::choreo::MapMetaData;
  }
  // @@protoc_insertion_point(field_mutable:choreo.OccupancyGrid.info)
  return info_;
}
::choreo::MapMetaData* OccupancyGrid::release_info() {
  // @@protoc_insertion_point(field_release:choreo.OccupancyGrid.info)
  
  ::choreo::MapMetaData* temp = info_;
  info_ = NULL;
  return temp;
}
void OccupancyGrid::set_allocated_info(::choreo::MapMetaData* info) {
  delete info_;
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.OccupancyGrid.info)
}

// .choreo.Bytes data = 3;
bool OccupancyGrid::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
void OccupancyGrid::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
const ::choreo::Bytes& OccupancyGrid::data() const {
  // @@protoc_insertion_point(field_get:choreo.OccupancyGrid.data)
  return data_ != NULL ? *data_
                         : *::choreo::Bytes::internal_default_instance();
}
::choreo::Bytes* OccupancyGrid::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::choreo::Bytes;
  }
  // @@protoc_insertion_point(field_mutable:choreo.OccupancyGrid.data)
  return data_;
}
::choreo::Bytes* OccupancyGrid::release_data() {
  // @@protoc_insertion_point(field_release:choreo.OccupancyGrid.data)
  
  ::choreo::Bytes* temp = data_;
  data_ = NULL;
  return temp;
}
void OccupancyGrid::set_allocated_data(::choreo::Bytes* data) {
  delete data_;
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.OccupancyGrid.data)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Odometry::kHeaderFieldNumber;
const int Odometry::kChildFrameIdFieldNumber;
const int Odometry::kPoseFieldNumber;
const int Odometry::kTwistFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Odometry::Odometry()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_nav_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.Odometry)
}
Odometry::Odometry(const Odometry& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_child_frame_id()) {
    child_frame_id_ = new ::choreo::String(*from.child_frame_id_);
  } else {
    child_frame_id_ = NULL;
  }
  if (from.has_pose()) {
    pose_ = new ::choreo::PoseWithCovariance(*from.pose_);
  } else {
    pose_ = NULL;
  }
  if (from.has_twist()) {
    twist_ = new ::choreo::TwistWithCovariance(*from.twist_);
  } else {
    twist_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.Odometry)
}

void Odometry::SharedCtor() {
  ::memset(&header_, 0, reinterpret_cast<char*>(&twist_) -
    reinterpret_cast<char*>(&header_) + sizeof(twist_));
  _cached_size_ = 0;
}

Odometry::~Odometry() {
  // @@protoc_insertion_point(destructor:choreo.Odometry)
  SharedDtor();
}

void Odometry::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete child_frame_id_;
  }
  if (this != internal_default_instance()) {
    delete pose_;
  }
  if (this != internal_default_instance()) {
    delete twist_;
  }
}

void Odometry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Odometry::descriptor() {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Odometry& Odometry::default_instance() {
  protobuf_nav_2eproto::InitDefaults();
  return *internal_default_instance();
}

Odometry* Odometry::New(::google::protobuf::Arena* arena) const {
  Odometry* n = new Odometry;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Odometry::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.Odometry)
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && child_frame_id_ != NULL) {
    delete child_frame_id_;
  }
  child_frame_id_ = NULL;
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) {
    delete pose_;
  }
  pose_ = NULL;
  if (GetArenaNoVirtual() == NULL && twist_ != NULL) {
    delete twist_;
  }
  twist_ = NULL;
}

bool Odometry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.Odometry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.String child_frame_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_child_frame_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.PoseWithCovariance pose = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.TwistWithCovariance twist = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_twist()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.Odometry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.Odometry)
  return false;
#undef DO_
}

void Odometry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.Odometry)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .choreo.String child_frame_id = 2;
  if (this->has_child_frame_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->child_frame_id_, output);
  }

  // .choreo.PoseWithCovariance pose = 3;
  if (this->has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->pose_, output);
  }

  // .choreo.TwistWithCovariance twist = 4;
  if (this->has_twist()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->twist_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.Odometry)
}

::google::protobuf::uint8* Odometry::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.Odometry)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // .choreo.String child_frame_id = 2;
  if (this->has_child_frame_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->child_frame_id_, deterministic, target);
  }

  // .choreo.PoseWithCovariance pose = 3;
  if (this->has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->pose_, deterministic, target);
  }

  // .choreo.TwistWithCovariance twist = 4;
  if (this->has_twist()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->twist_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.Odometry)
  return target;
}

size_t Odometry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.Odometry)
  size_t total_size = 0;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // .choreo.String child_frame_id = 2;
  if (this->has_child_frame_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->child_frame_id_);
  }

  // .choreo.PoseWithCovariance pose = 3;
  if (this->has_pose()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pose_);
  }

  // .choreo.TwistWithCovariance twist = 4;
  if (this->has_twist()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->twist_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Odometry::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.Odometry)
  GOOGLE_DCHECK_NE(&from, this);
  const Odometry* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Odometry>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.Odometry)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.Odometry)
    MergeFrom(*source);
  }
}

void Odometry::MergeFrom(const Odometry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.Odometry)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
  if (from.has_child_frame_id()) {
    mutable_child_frame_id()->::choreo::String::MergeFrom(from.child_frame_id());
  }
  if (from.has_pose()) {
    mutable_pose()->::choreo::PoseWithCovariance::MergeFrom(from.pose());
  }
  if (from.has_twist()) {
    mutable_twist()->::choreo::TwistWithCovariance::MergeFrom(from.twist());
  }
}

void Odometry::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.Odometry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Odometry::CopyFrom(const Odometry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.Odometry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Odometry::IsInitialized() const {
  return true;
}

void Odometry::Swap(Odometry* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Odometry::InternalSwap(Odometry* other) {
  std::swap(header_, other->header_);
  std::swap(child_frame_id_, other->child_frame_id_);
  std::swap(pose_, other->pose_);
  std::swap(twist_, other->twist_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Odometry::GetMetadata() const {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Odometry

// .choreo.Header header = 1;
bool Odometry::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void Odometry::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& Odometry::header() const {
  // @@protoc_insertion_point(field_get:choreo.Odometry.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* Odometry::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Odometry.header)
  return header_;
}
::choreo::Header* Odometry::release_header() {
  // @@protoc_insertion_point(field_release:choreo.Odometry.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void Odometry::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Odometry.header)
}

// .choreo.String child_frame_id = 2;
bool Odometry::has_child_frame_id() const {
  return this != internal_default_instance() && child_frame_id_ != NULL;
}
void Odometry::clear_child_frame_id() {
  if (GetArenaNoVirtual() == NULL && child_frame_id_ != NULL) delete child_frame_id_;
  child_frame_id_ = NULL;
}
const ::choreo::String& Odometry::child_frame_id() const {
  // @@protoc_insertion_point(field_get:choreo.Odometry.child_frame_id)
  return child_frame_id_ != NULL ? *child_frame_id_
                         : *::choreo::String::internal_default_instance();
}
::choreo::String* Odometry::mutable_child_frame_id() {
  
  if (child_frame_id_ == NULL) {
    child_frame_id_ = new ::choreo::String;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Odometry.child_frame_id)
  return child_frame_id_;
}
::choreo::String* Odometry::release_child_frame_id() {
  // @@protoc_insertion_point(field_release:choreo.Odometry.child_frame_id)
  
  ::choreo::String* temp = child_frame_id_;
  child_frame_id_ = NULL;
  return temp;
}
void Odometry::set_allocated_child_frame_id(::choreo::String* child_frame_id) {
  delete child_frame_id_;
  child_frame_id_ = child_frame_id;
  if (child_frame_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Odometry.child_frame_id)
}

// .choreo.PoseWithCovariance pose = 3;
bool Odometry::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
void Odometry::clear_pose() {
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) delete pose_;
  pose_ = NULL;
}
const ::choreo::PoseWithCovariance& Odometry::pose() const {
  // @@protoc_insertion_point(field_get:choreo.Odometry.pose)
  return pose_ != NULL ? *pose_
                         : *::choreo::PoseWithCovariance::internal_default_instance();
}
::choreo::PoseWithCovariance* Odometry::mutable_pose() {
  
  if (pose_ == NULL) {
    pose_ = new ::choreo::PoseWithCovariance;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Odometry.pose)
  return pose_;
}
::choreo::PoseWithCovariance* Odometry::release_pose() {
  // @@protoc_insertion_point(field_release:choreo.Odometry.pose)
  
  ::choreo::PoseWithCovariance* temp = pose_;
  pose_ = NULL;
  return temp;
}
void Odometry::set_allocated_pose(::choreo::PoseWithCovariance* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Odometry.pose)
}

// .choreo.TwistWithCovariance twist = 4;
bool Odometry::has_twist() const {
  return this != internal_default_instance() && twist_ != NULL;
}
void Odometry::clear_twist() {
  if (GetArenaNoVirtual() == NULL && twist_ != NULL) delete twist_;
  twist_ = NULL;
}
const ::choreo::TwistWithCovariance& Odometry::twist() const {
  // @@protoc_insertion_point(field_get:choreo.Odometry.twist)
  return twist_ != NULL ? *twist_
                         : *::choreo::TwistWithCovariance::internal_default_instance();
}
::choreo::TwistWithCovariance* Odometry::mutable_twist() {
  
  if (twist_ == NULL) {
    twist_ = new ::choreo::TwistWithCovariance;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Odometry.twist)
  return twist_;
}
::choreo::TwistWithCovariance* Odometry::release_twist() {
  // @@protoc_insertion_point(field_release:choreo.Odometry.twist)
  
  ::choreo::TwistWithCovariance* temp = twist_;
  twist_ = NULL;
  return temp;
}
void Odometry::set_allocated_twist(::choreo::TwistWithCovariance* twist) {
  delete twist_;
  twist_ = twist;
  if (twist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Odometry.twist)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Path::kHeaderFieldNumber;
const int Path::kPosesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Path::Path()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_nav_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.Path)
}
Path::Path(const Path& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      poses_(from.poses_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::choreo::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.Path)
}

void Path::SharedCtor() {
  header_ = NULL;
  _cached_size_ = 0;
}

Path::~Path() {
  // @@protoc_insertion_point(destructor:choreo.Path)
  SharedDtor();
}

void Path::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
}

void Path::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Path::descriptor() {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Path& Path::default_instance() {
  protobuf_nav_2eproto::InitDefaults();
  return *internal_default_instance();
}

Path* Path::New(::google::protobuf::Arena* arena) const {
  Path* n = new Path;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Path::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.Path)
  poses_.Clear();
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}

bool Path::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.Path)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .choreo.Pose poses = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_poses()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.Path)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.Path)
  return false;
#undef DO_
}

void Path::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.Path)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .choreo.Pose poses = 2;
  for (unsigned int i = 0, n = this->poses_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->poses(i), output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.Path)
}

::google::protobuf::uint8* Path::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.Path)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.Header header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, deterministic, target);
  }

  // repeated .choreo.Pose poses = 2;
  for (unsigned int i = 0, n = this->poses_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->poses(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.Path)
  return target;
}

size_t Path::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.Path)
  size_t total_size = 0;

  // repeated .choreo.Pose poses = 2;
  {
    unsigned int count = this->poses_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->poses(i));
    }
  }

  // .choreo.Header header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Path::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.Path)
  GOOGLE_DCHECK_NE(&from, this);
  const Path* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Path>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.Path)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.Path)
    MergeFrom(*source);
  }
}

void Path::MergeFrom(const Path& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.Path)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  poses_.MergeFrom(from.poses_);
  if (from.has_header()) {
    mutable_header()->::choreo::Header::MergeFrom(from.header());
  }
}

void Path::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.Path)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Path::CopyFrom(const Path& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.Path)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Path::IsInitialized() const {
  return true;
}

void Path::Swap(Path* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Path::InternalSwap(Path* other) {
  poses_.InternalSwap(&other->poses_);
  std::swap(header_, other->header_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Path::GetMetadata() const {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Path

// .choreo.Header header = 1;
bool Path::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void Path::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::choreo::Header& Path::header() const {
  // @@protoc_insertion_point(field_get:choreo.Path.header)
  return header_ != NULL ? *header_
                         : *::choreo::Header::internal_default_instance();
}
::choreo::Header* Path::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::choreo::Header;
  }
  // @@protoc_insertion_point(field_mutable:choreo.Path.header)
  return header_;
}
::choreo::Header* Path::release_header() {
  // @@protoc_insertion_point(field_release:choreo.Path.header)
  
  ::choreo::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void Path::set_allocated_header(::choreo::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.Path.header)
}

// repeated .choreo.Pose poses = 2;
int Path::poses_size() const {
  return poses_.size();
}
void Path::clear_poses() {
  poses_.Clear();
}
const ::choreo::Pose& Path::poses(int index) const {
  // @@protoc_insertion_point(field_get:choreo.Path.poses)
  return poses_.Get(index);
}
::choreo::Pose* Path::mutable_poses(int index) {
  // @@protoc_insertion_point(field_mutable:choreo.Path.poses)
  return poses_.Mutable(index);
}
::choreo::Pose* Path::add_poses() {
  // @@protoc_insertion_point(field_add:choreo.Path.poses)
  return poses_.Add();
}
::google::protobuf::RepeatedPtrField< ::choreo::Pose >*
Path::mutable_poses() {
  // @@protoc_insertion_point(field_mutable_list:choreo.Path.poses)
  return &poses_;
}
const ::google::protobuf::RepeatedPtrField< ::choreo::Pose >&
Path::poses() const {
  // @@protoc_insertion_point(field_list:choreo.Path.poses)
  return poses_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetPlanRequest::kStartFieldNumber;
const int GetPlanRequest::kGoalFieldNumber;
const int GetPlanRequest::kToleranceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetPlanRequest::GetPlanRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_nav_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.GetPlanRequest)
}
GetPlanRequest::GetPlanRequest(const GetPlanRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_start()) {
    start_ = new ::choreo::PoseStamped(*from.start_);
  } else {
    start_ = NULL;
  }
  if (from.has_goal()) {
    goal_ = new ::choreo::PoseStamped(*from.goal_);
  } else {
    goal_ = NULL;
  }
  if (from.has_tolerance()) {
    tolerance_ = new ::choreo::Float32(*from.tolerance_);
  } else {
    tolerance_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.GetPlanRequest)
}

void GetPlanRequest::SharedCtor() {
  ::memset(&start_, 0, reinterpret_cast<char*>(&tolerance_) -
    reinterpret_cast<char*>(&start_) + sizeof(tolerance_));
  _cached_size_ = 0;
}

GetPlanRequest::~GetPlanRequest() {
  // @@protoc_insertion_point(destructor:choreo.GetPlanRequest)
  SharedDtor();
}

void GetPlanRequest::SharedDtor() {
  if (this != internal_default_instance()) {
    delete start_;
  }
  if (this != internal_default_instance()) {
    delete goal_;
  }
  if (this != internal_default_instance()) {
    delete tolerance_;
  }
}

void GetPlanRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetPlanRequest::descriptor() {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GetPlanRequest& GetPlanRequest::default_instance() {
  protobuf_nav_2eproto::InitDefaults();
  return *internal_default_instance();
}

GetPlanRequest* GetPlanRequest::New(::google::protobuf::Arena* arena) const {
  GetPlanRequest* n = new GetPlanRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetPlanRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.GetPlanRequest)
  if (GetArenaNoVirtual() == NULL && start_ != NULL) {
    delete start_;
  }
  start_ = NULL;
  if (GetArenaNoVirtual() == NULL && goal_ != NULL) {
    delete goal_;
  }
  goal_ = NULL;
  if (GetArenaNoVirtual() == NULL && tolerance_ != NULL) {
    delete tolerance_;
  }
  tolerance_ = NULL;
}

bool GetPlanRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.GetPlanRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.PoseStamped start = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_start()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.PoseStamped goal = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_goal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.Float32 tolerance = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tolerance()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.GetPlanRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.GetPlanRequest)
  return false;
#undef DO_
}

void GetPlanRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.GetPlanRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.PoseStamped start = 1;
  if (this->has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->start_, output);
  }

  // .choreo.PoseStamped goal = 2;
  if (this->has_goal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->goal_, output);
  }

  // .choreo.Float32 tolerance = 3;
  if (this->has_tolerance()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->tolerance_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.GetPlanRequest)
}

::google::protobuf::uint8* GetPlanRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.GetPlanRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.PoseStamped start = 1;
  if (this->has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->start_, deterministic, target);
  }

  // .choreo.PoseStamped goal = 2;
  if (this->has_goal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->goal_, deterministic, target);
  }

  // .choreo.Float32 tolerance = 3;
  if (this->has_tolerance()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->tolerance_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.GetPlanRequest)
  return target;
}

size_t GetPlanRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.GetPlanRequest)
  size_t total_size = 0;

  // .choreo.PoseStamped start = 1;
  if (this->has_start()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->start_);
  }

  // .choreo.PoseStamped goal = 2;
  if (this->has_goal()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->goal_);
  }

  // .choreo.Float32 tolerance = 3;
  if (this->has_tolerance()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->tolerance_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetPlanRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.GetPlanRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const GetPlanRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GetPlanRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.GetPlanRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.GetPlanRequest)
    MergeFrom(*source);
  }
}

void GetPlanRequest::MergeFrom(const GetPlanRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.GetPlanRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_start()) {
    mutable_start()->::choreo::PoseStamped::MergeFrom(from.start());
  }
  if (from.has_goal()) {
    mutable_goal()->::choreo::PoseStamped::MergeFrom(from.goal());
  }
  if (from.has_tolerance()) {
    mutable_tolerance()->::choreo::Float32::MergeFrom(from.tolerance());
  }
}

void GetPlanRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.GetPlanRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetPlanRequest::CopyFrom(const GetPlanRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.GetPlanRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPlanRequest::IsInitialized() const {
  return true;
}

void GetPlanRequest::Swap(GetPlanRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetPlanRequest::InternalSwap(GetPlanRequest* other) {
  std::swap(start_, other->start_);
  std::swap(goal_, other->goal_);
  std::swap(tolerance_, other->tolerance_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetPlanRequest::GetMetadata() const {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetPlanRequest

// .choreo.PoseStamped start = 1;
bool GetPlanRequest::has_start() const {
  return this != internal_default_instance() && start_ != NULL;
}
void GetPlanRequest::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) delete start_;
  start_ = NULL;
}
const ::choreo::PoseStamped& GetPlanRequest::start() const {
  // @@protoc_insertion_point(field_get:choreo.GetPlanRequest.start)
  return start_ != NULL ? *start_
                         : *::choreo::PoseStamped::internal_default_instance();
}
::choreo::PoseStamped* GetPlanRequest::mutable_start() {
  
  if (start_ == NULL) {
    start_ = new ::choreo::PoseStamped;
  }
  // @@protoc_insertion_point(field_mutable:choreo.GetPlanRequest.start)
  return start_;
}
::choreo::PoseStamped* GetPlanRequest::release_start() {
  // @@protoc_insertion_point(field_release:choreo.GetPlanRequest.start)
  
  ::choreo::PoseStamped* temp = start_;
  start_ = NULL;
  return temp;
}
void GetPlanRequest::set_allocated_start(::choreo::PoseStamped* start) {
  delete start_;
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.GetPlanRequest.start)
}

// .choreo.PoseStamped goal = 2;
bool GetPlanRequest::has_goal() const {
  return this != internal_default_instance() && goal_ != NULL;
}
void GetPlanRequest::clear_goal() {
  if (GetArenaNoVirtual() == NULL && goal_ != NULL) delete goal_;
  goal_ = NULL;
}
const ::choreo::PoseStamped& GetPlanRequest::goal() const {
  // @@protoc_insertion_point(field_get:choreo.GetPlanRequest.goal)
  return goal_ != NULL ? *goal_
                         : *::choreo::PoseStamped::internal_default_instance();
}
::choreo::PoseStamped* GetPlanRequest::mutable_goal() {
  
  if (goal_ == NULL) {
    goal_ = new ::choreo::PoseStamped;
  }
  // @@protoc_insertion_point(field_mutable:choreo.GetPlanRequest.goal)
  return goal_;
}
::choreo::PoseStamped* GetPlanRequest::release_goal() {
  // @@protoc_insertion_point(field_release:choreo.GetPlanRequest.goal)
  
  ::choreo::PoseStamped* temp = goal_;
  goal_ = NULL;
  return temp;
}
void GetPlanRequest::set_allocated_goal(::choreo::PoseStamped* goal) {
  delete goal_;
  goal_ = goal;
  if (goal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.GetPlanRequest.goal)
}

// .choreo.Float32 tolerance = 3;
bool GetPlanRequest::has_tolerance() const {
  return this != internal_default_instance() && tolerance_ != NULL;
}
void GetPlanRequest::clear_tolerance() {
  if (GetArenaNoVirtual() == NULL && tolerance_ != NULL) delete tolerance_;
  tolerance_ = NULL;
}
const ::choreo::Float32& GetPlanRequest::tolerance() const {
  // @@protoc_insertion_point(field_get:choreo.GetPlanRequest.tolerance)
  return tolerance_ != NULL ? *tolerance_
                         : *::choreo::Float32::internal_default_instance();
}
::choreo::Float32* GetPlanRequest::mutable_tolerance() {
  
  if (tolerance_ == NULL) {
    tolerance_ = new ::choreo::Float32;
  }
  // @@protoc_insertion_point(field_mutable:choreo.GetPlanRequest.tolerance)
  return tolerance_;
}
::choreo::Float32* GetPlanRequest::release_tolerance() {
  // @@protoc_insertion_point(field_release:choreo.GetPlanRequest.tolerance)
  
  ::choreo::Float32* temp = tolerance_;
  tolerance_ = NULL;
  return temp;
}
void GetPlanRequest::set_allocated_tolerance(::choreo::Float32* tolerance) {
  delete tolerance_;
  tolerance_ = tolerance;
  if (tolerance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.GetPlanRequest.tolerance)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SetMapRequest::kMapFieldNumber;
const int SetMapRequest::kInitialPoseFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SetMapRequest::SetMapRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_nav_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:choreo.SetMapRequest)
}
SetMapRequest::SetMapRequest(const SetMapRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_map()) {
    map_ = new ::choreo::OccupancyGrid(*from.map_);
  } else {
    map_ = NULL;
  }
  if (from.has_initial_pose()) {
    initial_pose_ = new ::choreo::PoseWithCovarianceStamped(*from.initial_pose_);
  } else {
    initial_pose_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:choreo.SetMapRequest)
}

void SetMapRequest::SharedCtor() {
  ::memset(&map_, 0, reinterpret_cast<char*>(&initial_pose_) -
    reinterpret_cast<char*>(&map_) + sizeof(initial_pose_));
  _cached_size_ = 0;
}

SetMapRequest::~SetMapRequest() {
  // @@protoc_insertion_point(destructor:choreo.SetMapRequest)
  SharedDtor();
}

void SetMapRequest::SharedDtor() {
  if (this != internal_default_instance()) {
    delete map_;
  }
  if (this != internal_default_instance()) {
    delete initial_pose_;
  }
}

void SetMapRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SetMapRequest::descriptor() {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const SetMapRequest& SetMapRequest::default_instance() {
  protobuf_nav_2eproto::InitDefaults();
  return *internal_default_instance();
}

SetMapRequest* SetMapRequest::New(::google::protobuf::Arena* arena) const {
  SetMapRequest* n = new SetMapRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SetMapRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:choreo.SetMapRequest)
  if (GetArenaNoVirtual() == NULL && map_ != NULL) {
    delete map_;
  }
  map_ = NULL;
  if (GetArenaNoVirtual() == NULL && initial_pose_ != NULL) {
    delete initial_pose_;
  }
  initial_pose_ = NULL;
}

bool SetMapRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:choreo.SetMapRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .choreo.OccupancyGrid map = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_map()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .choreo.PoseWithCovarianceStamped initial_pose = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_initial_pose()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:choreo.SetMapRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:choreo.SetMapRequest)
  return false;
#undef DO_
}

void SetMapRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:choreo.SetMapRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.OccupancyGrid map = 1;
  if (this->has_map()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->map_, output);
  }

  // .choreo.PoseWithCovarianceStamped initial_pose = 2;
  if (this->has_initial_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->initial_pose_, output);
  }

  // @@protoc_insertion_point(serialize_end:choreo.SetMapRequest)
}

::google::protobuf::uint8* SetMapRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:choreo.SetMapRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .choreo.OccupancyGrid map = 1;
  if (this->has_map()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->map_, deterministic, target);
  }

  // .choreo.PoseWithCovarianceStamped initial_pose = 2;
  if (this->has_initial_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->initial_pose_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:choreo.SetMapRequest)
  return target;
}

size_t SetMapRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:choreo.SetMapRequest)
  size_t total_size = 0;

  // .choreo.OccupancyGrid map = 1;
  if (this->has_map()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->map_);
  }

  // .choreo.PoseWithCovarianceStamped initial_pose = 2;
  if (this->has_initial_pose()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->initial_pose_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetMapRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:choreo.SetMapRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const SetMapRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const SetMapRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:choreo.SetMapRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:choreo.SetMapRequest)
    MergeFrom(*source);
  }
}

void SetMapRequest::MergeFrom(const SetMapRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:choreo.SetMapRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_map()) {
    mutable_map()->::choreo::OccupancyGrid::MergeFrom(from.map());
  }
  if (from.has_initial_pose()) {
    mutable_initial_pose()->::choreo::PoseWithCovarianceStamped::MergeFrom(from.initial_pose());
  }
}

void SetMapRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:choreo.SetMapRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetMapRequest::CopyFrom(const SetMapRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:choreo.SetMapRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetMapRequest::IsInitialized() const {
  return true;
}

void SetMapRequest::Swap(SetMapRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SetMapRequest::InternalSwap(SetMapRequest* other) {
  std::swap(map_, other->map_);
  std::swap(initial_pose_, other->initial_pose_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SetMapRequest::GetMetadata() const {
  protobuf_nav_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_nav_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SetMapRequest

// .choreo.OccupancyGrid map = 1;
bool SetMapRequest::has_map() const {
  return this != internal_default_instance() && map_ != NULL;
}
void SetMapRequest::clear_map() {
  if (GetArenaNoVirtual() == NULL && map_ != NULL) delete map_;
  map_ = NULL;
}
const ::choreo::OccupancyGrid& SetMapRequest::map() const {
  // @@protoc_insertion_point(field_get:choreo.SetMapRequest.map)
  return map_ != NULL ? *map_
                         : *::choreo::OccupancyGrid::internal_default_instance();
}
::choreo::OccupancyGrid* SetMapRequest::mutable_map() {
  
  if (map_ == NULL) {
    map_ = new ::choreo::OccupancyGrid;
  }
  // @@protoc_insertion_point(field_mutable:choreo.SetMapRequest.map)
  return map_;
}
::choreo::OccupancyGrid* SetMapRequest::release_map() {
  // @@protoc_insertion_point(field_release:choreo.SetMapRequest.map)
  
  ::choreo::OccupancyGrid* temp = map_;
  map_ = NULL;
  return temp;
}
void SetMapRequest::set_allocated_map(::choreo::OccupancyGrid* map) {
  delete map_;
  map_ = map;
  if (map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.SetMapRequest.map)
}

// .choreo.PoseWithCovarianceStamped initial_pose = 2;
bool SetMapRequest::has_initial_pose() const {
  return this != internal_default_instance() && initial_pose_ != NULL;
}
void SetMapRequest::clear_initial_pose() {
  if (GetArenaNoVirtual() == NULL && initial_pose_ != NULL) delete initial_pose_;
  initial_pose_ = NULL;
}
const ::choreo::PoseWithCovarianceStamped& SetMapRequest::initial_pose() const {
  // @@protoc_insertion_point(field_get:choreo.SetMapRequest.initial_pose)
  return initial_pose_ != NULL ? *initial_pose_
                         : *::choreo::PoseWithCovarianceStamped::internal_default_instance();
}
::choreo::PoseWithCovarianceStamped* SetMapRequest::mutable_initial_pose() {
  
  if (initial_pose_ == NULL) {
    initial_pose_ = new ::choreo::PoseWithCovarianceStamped;
  }
  // @@protoc_insertion_point(field_mutable:choreo.SetMapRequest.initial_pose)
  return initial_pose_;
}
::choreo::PoseWithCovarianceStamped* SetMapRequest::release_initial_pose() {
  // @@protoc_insertion_point(field_release:choreo.SetMapRequest.initial_pose)
  
  ::choreo::PoseWithCovarianceStamped* temp = initial_pose_;
  initial_pose_ = NULL;
  return temp;
}
void SetMapRequest::set_allocated_initial_pose(::choreo::PoseWithCovarianceStamped* initial_pose) {
  delete initial_pose_;
  initial_pose_ = initial_pose;
  if (initial_pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:choreo.SetMapRequest.initial_pose)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace choreo

// @@protoc_insertion_point(global_scope)
